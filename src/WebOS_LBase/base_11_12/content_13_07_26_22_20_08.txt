
luluping
posts - 1225, comments - 236, trackbacks - 1, articles - 5
  博客园 :: 首页 :: 新随笔 :: 联系 :: 订阅  :: 管理

日历
<	2009年4月	>
日	一	二	三	四	五	六
29	30	31	1	2	3	4
5	6	7	8	9	10	11
12	13	14	15	16	17	18
19	20	21	22	23	24	25
26	27	28	29	30	1	2
3	4	5	6	7	8	9

公告
昵称：linFen
园龄：5年4个月
粉丝：268
关注：3
+加关注

搜索
 

常用链接
我的随笔
我的评论
我的参与
最新评论
我的标签
更多链接

最新随笔
1. Stream 和 byte[] 之间的转换
2. WEB前端底层知识之浏览器是如何工作的(2)--渲染引擎
3. WEB前端底层知识之浏览器是如何工作的(4)--Render树与CSS解析
4. Spring.NET 1.3.2 集成 NHibernate 3.2 - 5 - 事务管理
5. sqlserver2005 使用OpenRowSet,opendatasource访问远程数据
6. ASP.NET MVC Razor 输出没有编码的HTML字符串
7. Sql结果导出为excel文件(转）
8. EXtJs_Grid:二基本属性
9. ext.grid的配置属性和方法
10. SQL Server系统函数

我的标签
jQuery(207)
js(170)
C#(161)
CSS(154)
javascript(135)
.NET(111)
sql(106)
DIV+CSS(93)
ASP.NET(92)
DIV(73)
更多

随笔分类
ajax(1)
asp.net(7)
C# 3.x(5)
CodeSmith
Css(1)
javascript(5)
SQL(2)
设计模式(c#)

随笔档案
2013年7月 (1)
2013年4月 (2)
2013年3月 (1)
2013年1月 (2)
2012年12月 (1)
2012年11月 (5)
2012年9月 (1)
2012年8月 (10)
2012年7月 (20)
2012年6月 (2)
2012年4月 (1)
2012年3月 (4)
2012年2月 (2)
2011年12月 (1)
2011年11月 (14)
2011年10月 (2)
2011年9月 (3)
2011年8月 (1)
2011年7月 (4)
2011年6月 (4)
2011年5月 (43)
2011年4月 (7)
2011年3月 (9)
2011年2月 (3)
2011年1月 (3)
2010年12月 (25)
2010年11月 (26)
2010年10月 (20)
2010年9月 (24)
2010年8月 (21)
2010年7月 (12)
2010年6月 (26)
2010年5月 (8)
2010年4月 (12)
2010年3月 (25)
2010年2月 (13)
2010年1月 (23)
2009年12月 (27)
2009年11月 (13)
2009年10月 (33)
2009年9月 (65)
2009年8月 (62)
2009年7月 (102)
2009年6月 (67)
2009年5月 (31)
2009年4月 (120)
2009年3月 (13)
2009年2月 (40)
2009年1月 (21)
2008年12月 (29)
2008年11月 (17)
2008年10月 (13)
2008年9月 (8)
2008年7月 (39)
2008年6月 (34)
2008年5月 (110)

文章分类
.net 3.0
ajax
asp.net 2.0(2)
CSS
javascript
SEO 学习
Silverlight
企业库
设计模式(C#)
数据库(1)
正则表达式

文章档案
2008年3月 (4)

相册
me

used Link
.net 3.0 tool
IE web develop
SEO blog
960 System css
asp.net mvc
ASP.NET MVC
ASP.NET MVC Blog
ASP.NET MVC 1.0
asp.net mvc blog
BlockUI
book site
c# code source
castl
cloudgamer js 高手
CodeSmith
css
css page
css Q&A
css useful Link
css88
CSS整理与优化工具
data acess help
EdoGantt易度甘特图功能示例和开发手册
english site
ESBasic
ESFramework 4.0 快速上手
ext
ext example
Ext2.2学习系列
extjs site
Flash
Flash 2
flex resource
html website2
Html教程
http://www.cnblogs.com/Jeez_JBF/
http://www.open-open.com/
imageScoll
img
javascript Game
javascript UI
jQuer Info
jQuery malsup
jQuery api
jquery blog
jQuery Cycle Plugin
jQuery Example
jQuery P
jQuery UI使用
jQuery 插件2
jQuery 的模板技术
jQuery 开源
jquery 无间缝滚动
jQuery 资源
jQuerybbs
jQuery爱好者
jQuery插件
jQuery特效展示
Jquery图片滚动插件—BxCarousel
jQuery中文博客
js blog
js link
js play
JSON网站
js框架事例
js特效
js学习网站（很多框架）
KISSY 快讯
Microsoft c#Windows程序设计(上下册)电子书下载
MongoDB
net企业级架构
NHibenate blog
office css element
office 开发
office 应用开发
PageControll
php
php userfull info
php 服务器配置
problem
PS、CSS与jQuery打造动态渐变特效按钮(3)
PS制作图片的矩形圆角效果
Scriptaculous学习
sharepoint
spring.net
Spring.NET blog
sql开发手册
subsonic
table
UI UI
UI Controls
UI Q&A
UI Web site
useful links
useful UI Links
w3css
WEB 2.0 Site
windows 程序
winfrom blog
wml 手机开发
WPF blog
yuyadong
存储过程
工作流
工作流图JS
基于Jquery图片滚动的marquee插件
开源描述
开源中国社区
李天平博客
面向对象
前台UI
权限
让VS2008对JQuery语法的智能感知更完美一点
时间管理
实例讲解基于jQuery的AJAX和JSON实现纯html数据模板
视频
视频播客
书库
数据库
淘宝前台开发
万年历
网页模板
网站
网站技术框架
文字滚动效果大集合
项目管理
有用的个人主页1

积分与排名
积分 - 381931
排名 - 188

阅读排行榜
1. jquery表单验证插件 jquery.form.js(36753)
2. 在css中定义滚动条样式(33946)
3. ExtJs之Ext.data.Store(26261)
4. jquery 与正则表达式应用 (25526)
5. C# String.Format格式说明(23741)
6. C#的String.Split方法(23139)
7. 软件需求分析方法(20992)
8. jquery 实现iframe 自适应高度(15710)
9. PowerDesigner使用教程 —— 概念数据模型 (转)(14326)
10. Oracle expdp/impdp导出导入命令及数据库备份(转)(12922)
11. SQL中使用update inner join和delete inner join(12452)
12. jQuery弹出层插件简化版(11972)
13. ORA-12528: TNS: 监听程序: 所有适用的例程都不允许建(11683)
14. 实时股票数据接口(11584)
15. Ext.GridPanel 用法总结（一）—— Grid基本用法(9876)
16. jQuery---window.open中的一些操作(7902)
17. 浅析求素数算法(7820)
18. jquery插件thickbox遮罩层的的使用 (7817)
19. 详细介绍ORACLE sqlplus命令(转)(7528)
20. jQuery中 index() 方法的使用 (7489)
21. 大型ORACLE数据库优化设计方案(7485)
22. jQuery、JSON超强组合 (7480)
23. Extjs中面板布局的应用(7297)
24. jQuery插件—获取URL参数(6921)
25. Windows下命令行下启动ORACLE服务(6642)
26. jQuery UI --- Layout(布局)(6445)
27. c#实现多线程代码例子(6127)
28. jQuery-图片预加载+等比例缩放(6027)
29. iframe里用jquery获取父页面body(5889)
30. ASP.NET 页面打印与预览 (5633)
31. jQuery.json.js(5575)
32. Windows下的.NET+ Memcached安装(5454)
33. 测试用例设计方法(5309)
34. android 自定义Dialog背景透明及显示位置设置(5103)
35. ASP.NET2.0中RegisterClientScriptBlock 怎样用(4993)
36. jquery UI入门手册(4812)
37. AJAX处理Session(4725)
38. Ext.Panel的主要功能(4710)
39. 排列组合的一些算法 (4701)
40. js实践篇：例外处理Try{}catch(e){}(4671)

推荐排行榜
1. jquery表单验证插件 jquery.form.js(7)
2. PowerDesigner使用教程 —— 概念数据模型 (转)(6)
3. 浅析求素数算法(5)
4. 聚集索引查询优化(3)
5. SQL Server死锁总结(3)
6. 软件需求分析方法(3)
7. C#的String.Split方法(3)
8. Razor引擎学习：RenderBody，RenderPage和RenderSection(2)
9. ExtJs之Ext.data.Store(2)
10. 测试用例设计方法(2)
11. CuteEditor学习总结技巧 (2)
12. 用WebORB实现flex + .net后台的Remoting(2)
13. 大型ORACLE数据库优化设计方案(2)
14. jQTreeTable在Asp.net中的应用(1)
15. oracle教程:PLSQL常用方法汇总(1)
16. C# winform treeview node添加右键菜单并选中节点(1)
17. 使用gui design studio做原型设计(1)
18. GUIDESIGNSTUDIO3中文帮助(1)-欢迎使用 GUI Design Studio 3.0(1)
19. gui design studio 3 中文帮助（2）-获取帮助(1)
20. gui design studio3 中文帮助（4）-用户界面 （中）-工具面板(1)
21. 原型设计实践-使用gui design studio进行原型设计(1)
22. 客户端原型GUI Design Studio(1)
23. DIV+CSS定义滚动条样式，实现内嵌效果(1)
24. 为VisualSVN Server增加在线修改用户密码的功能(1)
25. ADO.Net对Oracle数据库的操作【转载】(1)
26. memcached深度分析(1)
27. 分布式缓存系统Memcached学习心得(1)
28. UrlRewritingNet.UrlRewrite 中文文档(1)
29. flexigrid（一）如何获取并使用flexigrid？(1)
30. jquery 跨iframe拖拽(1)
31. Draggable的使用(1)
32. 淘宝网大规模网站如何进行性能测试！(1)
33. 在网站测试中如何做好安全性测试(1)
34. ASP.NET MVC + jQuery + Newtonsoft.Json 快乐的AJAX(1)
35. 技术高手讲评ASP.NET MVC 1.0(1)
36. 通过W3C XHTML1.0及CSS标准需要注意的九个问题(1)
37. jquery 与正则表达式应用 (1)
38. jQuery插件---tooltip(超链接提示,图片提示).(1)
39. Hoverbox.--鼠标经过图片显示大图(1)
40. CSS框架汇总.(1)
排列组合的一些算法
Posted on 2009-04-29 09:10 linFen 阅读(4702) 评论(2) 编辑 收藏
排列组合有多种实现方法，下面介绍整理的一些方法。

一、最简单直接的就是递归

       原理比较直接：计算一个集合的组合，首先选择一个元算，然后在剩下的集合中选择剩下的元素。看下面的源代码：

/**************************
 * 计算一个集合的组合
 *************************/
#include<stdlib.h>
#include<assert.h>
/*************************
 * 递归: 首先选择一个元素，然后在剩下的集合中选择其余元素
 ************************/
typedef struct LiStack
{
          char element;
          struct LiStack* prev;
          struct LiStack* next;
}LiStack;
typedef struct SqStack
{
         char *elements;
         int top;       /*栈指针*/
}SqStack;
//采用链式存储的栈, 双向链表:由栈顶指向栈底
void CalCombinationLi(const char Elements[], int SetLg, int k, LiStack *StackHead, LiStack *StackTail)
{//Elements:集合, SetLg:集合长度, k:要选取的元素个数, stackHead:指向栈顶, StackTail:指向栈底
                   LiStack* StackTmp;
                   LiStack* StackN;
                   int i;
                   assert(k<=SetLg);//如果要选取的元素个数超过集合长度，则出错
                  
                   if(k==0)
                   {//输出该次选取的元素组合
                            StackTmp = StackTail;
                            while(StackTmp)
                            {
                                               printf("%c ",StackTmp->element);
                                               StackTmp = StackTmp->prev;
                            }
                            printf(""n");
                            return;
                   }
                   //从该集合中顺序选取一个元素[i], 因为共选取k个元素, 所以最后一个可选择的元素为[SetLg-k]
                   //然后从剩下的集合[i+1:end]中选取其余的k-1个元素
                   //这样就构成了从集合(长度为SetLg)中选取k个元素, 按字典序的组合
                   for(i=0; i<=SetLg-k; ++i)
                   {
                            //将元素[i]压栈
                            StackN = (LiStack*)malloc(sizeof(LiStack));
                            StackN->element = Elements[i];
                            StackN->next = NULL;
                            StackN->prev = NULL;
                           
                            if(StackHead)
                            {
                                     StackHead->prev = StackN;
                                     StackN->next    = StackHead;         
                            }
                            else
                            {
                                     StackTail = StackN;  
                            }
                            StackHead = StackN;
                           
                            CalCombinationLi(Elements+i+1, SetLg-i-1, k-1, StackHead, StackTail);//从剩下的集合中选取k-1个元素
                           
                            //将元素[i]弹出栈
                            StackTmp = StackHead;
                            StackHead = StackHead->next;
                            free(StackTmp);
                            if(StackHead)
                            {
                                     StackHead->prev = NULL;        
                            }
                            else
                            {
                                     StackHead = NULL;
                                     StackTail = NULL;    
                            }
                   }
}
//采用顺序存储的栈
void CalCombinationSq(const char Elements[], int SetLg, int k, SqStack *stack)
{//Elements:集合, SetLg:集合长度, k:要选取的元素个数, stack:栈
         assert(k<=SetLg);
        
         int i;
         if(k==0)
         {//输出此次选取的元素组合
                   for(i=0; i<=stack->top; i++)//从栈底到栈顶
                   {
                            printf("%c ",stack->elements[i]);
                   }
                   printf(""n");
                   return;
         }
         for(i=0; i<=SetLg-k; i++)
         {
                  //将元素[i]压栈
                   stack->top++;
                   stack->elements[stack->top]=Elements[i];
                  
                   CalCombinationSq(Elements+i+1, SetLg-i-1, k-1, stack);
                  
                   //将元素[i]弹出栈
                   stack->top--;
         }
}
//测试
int main()
{
         char elements[] = {'a', 'b', 'c', 'd'};
         const int NUM = sizeof(elements) / sizeof(elements[0]);
         LiStack *StackHead=NULL, *StackTail=NULL;
         int i;
         SqStack *stack=(SqStack *)malloc(sizeof(SqStack));
         stack->elements = (char *)malloc(sizeof(elements));
         for(i=1; i<=NUM; i++)
         {
                   //CalCombinationLi(elements, NUM, i, StackHead, StackTail); 
                   CalCombinationSq(elements, NUM, i, stack);
         }
}
排列的源程序和上面的类似，其实上面的组合输出具有顺序性，和排列的输出没有多大的区别。

二、使用位运算（算法和程序来自网络）

       对于元素个数为n的集合，可以使用n为来表示每一个元素，为1表示该元素被选中，为0表示该元素未被选中。那么，计算组合C(n, k)就相当于计算出n位数中有k个1位的所有数，每一个计算出的数就表示一个选中的组合。源代码如下：

/*******************************
 * 计算一个集合的组合
 ******************************/
/******************************
 * 使用位运算来实现组合计算：对于元素个数为n的集合，可以使用n位来表示每一个元素，为1表示该元素被选中，为0表示该元素
 * 未被选中。那么，计算组合C(n, k)就相当于计算出n位数中有k个1位的所有数，每一个计算出的数就表示一个选中的组合
 *****************************/
#include<iostream>
#include<cassert>
using namespace std;
typedef unsigned int unint32_t;
 
//输出数表示的组合
template <typename T>
void OutputCombination(const T elements[], int num, uint32_t combinationBits)
{
         for(int i=0; i<num; i++)
         {
                   if(combinationBits & unint32_t(1)<<i)
                            cout << elements[i];
         }
         cout << endl;    
}
//产生跟pre有相同的1位，且比pre大的下一个数，如果存在，返回
uint32_t NextCombination(uint32_t pre)
{
         uint32_t lastOne = pre & -pre;
         uint32_t high = pre+lastOne;
        
         if(high == 0)
                   return 0;//已经达到最大值
         uint32_t mid = high^pre;
         uint32_t low = (mid>>2)/lastOne;
         return high | low;
}
template <typename T>
void GenAllCombination(const T elements[], int num, int k)
{
         assert(1<=num && num<=32 && 1<=k && k<=num);
        
         //产生最小的具有k个1的数
         uint32_t number = (uint32_t(1)<<k) - 1;
         //具有k个1的最大的num位数
         uint32_t maxNumber = number << (num-k);
        
         for(; true; number=NextCombination(number))
         {
                   OutputCombination(elements, num, number);
                   if(number==maxNumber)
                            break;
         }
}
//测试
int main()
{
         const int NUM = 5;
         char elements[NUM];
        
         for(int i=0; i<NUM; i++)
                   elements[i] = 'a'+i;
         GenAllCombination(elements, NUM, 2);
}
三、（算法来自网络）

       组合算法：开一个数组，其下标表示1到m个数，数组元素的值为1表示其下标代表的数被选中，为0则没有选中。

       首先初始化，将数组前n个元素置1，表示第一个组合为前n个数；然后从左到右扫描数组元素值的“10”组合，找到第一个“10”组合后将其变为“01”组合，同时将其左边的所有“1”全部移动到数组的最左端；当第一个“1”移动到数组的m-n位置，即n个“1”全部移动到最右端时，就得到了最后一个组合。

       例如求5中选3的组合：

       1     1     1     0     0     //1, 2, 3

       1     1     0     1     0     //1, 2, 4

       1     0     1     1     0     //1, 3, 4

       0     1     1     1     0     //2, 3, 4

       1     1     0     0     1     //1, 2, 5

       1     0     1     0     1     //1, 3, 5

       0     1     1     0     1     //2, 3, 5

       1     0     0     1     1     //1, 4, 5

       0     1     0     1     1     //2, 4, 5

       0     0     1     1     1     //3, 4, 5

源程序如下：

       /***********************

 * 计算一个集合的组合
 **********************/
#include<stdlib.h>
/*输出某个组合*/
void OutputCom(const char elements[], int *flags, int length)
{
         int i;
         for(i=0; i<length; i++)
         {
                   if(flags[i]==1)
                   {
                            printf("%c ",elements[i]);
                   }
         }
         printf(""n");
}
/*计算组合*/
int GenCom(const char elements[], int setLg, int k)
//elements:集合元素; setLg:集合长度; k:从集合中要选取的元素个数
{
         if(k>setLg || k<=0)
                   return -1;
 
         int i,j;                   //循环变量
         int has10; //是否有"10"组合的标志:1-有;0-无
         int bound; //第一个"10"组合的索引
         int num1;           //"10"组合左边的"1"的个数
         int *flags = (int *)malloc(setLg*sizeof(int));//与元素集合对应的标志:1-被选中;0-未被选中
         //初始化,将标志的前k个元素置1,表示第一个组合为前k个数
         for(i=0; i<k; i++)
                   flags[i]=1;
         for(i=k; i<setLg; i++)
                   flags[i]=0;
 
         OutputCom(elements, flags, setLg);//输出初始化的组合
         /*
                   从左到右扫描标志的"10"组合，找到第一个"10"组合后将其变为"01"组合，同时将其左边的所有"1"全部移动到数组的最左端
         */
         while(1)
         {
                   num1 = 0;
                   has10= 0;
                   for(i=0; i<setLg-1; i++)
                   {
                            if(flags[i]==1 && flags[i+1]==0)//找到第一个"10"组合
                            {
                                     bound = i;
 
                                     flags[i]=0;//将该"10"组合变为"01"组合
                                     flags[i+1]=1;
 
                                     for(j=0; j<num1; j++)//将其左边的所有"1"全部移动到数组的最左端
                                     {
                                               flags[j]=1;
                                     }
                                     for(j=num1; j<bound; j++)
                                     {
                                               flags[j]=0;
                                     }
 
                                     has10 = 1;
                                     break;
                            }
                            else if(flags[i]==1)
                            {
                                     num1++;
                            }
                   }
                   if(has10==0)//没有"10"组合了,代表组合计算完毕
                            break;
                   OutputCom(elements, flags, setLg);
         }
        
         return 1;
}
/*测试*/
int main()
{
         const char elements[5]="abcde";
         int setLg=5;
         GenCom(elements, setLg, 3);
         return 0;
}
 

       还有关于排列组合的其他算法，在此不述。在这些算法中，很容易理解的是递归，但其效率也很不理想。

标签: 算法
绿色通道： 好文要顶 关注我 收藏该文与我联系 
linFen
关注 - 3
粉丝 - 268
+加关注
0 0
(请您对文章做出评价)
« 上一篇：jQuery.json.js
» 下一篇：组合问题的递归算法
Feedback

#1楼   
2009-04-29 09:36 by 温景良(Jason)  
好长
支持(0)反对(0)
#2楼   
2013-07-24 10:58 by Lin.Zheng  
//组合，注意m<=n c(n,m)=p(n,m)/m!=n!/((n-m)!*m!)
function combination_sum(m, n) {
var temp_sum;
var temp_i;
temp_sum = 1;
if (n == 0 || m > n) temp_sum = 0;
if ((m != 0) && (m <= n) && (n != 0)) {
if (2 * m < n) m = n - m;
temp_i = m + 1;
while (temp_i <= n) {
temp_sum = temp_i * temp_sum;
temp_i = temp_i + 1;
}
temp_i = n - m;
while (temp_i > 1) {
temp_sum = temp_sum / temp_i;
temp_i = temp_i - 1;
}
}
return temp_sum;
}


//排序算法,注意m<=n 
function compositor_sum(m, n) {
var temp_sum = 0;
var temp_i;
temp_sum = 1;
if (n == 0 || m > n || m < 1) {
temp_sum = 0;
}
if ((m != 0) && (m <= n) && (n != 0) && (m > 0)) {
temp_i = n;
while (temp_i > (n - m)) {
temp_sum = temp_sum * temp_i;
temp_i = temp_i - 1;
}
}
return
支持(0)反对(0)
刷新评论刷新页面返回顶部
注册用户登录后才能发表评论，请 登录 或 注册，访问网站首页。
博客园首页博问新闻闪存程序员招聘知识库

最新IT新闻:
· 苹果赢得电脑平板手机年度最佳品牌称号
· IDC：二季度苹果三星份额下滑 LG联想中兴增速快
· 愤怒的小鸟里约版更新 关卡总数达到250个
· Android 4.3支持4K显示屏
· 亚马逊招聘政策遭吐槽：临时工转正前将被解雇
» 更多新闻...
最新知识库文章:
· Buffer Latch Timeout的解析
· 你优化系统的目标是什么？
· 淘宝图片服务的学习
· 即便没有读者，你也要写博客
· 学习新技术的10个建议
» 更多知识库文章...

Powered by: 
博客园 
Copyright © linFen
 
