Chinaunix首页　| 　论坛　| 　问答　| 　博客 登录 | 注册
    
随风...
我欲上青天 看沧海桑田.
2013第二季度“ChinaUnix博客之星”评选活动
五周年特别奉献：《IT架构实录》征文活动
【原创评选】2013年6-7月原创博文评选开始啦！
首页　| 　博文目录　| 　关于我

piaoyizu
博客访问： 696274
博文数量： 327
博客积分： 10594
博客等级： 上将
技术积分： 2375
用 户 组： 普通用户
注册时间： 2006-10-27 19:27

文章分类
全部博文（327）

Camera（2）
Embeddeb（170）
工作相关记录（52）
心情随笔（14）
English（8）
Bash脚本相关（22）
Linux C开发（59）
未分配的博文（0）
文章存档
2012年（5）

2011年（31）

2010年（44）

2009年（35）

2008年（99）

2007年（81）

2006年（32）

我的朋友

mxcai200

丹凤公主

liu090

johnbull

bsdc
最近访客

cu_fwang

壹米宽的

koka24

buaalyf

chenkun1

男人NO海

sunly_yg

y2009t

xhp0235
订阅
推荐博文
·[PowerVM]通过IVM在VIOS中创...
·SystemCenter2012SP1实践(33)...
·HAProxy 研究笔记 -- HTTP请...
·Sybase ASA数据库自动备份的...
·Java程序员从笨鸟到菜鸟之（...
热词专题
·c++枚举系统安装的硬盘...
·red5视频服务器
·libnet发包源码
·linux iowait process
·linux系统 office2003
友情链接
 ARM汇编学习的总结 2008-01-17 21:06:25
分类： C/C++
ARM汇编指令的一些总结
ARM汇编指令很多，但是真正常用的不是很多，而且需要认真琢磨的又更少了。
比较有用的是MOV B BL LDR STR
还是通过具体汇编代码来学习吧。
      @ disable watch dog timer     
   mov   r1, #0x53000000   //立即数寻址方式
   mov   r2, #0x0
   str   r2, [r1]       
MOV没有什么好说的，只要掌握几个寻址方式就可以了，而且ARM的寻址方式比386的简单很多。立即数寻址方式，立即数要求以“#”作前缀，对于十六进制的数，还要求在#后面加上0x或者&。0x大家很好理解。有一次我碰到了&ff这个数，现在才明白跟0xff是一样的。
STR是比较重要的指令了，跟它对应的是LDR。ARM指令集是加载/存储型的，也就是说它只处理在寄存器中的数据。那么对于系统存储器的访问就经常用到STR和LDR了。STR是把寄存器上的数据传输到指定地址的存储器上。它的格式我个人认为很特殊：
    STR(条件) 源寄存器，<存储器地址>
比如 STR R0, [R1] ，意思是R0-> [R1]，它把源寄存器写在前面，跟MOV、LDR都相反。
LDR应该是非常常见了。LDR就是把数据从存储器传输到寄存器上。而且有个伪指令也是LDR，因此我有个百思不得其解的问题。看这段代码：
mov r1, #GPIO_CTL_BASE
   add   r1, r1, #oGPIO_F
   ldr   r2,=0x55aa   // 0x55aa是个立即数啊，前面加个=干什么？
   str   r2, [r1, #oGPIO_CON]
   mov   r2, #0xff
   str   r2, [r1, #oGPIO_UP]
   mov   r2, #0x00
   str   r2, [r1, #oGPIO_DAT]
对于当中的ldr 那句，我就不明白了，如果你把=去掉，是不能通过编译的。我查了一些资料，个人感觉知道了原因：这个=应该表示LDR不是ARM指令，而是伪指令。作为伪指令的时候，LDR的格式如下：
    LDR 寄存器， =数字常量/Label
它的作用是把一个32位的地址或者常量调入寄存器。嗬嗬，那大家可能会问，
“MOV r2,#0x55aa”也可以啊。应该是这样的。不过，LDR是伪指令啊，也就是说编译时编译器会处理它的。怎么处理的呢？——规则如下：如果该数字常量在MOV指令范围内，汇编器会把这个指令作为MOV。如果不在MOV范围中，汇编器把该常量放在程序后面，用LDR来读取，PC和该常量的偏移量不能超过4KB。
这么一说，虽然似懂非懂，但是能够解释这个语句了。
 
 
然后说一下跳转指令。ARM有两种跳转方式。
（1） mov pc <跳转地址〉
 这种向程序计数器PC直接写跳转地址，能在4GB连续空间内任意跳转。
（2）通过 B BL BLX BX 可以完成在当前指令向前或者向后32MB的地址空间的跳转（为什么是32MB呢？寄存器是32位的，此时的值是24位有符号数，所以32MB）。
B是最简单的跳转指令。要注意的是，跳转指令的实际值不是绝对地址，而是相对地址——是相对当前PC值的一个偏移量，它的值由汇编器计算得出。
BL非常常用。它在跳转之前会在寄存器LR(R14)中保存PC的当前内容。BL的经典用法如下：
       bl NEXT   ; 跳转到NEXT
       ……
    NEXT
       ……
       mov pc, lr    ; 从子程序返回。
 
最后提一下Thumb指令。ARM体系结构还支持16位的Thumb指令集。Thumb指令集是ARM指令集的子集，它保留了32位代码优势的同时还大大节省了存储空间。由于Thumb指令集的长度只有16位，所以它的指令比较多。它和ARM各有自己的应用场合。对于系统性能有较高要求，应使用32位存储系统和ARM指令集；对于系统成本和功耗有较高要求，应使用16位存储系统和ARM指令集。
对ARM异常（Exceptions）的理解
分类:技术笔记
毕设笔记
1．对ARM异常（Exceptions）的理解
所有的系统引导程序前面中会有一段类似的代码，如下：
.globl _start                    ；系统复位位置
_start: b       reset            ；各个异常向量对应的跳转代码
        ldr     pc, _undefined_instruction ；未定义的指令异常
        ldr     pc, _software_interrupt     ；软件中断异常
        ldr     pc, _prefetch_abort          ；内存操作异常
        ldr     pc, _data_abort               ；数据异常
        ldr     pc, _not_used                  ；未使用
        ldr     pc, _irq                       ；慢速中断异常
        ldr     pc, _fiq                       ；快速中断异常
从中我们可以看出，ARM支持7种异常。问题时发生了异常后ARM是如何响应的呢？第一个复位异常很好理解，它放在0x0的位置，一上电就执行它，而且我们的程序总是从复位异常处理程序开始执行的，因此复位异常处理程序不需要返回。那么怎么会执行到后面几个异常处理函数呢？
看看书后，明白了ARM对异常的响应过程，于是就能够回答以前的这个疑问。
当一个异常出现以后，ARM会自动执行以下几个步骤：
（1）把下一条指令的地址放到连接寄存器LR(通常是R14)，这样就能够在处理异常返回时从正确的位置继续执行。
（2）将相应的CPSR(当前程序状态寄存器)复制到SPSR（备份的程序状态寄存器）中。从异常退出的时候，就可以由SPSR来恢复CPSR。
(3) 根据异常类型，强制设置CPSR的运行模式位。
（4）强制PC（程序计数器）从相关异常向量地址取出下一条指令执行，从而跳转到相应的异常处理程序中。
至于这些异常类型各代表什么，我也没有深究。因为平常就关心reset了，也没有必要弄清楚。
ARM规定了异常向量的地址：
   b       reset            ； 复位 0x0
ldr pc, _undefined_instruction ；未定义的指令异常 0x4
       ldr     pc, _software_interrupt     ；软件中断异常    0x8
       ldr     pc, _prefetch_abort          ；预取指令    0xc
       ldr     pc, _data_abort               ；数据        0x10
       ldr     pc, _not_used                  ；未使用      0x14
       ldr     pc, _irq                       ；慢速中断异常   0x18
        ldr   pc, _fiq                       ；快速中断异常    0x1c
这样理解这段代码就非常简单了。碰到异常时，PC会被强制设置为对应的异常向量，从而跳转到相应的处理程序，然后再返回到主程序继续执行。
这些引导程序的中断向量，是仅供引导程序自己使用的，一旦引导程序引导Linux内核完毕后，会使用自己的中断向量。
嗬嗬，这又有问题了。比如，ARM发生中断(irq)的时候，总是会跑到0x18上执行啊。那Linux内核又怎么能使用自己的中断向量呢？原因在于Linux内核采用页式存储管理。开通MMU的页面映射以后，CPU所发出的地址就是虚拟地址而不是物理地址。就Linux内核而言，虚拟地址0x18经过映射以后的物理地址就是0xc000 0018。所以Linux把中断向量放到0xc000 0018就可以了。
另外，说一下MMU。说句实话，还不是很明白这个MMU机理。参加Intel培训的时候，李眈说了MMU的两个主要作用：
(1）安全性：规定访问权限
 (2) 提供地址空间：把不连续的空间转换成连续的。
第2点是不是实现页式存储的意思？
2005年6月9日晚
补充一下：  05/06/14

.globl _start ；系统复位位置
_start: b reset ；各个异常向量对应的跳转代码
ldr pc, _undefined_instruction ；未定义的指令异常

……

_undefined_instruction :
.word undefined_instruction 

也许有人会有疑问，同样是跳转指令，为什么第一句用的是 b reset；
而后面的几个都是用ldr？

为了理解这个问题，我们以未定义的指令异常为例。

当发生了这个异常后，CPU总是跳转到0x4，这个地址是虚拟地址，它映射到哪个物理地址
取决于具体的映射。
ldr pc, _undefined_instruction 
相对寻址，跳转到标号_undefined_instruction，然而真正的跳转地址其实是_undefined_instruction的内容——undefined_instruction。那句.word的相当于：
_undefined_instruction dw undefined_instruction (详见毕设笔记3）。
这个地址undefined_instruction到底有多远就难说了，也许和标号_undefined_instruction在同一个页面，也许在很远的地方。不过除了reset，其他的异常是MMU开始工作之后才可能发生的，因此undefined_instruction 的地址也经过了MMU的映射。
在刚加电的时候，CPU从0x0开始执行，MMU还没有开始工作，此时的虚拟地址和物理地址相同；另一方面，重启在MMU开始工作后也有可能发生，如果reset也用ldr就有问题了，因为这时候虚拟地址和物理地址完全不同。

因此，之所以reset用b，就是因为reset在MMU建立前后都有可能发生，而其他的异常只有在MMU建立之后才会发生。用b reset，reset子程序与reset向量在同一页面，这样就不会有问题（b是相对跳转的）。如果二者相距太远，那么编译器会报错的。
 
 
阅读(2189) | 评论(0) | 转发(0) |
0
上一篇：从物理地址到内核虚拟地址的映射
下一篇：IBM POWERPC405 CPU lINUX下GPIO操作笔记
相关热门文章
PCI学习笔记
Linux应用开发学习01——Gcc编...
玩儿太阳城21点老虎机等是有技...
美国高中大学留学,美国留学申...
叛逆的辉煌 辉煌的叛逆...
test123
编写安全代码——小心有符号数...
使用openssl api进行加密解密...
一段自己打印自己的c程序...
sql relay的c++接口
 C++ 拷贝一个对象是什么意思...
innodb_max_dirty_pages_pct一...
latin1字符集能使用汉字吗？...
 Headers already send by PHP...
PHP 中什么时候用self vs $thi...
给主人留下些什么吧！~~
评论热议
请登录后评论。
登录 注册
关于我们 | 关于IT168 | 联系方式 | 广告合作 | 法律声明 | 免费注册
Copyright 2001-2010 ChinaUnix.net All Rights Reserved 北京皓辰网域网络信息技术有限公司. 版权所有
感谢所有关心和支持过ChinaUnix的朋友们
京ICP证041476号 京ICP证060528号

