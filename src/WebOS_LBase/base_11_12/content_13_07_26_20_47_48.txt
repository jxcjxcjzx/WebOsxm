djdhbjqdbwhjb0我的：收件箱资源博客空间设置|帮助|退出首页业界移动云计算研发论坛博客下载
更多
转角遇到嵌入式誓以春哥的霸气，凤姐的自信征服嵌入式！
目录视图摘要视图订阅
公告：博客新增直接引用代码功能        专访谭海燕：移动互联网开发的那些事      CSDN博客频道自定义摘要、图片水印、热门标签等功能上线啦      CSDN博客第二期云计算最佳博主评选     
 arm B和BL指令浅析
2011-03-19 11:00 2244人阅读 评论(0) 收藏 举报
linux内核汇编存储存储系统编译器工作
B或BL指令引起处理器转移到“子程序名”处开始执行。两者的不同之处在于BL指令在转移到子

程序执行之前，将其下一条指令的地址拷贝到R14（LR,链接寄存器）。由于BL指令保存了下条指令的地

址，因此使用指令“MOV PC ,LR”即可实现子程序的返回。而B指令则无法实现子程序的返回，只能实

现单纯的跳转。用户在编程的时候，可根据具体应用选用合适的子程序调用语句。

   AREA Init,CODE,READONLY 

;该伪指令定义了一个代码段，段名为Init，属性只读
ENTRY                      ;程序的入口点标识

.

.

bl delay                 ;调用延迟

.

.

mov pc,lr                 ;返回

下面的在BLOG中看到觉得讲得比较详细就拷过来了

ARM汇编指令的一些总结
ARM汇编指令很多，但是真正常用的不是很多，而且需要认真琢磨的又更少了。
比较有用的是MOV B BL LDR STR
还是通过具体汇编代码来学习吧。
      @ disable watch dog timer      
   mov   r1, #0x53000000   //立即数寻址方式 
   mov   r2, #0x0 
   str   r2, [r1]        
立即数寻址方式，立即数要求以“#”作前缀，对于十六进制的数，还要求在#后面加上0x或者&。STR是

比较重要的指令了，跟它对应的是LDR。ARM指令集是加载/存储型的，也就是说它只处理在寄存器中的

数据。那么对于系统存储器的访问就经常用到STR和LDR了。STR是把寄存器上的数据传输到指定地址的

存储器上。它的格式我个人认为很特殊：
    STR(条件) 源寄存器，<存储器地址>
比如 STR R0, [R1] ，意思是R0-> [R1]，它把源寄存器写在前面，跟MOV、LDR都相反。
LDR应该是非常常见了。LDR就是把数据从存储器传输到寄存器上。而且有个伪指令也是LDR，因此我有

个百思不得其解的问题。看这段代码：
mov r1, #GPIO_CTL_BASE 
   add   r1, r1, #oGPIO_F 
   ldr   r2,=0x55aa   // 0x55aa是个立即数啊，前面加个=干什么？ 
对于当中的ldr 那句，我就不明白了，如果你把=去掉，是不能通过编译的。我查了一些资料，个人感

觉知道了原因：这个=应该表示LDR不是ARM指令，而是伪指令。作为伪指令的时候，LDR的格式如下：
    LDR 寄存器， =数字常量/Label
它的作用是把一个32位的地址或者常量调入寄存器。嗬嗬，那大家可能会问，
“MOV r2,#0x55aa”也可以啊。应该是这样的。不过，LDR是伪指令啊，也就是说编译时编译器会处理

它的。怎么处理的呢？——规则如下：如果该数字常量在MOV指令范围内，汇编器会把这个指令作为MOV

。如果不在MOV范围中，汇编器把该常量放在程序后面，用LDR来读取，PC和该常量的偏移量不能超过

4KB。
然后说一下跳转指令。ARM有两种跳转方式。
（1） mov pc <跳转地址〉
这种向程序计数器PC直接写跳转地址，能在4GB连续空间内任意跳转。
（2）通过 B BL BLX BX 可以完成在当前指令向前或者向后32MB的地址空间的跳转（为什么是32MB呢？

寄存器是32位的，此时的值是24位有符号数，所以32MB）。
B是最简单的跳转指令。要注意的是，跳转指令的实际值不是绝对地址，而是相对地址——是相对当前

PC值的一个偏移量，它的值由汇编器计算得出。
BL非常常用。它在跳转之前会在寄存器LR(R14)中保存PC的当前内容。BL的经典用法如下：
        bl NEXT   ; 跳转到NEXT 
       …… 
    NEXT 
       …… 
       mov pc, lr    ; 从子程序返回。 
最后提一下Thumb指令。ARM体系结构还支持16位的Thumb指令集。Thumb指令集是ARM指令集的子集，它

保留了32位代码优势的同时还大大节省了存储空间。由于Thumb指令集的长度只有16位，所以它的指令

比较多。它和ARM各有自己的应用场合。对于系统性能有较高要求，应使用32位存储系统和ARM指令集；

对于系统成本和功耗有较高要求，应使用16位存储系统和ARM指令集。 
对ARM异常（Exceptions）的理解
分类:技术笔记
毕设笔记
1．对ARM异常（Exceptions）的理解
所有的系统引导程序前面中会有一段类似的代码，如下：
.globl _start                    ；系统复位位置
_start: b       reset            ；各个异常向量对应的跳转代码
        ldr     pc, _undefined_instruction ；未定义的指令异常
        ldr     pc, _software_interrupt     ；软件中断异常
        ldr     pc, _prefetch_abort          ；内存操作异常
        ldr     pc, _data_abort               ；数据异常
        ldr     pc, _not_used                  ；未使用
        ldr     pc, _irq                       ；慢速中断异常
        ldr     pc, _fiq                       ；快速中断异常

从中我们可以看出，ARM支持7种异常。问题时发生了异常后ARM是如何响应的呢？第一个复位异常很好

理解，它放在0x0的位置，一上电就执行它，而且我们的程序总是从复位异常处理程序开始执行的，因

此复位异常处理程序不需要返回。那么怎么会执行到后面几个异常处理函数呢？
看看书后，明白了ARM对异常的响应过程，于是就能够回答以前的这个疑问。
当一个异常出现以后，ARM会自动执行以下几个步骤：
（1）把下一条指令的地址放到连接寄存器LR(通常是R14)，这样就能够在处理异常返回时从正确的位置

继续执行。
（2）将相应的CPSR(当前程序状态寄存器)复制到SPSR（备份的程序状态寄存器）中。从异常退出的时

候，就可以由SPSR来恢复CPSR。
(3) 根据异常类型，强制设置CPSR的运行模式位。
（4）强制PC（程序计数器）从相关异常向量地址取出下一条指令执行，从而跳转到相应的异常处理程

序中。
至于这些异常类型各代表什么，我也没有深究。因为平常就关心reset了，也没有必要弄清楚。
ARM规定了异常向量的地址：
   b       reset            ； 复位 0x0
ldr pc, _undefined_instruction ；未定义的指令异常 0x4
       ldr     pc, _software_interrupt     ；软件中断异常    0x8
       ldr     pc, _prefetch_abort          ；预取指令    0xc
       ldr     pc, _data_abort               ；数据        0x10
       ldr     pc, _not_used                  ；未使用      0x14
       ldr     pc, _irq                       ；慢速中断异常   0x18
        ldr   pc, _fiq                       ；快速中断异常    0x1c
这样理解这段代码就非常简单了。碰到异常时，PC会被强制设置为对应的异常向量，从而跳转到相应的

处理程序，然后再返回到主程序继续执行。
这些引导程序的中断向量，是仅供引导程序自己使用的，一旦引导程序引导Linux内核完毕后，会使用

自己的中断向量。
嗬嗬，这又有问题了。比如，ARM发生中断(irq)的时候，总是会跑到0x18上执行啊。那Linux内核又怎

么能使用自己的中断向量呢？原因在于Linux内核采用页式存储管理。开通MMU的页面映射以后，CPU所

发出的地址就是虚拟地址而不是物理地址。就Linux内核而言，虚拟地址0x18经过映射以后的物理地址

就是0xc000 0018。所以Linux把中断向量放到0xc000 0018就可以了。
MMU的两个主要作用：
(1）安全性：规定访问权限
(2) 提供地址空间：把不连续的空间转换成连续的。
第2点是不是实现页式存储的意思？

.globl _start ；系统复位位置
_start: b reset ；各个异常向量对应的跳转代码
ldr pc, _undefined_instruction ；未定义的指令异常

……

_undefined_instruction :
.word undefined_instruction

也许有人会有疑问，同样是跳转指令，为什么第一句用的是 b reset；
而后面的几个都是用ldr？

为了理解这个问题，我们以未定义的指令异常为例。

当发生了这个异常后，CPU总是跳转到0x4，这个地址是虚拟地址，它映射到哪个物理地址
取决于具体的映射。
ldr pc, _undefined_instruction 
相对寻址，跳转到标号_undefined_instruction，然而真正的跳转地址其实是_undefined_instruction

的内容——undefined_instruction。那句.word的相当于：
_undefined_instruction dw undefined_instruction (详见毕设笔记3）。
这个地址undefined_instruction到底有多远就难说了，也许和标号_undefined_instruction在同一个

页面，也许在很远的地方。不过除了reset，其他的异常是MMU开始工作之后才可能发生的，因此

undefined_instruction 的地址也经过了MMU的映射。
在刚加电的时候，CPU从0x0开始执行，MMU还没有开始工作，此时的虚拟地址和物理地址相同；另一方

面，重启在MMU开始工作后也有可能发生，如果reset也用ldr就有问题了，因为这时候虚拟地址和物理

地址完全不同。

因此，之所以reset用b，就是因为reset在MMU建立前后都有可能发生，而其他的异常只有在MMU建立之

后才会发生。用b reset，reset子程序与reset向量在同一页面，这样就不会有问题（b是相对跳转的）

。如果二者相距太远，那么编译器会报错的

分享到： 
上一篇：深度分析NandFlash—控制器参数TACLS、TWRPH0和TWRPH1的确定（以TQ2440开发板上的K9F2G08U0A为例）
下一篇：S3C2440启动方式研究

查看评论

  暂无评论

发表评论
用 户 名：
u011520465
评论内容：


  
* 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场

个人资料
  
IT_114
 
访问：51453次
积分：897分
排名：第12615名
原创：32篇转载：21篇译文：2篇评论：39条

文章搜索

文章分类
bootloader(0)
Linux C/C++(2)
linux 2.6 内核学习笔记(3)
linux驱动学习笔记(0)
uboot移植系列(2)
哥的那些事(0)
嵌入式底层开发(15)
工作中的积累(0)
深度分析NandFlash系列(0)
文章存档
2011年04月(18)
2011年03月(28)
2011年02月(9)
阅读排行
u-boot-2011.03在TQ2440上的移植(1)--建立自己的demo板(2764)
u-boot-2011.03在TQ2440上的移植(3)--支持norflash启动(2536)
深度分析NandFlash—控制器参数TACLS、TWRPH0和TWRPH1的确定（以TQ2440开发板上的K9F2G08U0A为例）(2460)
u-boot-2011.03在TQ2440上的移植(4)--支持nandflash启动(2350)
arm B和BL指令浅析(2244)
u-boot-2011.03在TQ2440上的移植(2)--初始化时钟(2077)
特别详细好懂的一篇文章：s3c2440 -linux-LED驱动(1738)
深度分析NandFlash—物理结构及地址传送（以TQ2440开发板上的K9F2G08U0A为例）(1668)
u-boot-2011.03在TQ2440上的移植(6)--支持dm9000x网卡(1597)
u-boot-2011.03在TQ2440上的移植(11)--支持USB下载(1467)
评论排行
u-boot-2011.03在TQ2440上的移植(1)--建立自己的demo板(11)
深度分析NandFlash—控制器参数TACLS、TWRPH0和TWRPH1的确定（以TQ2440开发板上的K9F2G08U0A为例）(7)
深度分析NandFlash—物理结构及地址传送（以TQ2440开发板上的K9F2G08U0A为例）(4)
s3c2440的时钟详解(4)
u-boot-2011.03在TQ2440上的移植(4)--支持nandflash启动(3)
u-boot-2011.03在TQ2440上的移植(3)--支持norflash启动(2)
S3C2440对Nand Flash操作和电路原理(基于K9F2G08U0A)(2)
u-boot-1.1.6 源码分析（3）--第二阶段(1)
深度分析NandFlash—硬件实现机制(1)
u-boot-2011.03在TQ2440上的移植(11)--支持USB下载(1)
推荐文章

最新评论
s3c2440的时钟详解
雨漫海阔: 不错，学习了，给力！
深度分析NandFlash—控制器参数TACLS、TWRPH0和TWRPH1的确定（以TQ2440开发板上的K9F2G08U0A为例）
kangear: 这个似乎不对“TACLS：表示CLT/ALE的建立时间(setup time)。”改成这个“TACL...
u-boot-2011.03在TQ2440上的移植(3)--支持norflash启动
lap89: #define CONFIG_EON_29LV160AB 这里的29去掉，否则回报错
u-boot-2011.03在TQ2440上的移植(3)--支持norflash启动
lap89: #define CONFIG_EON_29LV160AB 1 //添加TQ24...
深度分析NandFlash—控制器参数TACLS、TWRPH0和TWRPH1的确定（以TQ2440开发板上的K9F2G08U0A为例）
happain123: 却是是符合时序要求了，但是浪费在无用的时间太多了
深度分析NandFlash—控制器参数TACLS、TWRPH0和TWRPH1的确定（以TQ2440开发板上的K9F2G08U0A为例）
dog_who: TWRPH1：表示nWE无效到数据或地址无效的延时；TACLS=Tcls-Twp 表示地址锁存到W...
s3c2440的时钟详解
ZJF_897748037: 写的挺好 对于新手 特别易于理解！顶！
深度分析NandFlash—控制器参数TACLS、TWRPH0和TWRPH1的确定（以TQ2440开发板上的K9F2G08U0A为例）
astrotycoon: 我是一个初学者，学习到这块时对这几个参数很是迷惑，书上的值不知道怎么来的，看了你的文章，我学会了学习...
深度分析NandFlash—控制器参数TACLS、TWRPH0和TWRPH1的确定（以TQ2440开发板上的K9F2G08U0A为例）
yuzhoudiwang: 结合上面的图，就可以看出TACLS就相当于tCLS和tALS参数???这个貌似不对吧！你貌似把图粘错...
u-boot-2011.03在TQ2440上的移植(1)--建立自己的demo板
wanglinuxwang: 哥们，请问你方便留下你的联系方式吗？ 请教关于uboot和kernel方面问题？想找个师傅。。。 我...
公司简介|招贤纳士|广告服务|银行汇款帐号|联系方式|版权声明|法律顾问|问题报告
QQ客服 微博客服 论坛反馈 联系邮箱：webmaster@csdn.net 服务热线：400-600-2320
京 ICP 证 070598 号
北京创新乐知信息技术有限公司 版权所有
世纪乐知(北京)网络技术有限公司 提供技术支持
江苏乐知网络技术有限公司 提供商务支持
Copyright © 1999-2012, CSDN.NET, All Rights Reserved 
  
