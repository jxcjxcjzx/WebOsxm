



liuhuiyi的专栏

真正的勇士要学会为做一件事卧薪尝胆，默默无闻……


 


目录视图
摘要视图
订阅
 . 



2014年1月微软MVP申请开始啦！       2013年10月微软MVP当选名单揭晓！      Tag功能介绍—我们为什么打Tag      “说说家乡的互联网”主题有奖征文 



C\C++编译器关于变量的内存分配顺序总结 
.
 分类： 内存2012-05-02 09:491304人阅读评论(1)收藏举报
 
编译器cc++测试存储优化

 

       关于《纠结的N皇后问题》中数组越界导致的sum出现非正常的变化这个问题，继而引发出关于内存到底是如何被分配的疑问，今天早上便着手进行探索，当然其中借鉴了广大网友的总结，其中包括birdzb，NEO等牛人关于这方面的讨论。特别是看到一些讨论，感触颇深啊http://www.programfan.com/club/showtxt.asp?id=191048。怎么说呢，我还是觉得研究一下是有必要的，但要注意适可而止。
 
       知识储备：1. 内存的分区：代码区，数据区，堆，栈。 四个区域司职不同，相互配合。
 
                         2. 变量的分类以及初始化情况：局部变量，全局变量，静态的，非静态的。C++里面又包括成员变量。
 
一. 局部变量
 
编译器按照内存地址递减的方式来给变量分配内存
 
局部变量很多书籍中也叫自动变量，它声明在函数块内，作用范围也在函数块内。 不能被同一源文件的其他函数使用，也不能被其他文件中的函数使用。局部变量存储在栈中。无论局部变量显示初始化，或者未初始化，都只有当定义它们的程序块被调用时（即执行时），才分配空间，声明或定义时并不分配。局部变量不是可执行模块的一部分！！除非显示地对局部变量进行初始化，否则，它们的初始值是不确定的。为了验证“编译器按照内存地址递减的方式来给变量分配内存”，我们进行如下实验：
 
测试一：
 #include "iostream"
using namespace std;

void main() {
	int i,j;
	cout<<&i<<' '<<&j<<endl;
} 
测试结果是：
 
&i = 0012FF44, &j = 0012FF40
 
可见，虽然i在j之前被定义，但在编译器给变量分配内存时采用了内存地址递减的方式，所以j在内存中的位置比i超前了4个字节(因为是整型)。
 
测试二：
 #include "iostream"
using namespace std;

void main() {
	int j,i;
	cout<<&i<<' '<<&j<<endl;
} 
测试结果是：
 
&i = 0012FF40， &j =  0012FF44
 
根据上面说明的采用内存递减的方式进行空间分配的话，首先分配的 j ,然后分配i，测试一首先分配i，然后分配j。
 
由此可见：在局部变量分配空间的顺序跟变量的声明顺序直接相关，同时按照内存由高到低的顺序进行空间分配。
 
下面看一段代码可以加深对数组越界出现昨天那个问题的理解。
 int i,a[10];
 for(i=1;i<=10;i++)
  a[i]=0; 
在for语句的比较部分本来是i<10;却写成了i<=10;因此实际上并不存在的a[10]被设置为0，也就是内存在数组a之后的一个字(word)的内存被设置为0。如果用来编译这段程序的编译器按照内存地址递减的方式来给变量分配内存，那么内存中数组a之后的一个字(word)实际上是分配给了整型变量i。此时本来循环计数器i的值为10，循环体内将并不存在的a[10]设置为0，实际上却是将计数器i的值设置为0，这就陷入死循环。
 #include <iostream.h>
void main()
{
 int i,a[4];
 cout<<&i<<endl<<&a[0]<<' '<<&a[1]<<' '<<&a[2]<<' '<<&a[3]<<' '<<&a[4]<<endl;
} 
这段代码的执行结果：
 
0x0012FF44
 0x0012FF34 0x0012FF38 0x0012FF3C 0x0012FF40 0x0012FF44
 由此可以发现&i = &a[4],因为先声明的是i,然后才是a[4]，故i处于高位，a处于低位，但是越界后a[4]来到高位，覆盖i
 #include <iostream.h>
void main()
{
 int a[4],i;
 cout<<&i<<endl<<&a[0]<<' '<<&a[1]<<' '<<&a[2]<<' '<<&a[3]<<' '<<&a[4]<<endl;
}
 

这段代码的执行结果：
 
0x0012FF34
 0x0012FF38 0x0012FF3C 0x0012FF40 0x0012FF44 0x0012FF48
 
由于首先声明的是数组a[4]，于是在高位上优先分配a，低位上分配i，因此可以发现这是并没有出现&i = &a[4]的情况。此时要是执行的话程序就不是假死了，直接是内存出错。
 
二. 全局变量
 

全局变量没有声明在任何一个函数内，作用范围在程序运行始终存在。能被同一源文件的任何函数使用，也能被其他文件中的函数使用，但要使用extern关键字。全局变量存储在数据段中。全局变量显示初始化时，或者未初始化时，在程序映像中有不同的分区：已初始化的全局变量是可执行模块的一部分。未初始化的全局变量则不是可执行模块的一部分，只有当定义它们的程序被调用时（即执行时），才分配空间，声明或定义时并不分配。未初始化的全局变量在运行时被初始化为0。
 
全局变量的空间一般分配在数据区，因此并不像局部变量那样在函数被调用的时候才按照声明顺序由递减的方式分配空间，全局变量在编译阶段就会把空间分配完毕，这其中的机制根据编译器的优化以及操作系统的原理都有很大的不同。
 
猜测一： 全局变量的显示初始为0与默认初始化为0效果一致，并不会导致内存分配地址出现不同，这时候遵循的规则是按章全局变量命名的字母顺序分配空间。
 #include <iostream.h>
int a;
int c;
int b;
void main() {
	cout<<&a<<' '<<&b<<' '<<&c<<endl;
}
 
0x0042E058 0x0042E05C 0x0042E060
 #include <iostream.h>

int c=0;
int a;
int b;
void main() {
	cout<<&a<<' '<<&b<<' '<<&c<<endl;
}
 

0x0042E058 0x0042E05C 0x0042E060
 
由上述代码可以推测当所有的变量都默认初始化，或者显示初始化为0时，空间分配是按照声明变量的字母顺序按照空间递增顺序进行分配的。
 
添加数组测试用例：
 #include <iostream.h>
int a[2];
int b;
void main() {
	cout<<&a[0]<<' '<<&a[1]<<' '<<&a[2]<<endl<<&b<<endl;
}

 

0x0042E058 0x0042E05C 0x0042E060
 0x0042E060
 
#include <iostream.h>
int b;
int a[2];
void main() {
	cout<<&a[0]<<' '<<&a[1]<<' '<<&a[2]<<endl<<&b<<endl;
} 

0x0042E058 0x0042E05C 0x0042E060
 0x0042E060
 可见两者的测试结果相同，说明的验证是正确的，作为默认初始化或者显示初始化为0的全局变量，其内存的分配与声明顺序无关，与变量命名的字母顺序有关。进一步测试：
 #include <iostream.h>
int c[2];
int b;

void main() {
	cout<<&c[0]<<' '<<&c[1]<<' '<<&c[2]<<endl<<&b<<endl;
}

 

0x0042E05C 0x0042E060 0x0042E064
 0x0042E058
 
#include <iostream.h>

int b;
int c[2];
void main() {
	cout<<&c[0]<<' '<<&c[1]<<' '<<&c[2]<<endl<<&b<<endl;
} 

0x0042E05C 0x0042E060 0x0042E064
 0x0042E058
 数组也满足这样的猜测，其内存的分配按照变量名的字母顺序进行递增分配。
 
但是这时候要是有个有个变量初始化为0，结果就不按字母顺序进行递增分配了，而是按照声明顺序进行。
 
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
 
上述猜测只对全局变量的命名为单字母成立，且字母的排序按照ASCII码中字母的顺序进行比较。如果全局变量的命名是多字母，或者数组中数值是宏并不是数字(若MAX = 4,那么a[MAX]被分配的地址与a[4]有可能不同)，甚至因为代码的优化也会影响到地址的分配。这时候的规律是很难找的，而且也没有意义，最重要的是在自己写程序的时候尽量不要出现程序越界之后溢出覆盖的情形，那样是在太危险了。
 
不得不说别人说的很有道理，猜测一直接 陷入混乱，可能编译器的规则实在太多了，不能深究，掌握一些基本的就可以了。
 
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
 
猜测二：全局变量初始化为非零的初始值时，内存分配按照声明顺序进行的
 
#include <iostream.h>
int b=1;
int c=2;
int a=1;

void main() {
	cout<<&a<<' '<<&b<<' '<<&c<<endl;
}

 

0x0042D708 0x0042D700 0x0042D704
 
#include <iostream.h>
int a=1;
int b=1;
int c=2;
void main() {
	cout<<&a<<' '<<&b<<' '<<&c<<endl;
}

 

0x0042D700 0x0042D704 0x0042D708
 由上述两个测试可以推测，当所有的全局变量初始化为非零值时，空间分配按照声明顺序按空间递增进行分配。 
 
总结
 
       事实上，全局变量不管有没有被初始化，其实都是被存放在DATA这个域中的，但是唯一不同的是这个DATA数据域有的时候又被划分成几个小的区域(说有的时候是因为并不是所有的系统都一定会这样做),分成initialized和un-initialized，因此，我们讨论的全局变量默认初始化或者初始化为零时，数据存储在un-initilized区域中，被初始化为非零时，数据存储在initialized区域中
 

 
 

 
 

 
 






上一篇：让人纠结的N皇后问题
下一篇：C++内存地址分配与划分
 .
顶2踩1. 


查看评论
 



* 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场
 







个人资料 

liuhuiyi 




访问：32079次
积分：765分
排名：第16434名
 . 原创：38篇
转载：27篇
译文：0篇
评论：12条
 . 
文章搜索

. 
文章分类 回溯(1) 
内存(3) 
生活小札(1) 
编码(20) 
调试(4) 
数据结构 二叉树(1) 
排序(1) 
DLL(5) 
软件技巧(3) 
安全(14) 
Vijos(7) 
动态规划(4) 
链表(3) 

文章存档 
2013年08月(1).
2013年05月(1).
2013年04月(1).
2013年03月(4).
2013年02月(1).
2013年01月(1).
2012年12月(3).
2012年11月(17).
2012年08月(4).
2012年07月(24).
2012年06月(1).
2012年05月(4).
2012年04月(3).
 . 
阅读排行 CSP开发基础--CayptAPI函数库介绍(2371) 
结构体的内存分配(2019) 
数字证书原理(1459) 
PKI系统深入介绍(1443) 
CSP开发基础--数字证书调用CSP过程(1427) 
CSP开发基础--如何将USBkey中的证书注册到Windows系统中(1371) 
程序中关于堆栈大小的划定(1319) 
C\C++编译器关于变量的内存分配顺序总结(1304) 
CSP开发基础--CryptoAPI函数简介(1126) 
CSP开发基础--CSP开发流程(1116) 

评论排行 Windows下多进程的实现案例(4) 
CSP开发基础--如何将USBkey中的证书注册到Windows系统中(3) 
关于main(int argc, char* argv[])的理解(1) 
CSP开发基础--开发实例一(1) 
PKI系统深入介绍(1) 
结构体的内存分配(1) 
C\C++编译器关于变量的内存分配顺序总结(1) 
1385(0) 
用指针操作实现二分法程序(0) 
计算日期，天数,星期几的小例子(0) 

推荐文章 
最新评论 Windows下多进程的实现案例
liuhuiyi: @h_yongqiang:我认为以我说的这种方式启动通过主进程启动了多个子进程之后，子进程的运行就与... 

Windows下多进程的实现案例
h_yongqiang: 真的多谢你的恢复，我这段时间按照你的方法可以运行几个进程加多线程的程序了，可我有点像问你，就是我希望... 

关于main(int argc, char* argv[])的理解
pandafxp: 明白了、THX~~~ 

CSP开发基础--如何将USBkey中的证书注册到Windows系统中
liuhuiyi: @bluetz_2011:首先这个证书所对应的私钥一定要在证书安装的计算机上。明确一点私钥是不能真正... 

Windows下多进程的实现案例
liuhuiyi: @h_yongqiang:首先你是使用的那个平台？Win下的多进程我可以给你解释一下：创建进程函数C... 

Windows下多进程的实现案例
h_yongqiang: 你好，遇到个问题，也是多进程，每个进程下面多个线程运行，不知道是这么实现的，你上面这段c的代码只是提... 

CSP开发基础--开发实例一
zhuifeng06: vc6.0须加 

CSP开发基础--如何将USBkey中的证书注册到Windows系统中
liuhuiyi: @bluetz_2011:什么类型的证书？ 

CSP开发基础--如何将USBkey中的证书注册到Windows系统中
bluetz_2011: 您好，想请教一个问题，如何利用cryptoAPI函数获取一个指定公钥证书对应的私钥？谢谢！ 

结构体的内存分配
tsmaomaoyu: 这篇文章错误不少,我仅拿出一个例子说一下:struct s { int i; char ... 



. 
