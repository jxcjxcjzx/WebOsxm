



结构之法 算法之道

Google或baidu搜索：“结构之法”，进入本博客


 


目录视图
摘要视图
订阅
 . 



《这些年，我们读过的技术经典图书》主题有奖征文       专访李铁军：从医生到金山首席安全专家的转变      独一无二的职位：开源社区经理        CSDN博客第三期云计算最佳博主评选
 


经典算法研究系列：五、红黑树算法的实现与剖析 
.
 分类： 25.Red-black tree01.Algorithms（研究）2010-12-31 11:1045440人阅读评论(105)收藏举报
 
算法tree照片工作出版blog

 
                     红黑树算法的层层剖析与逐步实现


 

----

作者 July  二零一零年十二月三十一日

本文主要参考：算法导论第二版
本文主要代码：参考算法导论。
本文图片来源：个人手工画成、算法导论原书。
推荐阅读：Leo J. Guibas 和 Robert Sedgewick 于1978年写的关于红黑树的一篇论文。
--------------------------------------------------------------
1、教你透彻了解红黑树2、红黑树算法的实现与剖析3、红黑树的c源码实现与剖析4、一步一图一代码，R-B Tree5、红黑树插入和删除结点的全程演示6、红黑树的c++完整实现源码
---------------------------------------------------------------

 

引言： 

昨天下午画红黑树画了好几个钟头，总共10页纸。
特此，再深入剖析红黑树的算法实现，教你如何彻底实现红黑树算法。

经过我上一篇博文，“教你透彻了解红黑树”后，相信大家对红黑树已经有了一定的了解。
个人觉得，这个红黑树，还是比较容易懂的。
不论是插入、还是删除，不论是左旋还是右旋，最终的目的只有一个：
即保持红黑树的5个性质，不得违背。

再次，重述下红黑树的五个性质：
一般的，红黑树，满足一下性质，即只有满足一下性质的树，我们才称之为红黑树：
1）每个结点要么是红的，要么是黑的。
2）根结点是黑的。
3）每个叶结点，即空结点（NIL）是黑的。
4）如果一个结点是红的，那么它的俩个儿子都是黑的。
5）对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。


抓住了红黑树的那5个性质，事情就好办多了。
如，
1.红黑红黑，要么是红，要么是黑；
2.根结点是黑；
3.每个叶结点是黑；
4.一个红结点，它的俩个儿子必然都是黑的；
5.每一条路径上，黑结点的数目等同。
   五条性质，合起来，来句顺口溜就是：（1）红黑 （2）黑 （3）黑 （4&5）红->黑 黑。

 

本文所有的文字，都是参照我昨下午画的十张纸（即我拍的照片）与算法导论来写的。

希望，你依照此文一点一点的往下看，看懂此文后，你对红黑树的算法了解程度，一定大增不少。

 

ok，现在咱们来具体深入剖析红黑树的算法，并教你逐步实现此算法。

此教程分为10个部分，每一个部分作为一个小节。且各小节与我给的十张照片一一对应。

 

一、左旋与右旋

     先明确一点：为什么要左旋?

因为红黑树插入或删除结点后，树的结构发生了变化，从而可能会破坏红黑树的性质。

为了维持插入、或删除结点后的树，仍然是一颗红黑树，所以有必要对树的结构做部分调整，从而恢复红黑树的原本性质。

而为了恢复红黑性质而作的动作包括：

结点颜色的改变(重新着色)，和结点的调整。

这部分结点调整工作，改变指针结构，即是通过左旋或右旋而达到目的。

从而使插入、或删除结点的树重新成为一颗新的红黑树。

 

ok，请看下图：



如上图所示，‘找茬’

如果你看懂了上述俩幅图有什么区别时，你就知道什么是“左旋”，“右旋”。

 

在此，着重分析左旋算法：

左旋，如图所示（左->右），以x->y之间的链为“支轴”进行，

使y成为该新子树的根，x成为y的左孩子，而y的左孩子则成为x的右孩子。

算法很简单，还有注意一点，各个结点从左往右，不论是左旋前还是左旋后，结点大小都是从小到大。

 

左旋代码实现，分三步（注意我给的注释）：

The pseudocode for LEFT-ROTATE assumes that right[x] ≠ nil[T] and that the root's parent is nil[T]. 

LEFT-ROTATE(T, x)
 1  y ← right[x]            ▹ Set y.
 2  right[x] ← left[y]                   //开始变化，y的左孩子成为x的右孩子

 3  if left[y]  ！=nil[T]

 4  then p[left[y]] <- x                

 5  p[y] <- p[x]                       //y成为x的父母
 6  if p[x] = nil[T]

 7     then root[T] <- y

 8     else if x = left[p[x]]
 9             then left[p[x]] ← y
10             else right[p[x]] ← y
11  left[y] ← x             //x成为y的左孩子（一月三日修正）

12  p[x] ← y
//注，此段左旋代码，原书第一版英文版与第二版中文版，有所出入。

//个人觉得，第二版更精准。所以，此段代码以第二版中文版为准。

 

左旋、右旋都是对称的，且都是在O（1）时间内完成。因为旋转时只有指针被改变，而结点中的所有域都保持不变。

最后，贴出昨下午关于此左旋算法所画的图：

左旋（第2张图）：



//此图有点bug。第4行的注释移到第11行。如上述代码所示。（一月三日修正）

 



二、左旋的一个实例

不做过多介绍，看下副图，一目了然。

LEFT-ROTATE(T, x)的操作过程（第3张图）：

 

--------------------- 

提醒，看下文之前，请首先务必明确，区别以下俩种操作：

1.红黑树插入、删除结点的操作

         //如插入中，红黑树插入结点操作：RB-INSERT(T, z)。

2.红黑树已经插入、删除结点之后，

为了保持红黑树原有的红黑性质而做的恢复与保持红黑性质的操作。

        //如插入中，为了恢复和保持原有红黑性质，所做的工作：RB-INSERT-FIXUP(T, z)。

ok，请继续。

 

三、红黑树的插入算法实现

RB-INSERT(T, z)   //注意我给的注释...
 1  y ← nil[T]                 // y 始终指向 x 的父结点。
 2  x ← root[T]              // x 指向当前树的根结点，
 3  while x ≠ nil[T]
 4      do y ← x
 5         if key[z] < key[x]           //向左，向右..
 6            then x ← left[x]
 7            else x ← right[x]         // 为了找到合适的插入点，x 探路跟踪路径，直到x成为NIL 为止。
 8  p[z] ← y         // y置为 插入结点z 的父结点。
 9  if y = nil[T]
10     then root[T] ← z
11     else if key[z] < key[y]
12             then left[y] ← z
13             else right[y] ← z     //此 8-13行，置z 相关的指针。
14  left[z] ← nil[T]
15  right[z] ← nil[T]            //设为空，
16  color[z] ← RED             //将新插入的结点z作为红色
17  RB-INSERT-FIXUP(T, z)   //因为将z着为红色，可能会违反某一红黑性质，

                                            //所以需要调用RB-INSERT-FIXUP(T, z)来保持红黑性质。

17 行的RB-INSERT-FIXUP(T, z) ，在下文会得到着重而具体的分析。

还记得，我开头说的那句话么，

是的，时刻记住，不论是左旋还是右旋，不论是插入、还是删除，都要记得恢复和保持红黑树的5个性质。

 



四、调用RB-INSERT-FIXUP(T, z)来保持和恢复红黑性质

RB-INSERT-FIXUP(T, z)
 1 while color[p[z]] = RED
 2     do if p[z] = left[p[p[z]]]
 3           then y ← right[p[p[z]]]
 4                if color[y] = RED
 5                   then color[p[z]] ← BLACK                    ▹ Case 1
 6                        color[y] ← BLACK                       ▹ Case 1
 7                        color[p[p[z]]] ← RED                   ▹ Case 1
 8                        z ← p[p[z]]                            ▹ Case 1
 9                   else if z = right[p[z]]
10                           then z ← p[z]                       ▹ Case 2
11                                LEFT-ROTATE(T, z)              ▹ Case 2
12                           color[p[z]] ← BLACK                 ▹ Case 3
13                           color[p[p[z]]] ← RED                ▹ Case 3
14                           RIGHT-ROTATE(T, p[p[z]])            ▹ Case 3
15           else (same as then clause
                         with "right" and "left" exchanged)
16 color[root[T]] ← BLACK

//第4张图略：

 





五、红黑树插入的三种情况，即RB-INSERT-FIXUP(T, z)。操作过程（第5张）：



//这幅图有个小小的问题，读者可能会产生误解。图中左侧所表明的情况2、情况3所标的位置都要标上一点。

//请以图中的标明的case1、case2、case3为准。一月三日。






六、红黑树插入的第一种情况（RB-INSERT-FIXUP(T, z)代码的具体分析一）

为了保证阐述清晰，重述下RB-INSERT-FIXUP(T, z)的源码：

RB-INSERT-FIXUP(T, z)
 1 while color[p[z]] = RED
 2     do if p[z] = left[p[p[z]]]
 3           then y ← right[p[p[z]]]
 4                if color[y] = RED
 5                   then color[p[z]] ← BLACK                    ▹ Case 1
 6                        color[y] ← BLACK                       ▹ Case 1
 7                        color[p[p[z]]] ← RED                   ▹ Case 1
 8                        z ← p[p[z]]                            ▹ Case 1
 9                   else if z = right[p[z]]
10                           then z ← p[z]                       ▹ Case 2
11                                LEFT-ROTATE(T, z)              ▹ Case 2
12                           color[p[z]] ← BLACK                 ▹ Case 3
13                           color[p[p[z]]] ← RED                ▹ Case 3
14                           RIGHT-ROTATE(T, p[p[z]])            ▹ Case 3
15           else (same as then clause
                         with "right" and "left" exchanged)
16 color[root[T]] ← BLACK

 //case1表示情况1，case2表示情况2，case3表示情况3.

 

ok，如上所示，相信，你已看到了。

咱们，先来透彻分析红黑树插入的第一种情况：

插入情况1，z的叔叔y是红色的。

第一种情况，即上述代码的第5-8行：
 5                   then color[p[z]] ← BLACK                    ▹ Case 1
 6                        color[y] ← BLACK                       ▹ Case 1
 7                        color[p[p[z]]] ← RED                   ▹ Case 1
 8                        z ← p[p[z]]                            ▹ Case 1


如上图所示，a：z为右孩子，b：z为左孩子。

只有p[z]和y（上图a中A为p[z]，D为z，上图b中，B为p[z]，D为y）都是红色的时候，才会执行此情况1.

 

咱们分析下上图的a情况，即z为右孩子时

因为p[p[z]]，即c是黑色，所以将p[z]、y都着为黑色（如上图a部分的右边），

此举解决z、p[z]都是红色的问题，将p[p[z]]着为红色，则保持了性质5.

 

ok，看下我昨天画的图（第6张）：



红黑树插入的第一种情况完。

 



七、红黑树插入的第二种、第三种情况

插入情况2：z的叔叔y是黑色的，且z是右孩子

插入情况3：z的叔叔y是黑色的，且z是左孩子

这俩种情况，是通过z是p[z]的左孩子，还是右孩子区别的。

 



参照上图，针对情况2，z是她父亲的右孩子，则为了保持红黑性质，左旋则变为情况3，此时z为左孩子，

因为z、p[z]都为黑色，所以不违反红黑性质（注，情况3中，z的叔叔y是黑色的，否则此种情况就变成上述情况1 了）。

 

ok，我们已经看出来了，情况2，情况3都违反性质4（一个红结点的俩个儿子都是黑色的）。

所以情况2->左旋后->情况3，此时情况3同样违反性质4，所以情况3->右旋，得到上图的最后那部分。

注，情况2、3都只违反性质4，其它的性质1、2、3、5都不违背。

 

好的，最后，看下我画的图（第7张）：



 

 

 

八、接下来，进入红黑树的删除部分。

RB-DELETE(T, z)
 1 if left[z] = nil[T] or right[z] = nil[T]
 2    then y ← z
 3    else y ← TREE-SUCCESSOR(z)
 4 if left[y] ≠ nil[T]
 5    then x ← left[y]
 6    else x ← right[y]
 7 p[x] ← p[y]
 8 if p[y] = nil[T]
 9    then root[T] ← x
10    else if y = left[p[y]]
11            then left[p[y]] ← x
12            else right[p[y]] ← x
13 if y 3≠ z
14    then key[z] ← key[y]
15         copy y's satellite data into z
16 if color[y] = BLACK               //如果y是黑色的，
17    then RB-DELETE-FIXUP(T, x)   //则调用RB-DELETE-FIXUP(T, x) 
18 return y              //如果y不是黑色，是红色的，则当y被删除时，红黑性质仍然得以保持。不做操作，返回。

                               //因为：1.树种各结点的黑高度都没有变化。2.不存在俩个相邻的红色结点。

                                          //3.因为入宫y是红色的，就不可能是根。所以，根仍然是黑色的。

ok，第8张图，不必贴了。

 

 

九、红黑树删除之4种情况，RB-DELETE-FIXUP(T, x)之代码

RB-DELETE-FIXUP(T, x)
 1 while x ≠ root[T] and color[x] = BLACK
 2     do if x = left[p[x]]
 3           then w ← right[p[x]]
 4                if color[w] = RED
 5                   then color[w] ← BLACK                        ▹  Case 1
 6                        color[p[x]] ← RED                       ▹  Case 1
 7                        LEFT-ROTATE(T, p[x])                    ▹  Case 1
 8                        w ← right[p[x]]                         ▹  Case 1
 9                if color[left[w]] = BLACK and color[right[w]] = BLACK
10                   then color[w] ← RED                          ▹  Case 2
11                        x ← p[x]                                  ▹  Case 2
12                   else if color[right[w]] = BLACK
13                           then color[left[w]] ← BLACK          ▹  Case 3
14                                color[w] ← RED                  ▹  Case 3
15                                RIGHT-ROTATE(T, w)              ▹  Case 3
16                                w ← right[p[x]]                 ▹  Case 3
17                         color[w] ← color[p[x]]                 ▹  Case 4
18                         color[p[x]] ← BLACK                    ▹  Case 4
19                         color[right[w]] ← BLACK                ▹  Case 4
20                         LEFT-ROTATE(T, p[x])                   ▹  Case 4
21                         x ← root[T]                            ▹  Case 4
22        else (same as then clause with "right" and "left" exchanged)
23 color[x] ← BLACK 

ok，很清楚，在此，就不贴第9张图了。

在下文的红黑树删除的4种情况，详细、具体分析了上段代码。

 

 

十、红黑树删除的4种情况

情况1：x的兄弟w是红色的。

情况2：x的兄弟w是黑色的，且w的俩个孩子都是黑色的。

情况3：x的兄弟w是黑色的，w的左孩子是红色，w的右孩子是黑色。

情况4：x的兄弟w是黑色的，且w的右孩子时红色的。

操作流程图：



 

 

ok，简单分析下，红黑树删除的4种情况：

针对情况1：x的兄弟w是红色的。



 5                   then color[w] ← BLACK                        ▹  Case 1
 6                        color[p[x]] ← RED                       ▹  Case 1
 7                        LEFT-ROTATE(T, p[x])                    ▹  Case 1
 8                        w ← right[p[x]]                         ▹  Case 1

对策：改变w、p[z]颜色，再对p[x]做一次左旋，红黑性质得以继续保持。

x的新兄弟new w是旋转之前w的某个孩子，为黑色。

所以，情况1转化成情况2或3、4。

 

针对情况2：x的兄弟w是黑色的，且w的俩个孩子都是黑色的。



10                   then color[w] ← RED                          ▹  Case 2
11                        x <-p[x]                                  ▹  Case 2
如图所示，w的俩个孩子都是黑色的，

对策：因为w也是黑色的，所以x和w中得去掉一黑色，最后，w变为红。

p[x]为新结点x，赋给x，x<-p[x]。

 

针对情况3：x的兄弟w是黑色的，w的左孩子是红色，w的右孩子是黑色。



13                           then color[left[w]] ← BLACK          ▹  Case 3
14                                color[w] ← RED                  ▹  Case 3
15                                RIGHT-ROTATE(T, w)              ▹  Case 3
16                                w ← right[p[x]]                 ▹  Case 3
w为黑，其左孩子为红，右孩子为黑

对策：交换w和和其左孩子left[w]的颜色。 即上图的D、C颜色互换。:D。

并对w进行右旋，而红黑性质仍然得以保持。

现在x的新兄弟w是一个有红色右孩子的黑结点，于是将情况3转化为情况4.

 

针对情况4：x的兄弟w是黑色的，且w的右孩子时红色的。



17                         color[w] ← color[p[x]]                 ▹  Case 4
18                         color[p[x]] ← BLACK                    ▹  Case 4
19                         color[right[w]] ← BLACK                ▹  Case 4
20                         LEFT-ROTATE(T, p[x])                   ▹  Case 4
21                         x ← root[T]                            ▹  Case 4
x的兄弟w为黑色，且w的右孩子为红色。

对策：做颜色修改，并对p[x]做一次旋转，可以去掉x的额外黑色，来把x变成单独的黑色，此举不破坏红黑性质。

将x置为根后，循环结束。

 

最后，贴上最后的第10张图：



 

ok，红黑树删除的4中情况，分析完成。

 

结语：只要牢牢抓住红黑树的5个性质不放，而不论是树的左旋还是右旋，
不论是红黑树的插入、还是删除，都只为了保持和修复红黑树的5个性质而已。

顺祝各位， 元旦快乐。完。
      July、二零一零年十二月三十日。

-------------------------------------------------------

扩展阅读：Left-Leaning Red-Black Trees, Dagstuhl Workshop on Data Structures, Wadern, Germany, February, 2008. 
直接下载：http://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf 

          1、教你透彻了解红黑树
2、红黑树算法的实现与剖析3、红黑树的c源码实现与剖析4、一步一图一代码，R-B Tree5、红黑树插入和删除结点的全程演示6、红黑树的c++完整实现源码
--------------------------------------------------------------------------------

 



版权声明
    版权所有，侵权必究。
 

上一篇：网友答案整理II：微软等面试100题系列之网友精彩回复 [二]
下一篇：三、动态规划算法解最长公共子序列LCS问题（2011.12.13重写）
 . 


查看评论
 



* 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场
 







个人资料 

v_JULY_v 




访问：4771597次
积分：27387分
排名：第46名
 . 原创：138篇
转载：0篇
译文：5篇
评论：10756条
 . 

博客公告 ①.本blog开通于2010年10月11日，高级C++/算法交流群：128691433；北京程序员联盟：172727781。②.狂热算法，热爱数据挖掘，关注机器学习、统计分析，爱好文学数学。③.微博：研究者July，邮箱：zhoulei97@aliyun.com，或zhoulei0907@yahoo.cn，July，二零一三年八月七日。 
我的微博 
文章分类 03.Algorithms（实现）(9) 
01.Algorithms（研究）(27) 
02.Algorithms（后续）(22) 
04.Algorithms（讨论）(1) 
05.MS 100' original(7) 
06.MS 100' answers(13) 
07.MS 100' classify(4) 
08.MS 100' one Keys(6) 
09.MS 100' follow-up(3) 
10.MS 100' comments(4) 
11.TAOPP（编程艺术）(29) 
12.TAOPP string(8) 
13.TAOPP array(12) 
14.TAOPP list(2) 
15.stack/heap/queue(0) 
16.TAOPP tree(1) 
17.TAOPP c/c++(2) 
18.TAOPP function(2) 
19.TAOPP algorithms(7) 
20.number operations(1) 
21.Essays(8) 
22.Big Data Processing(5) 
23.Redis/MongoDB(0) 
24.data structures(12) 
25.Red-black tree(7) 
26.Image Processing(3) 
27.Architecture design(4) 
28.Source analysis(3) 
29.Recommend&Search(4) 
30.Machine L&Data Mining(5) 

博客专栏




数据挖掘十大算法系列
文章：5篇
阅读：277414 





微软面试100题系列
文章：17篇
阅读：1412250 





程序员编程艺术
文章：27篇
阅读：1022204 





经典算法研究
文章：32篇
阅读：1254701 

阅读排行 程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦(217908) 
教你如何迅速秒杀掉：99%的海量数据处理面试题(170893) 
九月十月百度人搜，阿里巴巴，腾讯华为笔试面试八十题(第331-410题)(166897) 
从B树、B+树、B*树谈到R 树(142708) 
横空出世，席卷互联网--评微软等公司数据结构+算法面试100题(137238) 
十道海量数据处理面试题与十个方法大总结(113474) 
支持向量机通俗导论（理解SVM的三层境界）(102790) 
九月腾讯，创新工场，淘宝等公司最新面试三十题（第171-200题）(94309) 
十一、从头到尾彻底解析Hash表算法(89258) 
微软公司等数据结构+算法面试100题(第1-100题)全部出炉(84427) 

评论排行 程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦(409) 
九月十月百度人搜，阿里巴巴，腾讯华为笔试面试八十题(第331-410题)(368) 
九月腾讯，创新工场，淘宝等公司最新面试三十题（第171-200题）(339) 
当今世界最为经典的十大算法--投票进行时(322) 
从B树、B+树、B*树谈到R 树(279) 
横空出世，席卷互联网--评微软等公司数据结构+算法面试100题(267) 
我的大学生涯(236) 
程序员编程艺术第一章、左旋转字符串(223) 
十三个经典算法研究与总结、目录+索引(218) 
支持向量机通俗导论（理解SVM的三层境界）(215) 

最新评论 程序员编程艺术第三十二~三十三章：最小操作数，木块砌墙问题
u011916787: 问一个关于C++的问题，使用vector的时候为什么有时候初始化了之后需要resize(),而有时候... 

程序员编程艺术第三十二~三十三章：最小操作数，木块砌墙问题
u011916787: 问一下，这一个算法你大约想多久啊，我看现成的解答都要看半天，哎~~~ 

从Hadoop框架与MapReduce模式中谈海量数据处理（含淘宝技术架构）
yutianzuijin: @RunZhi1989:惊现俊哥！ 

程序员编程艺术：第二章、字符串是否包含及匹配/查找/转换/拷贝问题
ken_lover: @likefxy:这个方法有问题 

程序员编程艺术第一章、左旋转字符串
ken_lover: 将问题提高到数学方法实现，思考问题层次立马advanced了 

从Trie树（字典树）谈到后缀树（10.28修订）
hanchengxi: “还要提到一个节约时间的方法. 当我们遍历所有后缀时, 如果某个后缀的某个儿子跟待加字符(新前缀最后... 

全新整理：微软、Google等公司的面试题及解答、第161-170题
ilogo1: 放鸡蛋那个题，应该DP一下，在条件限制下的完全背包问题。 

微软面试100题2010年版全部答案集锦（含下载地址）
hasayake0302: 看了博主的帖子受益匪浅感觉Q48和Q51解法欠妥Q48：仅靠“a >= k && k > a”还不足... 

程序员编程艺术：第十章、如何给10^7个数据量的磁盘文件排序
yankai0219: 关于这个题目中K路归并时所采用的算法。在您的原文中，K路归并时就是采用数组比较获得最小值，复杂度为O... 

程序员编程艺术第三十四~三十五章：格子取数问题，完美洗牌算法
v_JULY_v: @k578522915:没记录最大值？ 


01、本blog索引 3、微软100题维护地址
1、微软100题横空出世
5、经典算法研究系列
7、红黑树系列集锦
6、程序员编程艺术系列
2、微软面试全部100题
0、经典5大原创系列集锦
4、微软100题下载地址
 
02、Google or baidu? Google搜--"结构之法"（My BLOG）
baidu 搜--"结构之法"（My BLOG）
 
03、我的驻点 01. 为学论坛-万物皆数 终生为学
 02、Harry
 03、NoSQLFan
 04、酷勤网
 05、52nlp
 06、北大朋友的挖掘乐园
 07、跟Sophia_qing一起读硕士
 08、caopengcs
 08、面试问答社区51nod
 09、韩寒
 11、曾经的叛逆与年少
 12、老D之MongoDB源码分析
 14、code4app:iOS代码示例
 17、斯坦福机器学习公开课
 18、TheItHome算法版块版主
 19、36氪--关注互联网创业
 20、德问--编程是一种艺术创作
 21、善科网
 22、百度搜索研发部
 23、淘宝搜索技术博客
 24、interviewstreet
 25、LeetCode
 26、Team_Algorithms人人小组
 
文章存档 
2013年08月(2).
2013年06月(1).
2013年03月(1).
2012年12月(1).
2012年11月(1).
2012年09月(1).
2012年06月(1).
2012年05月(2).
2012年04月(1).
2012年03月(2).
2012年02月(2).
2012年01月(2).
2011年12月(5).
2011年11月(1).
2011年10月(7).
2011年09月(3).
2011年08月(11).
2011年07月(4).
2011年06月(7).
2011年05月(10).
2011年04月(7).
2011年03月(17).
2011年02月(11).
2011年01月(18).
2010年12月(14).
2010年11月(6).
2010年10月(5).
 . 


. 
