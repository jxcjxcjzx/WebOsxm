您还未登录！|登录|注册|帮助首页业界移动云计算研发论坛博客下载
更多
gukesdo的专栏
目录视图摘要视图订阅
有奖征集活动系列——【HTML5游戏编程之旅】        专访贺炘：软件测试应讲究策略和方法      低价抢购开源中国论坛门票      “2013年度中国优秀开源项目征集”活动最后一天      Intel Perceptual Camera 初体验
 C++类对象创建过程（分配空间、赋值和初始化、对象初始化顺序、虚函数表指针）
分类： 一点小结 2012-04-26 13:55 928人阅读 评论(1) 收藏 举报
c++constructor编译器initializationallocation汇编
[html] view plaincopy
http://my.oschina.net/alphajay/blog/5029?from=rss<strong></strong>  
初看到这个题目，你可能会有些疑惑：C++类对象的创建还有什么好说的，不就是调用构造函数么？实际上情况并不是想象中的那么简单，大量的细节被隐藏或者被忽略了，而这些细节又是解决一些其他问题的关键，所以我们很有必要深入到这块"神秘"的区域，去探索鲜为人知的秘密。

分配空间(Allocation)
创建C++类对象的第一步就是为其分配内存空间。对于全局对象，静态对象以及分配在栈区域内的对象，对它们的内存分配是在编译阶段就完成了，而对于分配在堆区域内的对象，它们的分配是在运行是动态进行的。内存空间的分配过程涉及到两个关键的问题：需要分配空间的大小，即类对象的大小。这么问题对于编译器来说并不是什么问题，因为类对象的大小就是由它决定的，对于要分配多少内存，它最清楚不过了。

是否有足够的内存空间来满足分配。对于不同的情况我们需要具体问题具体分析：全局对象和静态对象。编译器会为他们划分一个独立的段(全局段)为他们分配足够的空间，一般不会涉及到内存空间不够的问题。分配在栈区域的对象。栈区域的大小由编译器的设置决定，不管具体的设置怎样，总归它是有一个具体的值，所以栈空间是有限的，在栈区域内同时分配超过空间大小的对象会导致栈区域溢出，由于栈区域的分配是在编译阶段完成的，所以在栈区域溢出的时候会抛出编译阶段的异常。分配在堆区域的对象。堆内存空间的分配是在运行是进行的，由于堆空间也是有限的，在栈区域内试图同时分配大量的对象会导致分配失败，通常情况会抛出运行时异常或者返回一个没有意义的值(通常是0)。

初始化(Initialization)
这一阶段是对象创建过程中最神秘的一个阶段，也是最容易被忽视的一个阶段。要想知道这一阶段具体完成那些任务，关键是要区分两个容易混淆的概念：初始化 (Initialization)和赋值(Assignment)。初始化早于赋值，它是随着对象的诞生一起进行的。而赋值是在对象诞生以后又给予它一个新的值。这里我想到了一个很好的例子：任何一个在医院诞生的婴儿，在它诞生的同时医院会给它一个标识，以防止和其他的婴儿混淆，这个标识通常是婴儿母亲所在床铺的编号，医院给婴儿一个标识的过程可以看作是初始化。当然当婴儿的父母拿到他们会为他们起个名字，起名字的过程就可以看作是赋值。经过初始化和赋值后，其他人就可以通过名字来标识他们的身份了。区分了这两个概念后，我们再转到对对象初始化的分析上。对类对象的初始化，实际上是对类对象内的所有数据成员进行初始化。C++已经为我们提供了对类对象进行初始化的能力，我们可以通过实现构造函数的初始化列表(memberinitialization list)来实现。

初始化列表先于构造函数体内的代码执行；
初始化列表确实执行的是数据成员的初始化过程，这个可以从成员对象的构造函数被调用看的出来。

赋值(Assignment)
对象经过初始化以后，我们仍然可以对其进行赋值。和类对象的初始化一样，类对象的赋值实际上是对类对象内的所有数据成员进行赋值。C++也已经为我们提供了这样的能力，我们可以通过构造函数的实现体(即构造函数中由"{}"包裹的部分)来实现。这一点也可以从上面的汇编代码中成员对象的赋值操作符 (operator=)被调用得到印证。

随着构造函数执行完最后一行代码，可以说类对象的创建过程也就顺利完成了。

由以上的分析可以看出，构造函数实现了对象的初始化和赋值两个过程：对象的初始化是通过初始化列表来完成，而对象的赋值则才是通过构造函数，或者更准确的说应该是构造函数的实现体。

虚函数表指针(VTable Pointer)
我们怎么可能会忽视虚函数表指针呢？如果没有它的话，C++世界会清净很多。我们最关心的是对于那些拥有虚函数的类，它们的类对象中的虚函数表指针是什么时候赋值的？我们没有任何代码，也没有任何能力(当然暴力破解的方法除外)能够在类对象创建的时候给其虚表指针赋值，给虚表指针赋值是编译器偷偷完成的，具体的时机是在进入到虚函数后，在给对象的数据成员初始化和赋值之前，编译器偷偷的给虚表指针赋值。我们可以清晰的看到，在构造函数的最开始，在进入构造函数体内部，甚至是在进入初始化列表之前，编译器会插入代码用当前正在被构造的类的虚表地址给虚表指针赋值。

后记
如果不是亲自实践和分析，很难想象一个简单的类对象创建过程竟然蕴涵了这么多秘密。了解了这些秘密为我们解决其他的一些问题打开了胜利之门。试试下面的一些问题，不知道在你看完本文后是否能够有一种豁然开朗的感觉:
1. 为什么C++需要提供初始化列表？那些情况下必须实现初始化列表？ (提示：有些情况下只能初始化不能赋值)
2. 构造函数可以是虚函数呢？在构造函数中调用虚函数会有什么样的结果？ (提示：虚表指针是在构造函数的最开始初始化的)
3. 构造函数和赋值操作符operator=有什么区别？ (提示：区分初始化和赋值)

对象初始化顺序：

当无虚基类的时候：按照继承时候声明的顺序进行基类构造函数，这个是为了将继承的部分进行初始化；按照成员对象在类中的声明顺序进行成员对象的初始化，这是因为在创建对象之前必须对成员进行初始化，这部分可以在构造函数初始化列表中进行；执行子类的构造函数体，对各部分进行初始化。

当有虚基类的时候：第一步应当是对于所有虚基类的子对象，按照他们在类中定义出现的位置，从上到下，从左导游进行初始化，之后就按照以上步骤进行初始化即可。


[html] view plaincopy
#include <iostream>  
using namespace std;  
  
class A{  
public:  
    A(int i){  
        cout << i << "  Constructor of A" << endl;  
    }  
    A(){  
        cout << "Constructor of A" << endl;  
    }  
    ~A(){  
        cout << "Desconstructor of A" << endl;  
    }  
};  
  
class B:public A{  
public:  
    //注意静态成员对象比较特殊，会在编译期间进行初始化  
    static A a1;   
    A a2;  
    A a3;  
    B():a2(A(2)){  
        cout << "constructor of B" << endl;  
    }  
    ~B(){  
        cout << "Desconstructor of B" << endl;  
    }  
};  
  
A B::a1=A(1);  
  
int main()  
{  
    B b;  
    return 0;  
}  

 

分享到： 
上一篇：c++中向上类型转换和向下类型转换
下一篇：判断单链表是否有环，如果有找出环的入口位置=>求两个相交链表的交点

 
查看评论
1楼 happyjw 2012-08-30 11:30发表 [回复]

写的不错啊~~
您还没有登录,请[登录]或[注册]
* 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场

 
个人资料
  
gukesdo
 

访问：158324次
积分：3890分
排名：第1333名
原创：231篇转载：103篇译文：0篇评论：30条
文章搜索

文章分类
一点小结(268)
杂谈(5)
Python(33)
Linux(11)
word排版(1)
面试宝典(54)
趣味题(14)
java(6)
文章存档
2013年05月(4)
2013年03月(5)
2012年10月(1)
2012年08月(2)
2012年05月(59)
展开
阅读排行
win7下怎么配置ODBC数据源(10217)
使用C++获取文件路径，已获取当前路径为基础(4616)
sqlserver所用端口、端口设置(4540)
C++读取以空格作为数据区分标记，以回车为行标记的txt文件到一个整数数组（字符串妙用）(3654)
ssh连接linux服务器中断后，如何让命令继续在服务器运行(3496)
vs2008添加连接静态库和动态库(3395)
win7配置数据源和ODBC数据源部署类型和访问权限（windows 服务无法访问数据源的问题）(3007)
VC 2008问题: 应用程序无法启动，因为应用程序的并行配置不正确(2935)
在socket编程中，如何获取连接另一端（客户端）的ip地址，使用accept或者getpeername(2719)
Python 判断变量的数据类型(2314)
评论排行
在socket编程中，如何获取连接另一端（客户端）的ip地址，使用accept或者getpeername(4)
MFC Application无法启动程序,因为计算机中丢失mfc90ud.dll的解决方案(4)
在MFC中从一个线程工作函数中向窗口发送消息（this指针的妙用）(4)
虚函数表指针、虚基类表指针(2)
c语言实现删除一个txt文件中含有xxx内容的一行，并把删除之后的文件写成另一份txt文件(2)
使用C++获取文件路径，已获取当前路径为基础(2)
小明一家过河(1)
一个不错的讲解基础数据结构和算法的博客(1)
f(n)是统计从1到n出现的1的次数的总和，输出从1到4000000000的所有f(n)=n的n的值P229(1)
C++类对象创建过程（分配空间、赋值和初始化、对象初始化顺序、虚函数表指针）(1)
推荐文章

最新评论
Linux下挂载u盘和光盘，即移动存储设备
弦动天下: 挂载不成功啊，出现这个mount: /dev/sdb already mounted or /mnt...
虚函数表指针、虚基类表指针
yexihu: 正需要呢。。。。
switch...case结构运行特点
u010253348: 不错的
在MFC中从一个线程工作函数中向窗口发送消息（this指针的妙用）
Just_bg: 楼主 ，我想说的是你用this直接指过去，在切换窗口，有时候也发送不了消息的，你可以试试，在debu...
Python实现在不同Linux主机之间拷贝文件
xiaoyao3857: 哇，期待博主能将完整过程和完整代码及截图贴上来，初学，真心不容易！
一个不错的讲解基础数据结构和算法的博客
a9291172061: 十分感谢收藏
在socket编程中，如何获取连接另一端（客户端）的ip地址，使用accept或者getpeername
JCIphone: 谢谢
小明一家过河
lxmzlxmzlxmz: 呵呵 好玩
在socket编程中，如何获取连接另一端（客户端）的ip地址，使用accept或者getpeername
nishuihanxing6466: 非常感谢这篇文章，让我修改了一个bug
类型强制转换，数据内存存储形式
HQ_Yuan: 你好！能请教下吗，一般像我们的PC系统都是小端模式，按照上面测试程序、当一个字节的内存放到两个字节的...
公司简介|招贤纳士|广告服务|银行汇款帐号|联系方式|版权声明|法律顾问|问题报告
QQ客服 微博客服 论坛反馈 联系邮箱：webmaster@csdn.net 服务热线：400-600-2320
京 ICP 证 070598 号
北京创新乐知信息技术有限公司 版权所有
世纪乐知(北京)网络技术有限公司 提供技术支持
江苏乐知网络技术有限公司 提供商务支持
Copyright © 1999-2012, CSDN.NET, All Rights Reserved 

