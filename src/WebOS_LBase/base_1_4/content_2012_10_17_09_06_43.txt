
C++动态分配内存new delete 
.
2009-11-08 17:203050人阅读评论(0)收藏举报

 
 
 

C++基础之动态分配内存
 

贝海拾珠—C/C++点滴   2009-10-16 18:59   阅读71   评论0   

字号： 大  中  小 




2009.10.16
 
转载自http://hi.baidu.com/xiaomeng008/blog/item/9b7706b0e39d785e08230226.html
 
动态内存分配
1.堆内存分配 ：
C/C++定义了4个内存区间：代码区，全局变量与静态变量区，局部变量区即栈区，动态存储区，即堆（heap）区或自由存储区（free store）。

堆的概念：
通常定义变量（或对象），编译器在编译时都可以根据该变量（或对象）的类型知道所需内存空间的大小，从而系统在适当的时候为他们分配确定的存储空间。这种内存分配称为静态存储分配；
有些操作对象只在程序运行时才能确定，这样编译时就无法为他们预定存储空间，只能在程序运行时，系统根据运行时的要求进行内存分配，这种方法称为动态存储分配。所有动态存储分配都在堆区中进行。
当程序运行到需要一个动态分配的变量或对象时，必须向系统申请取得堆中的一块所需大小的存贮空间，用于存贮该变量或对象。当不再使用该变量或对象时，也就是它的生命结束时，要显式释放它所占用的存贮空间，这样系统就能对该堆空间进行再次分配，做到重复使用有限的资源。

2.堆内存的分配与释放
堆空间申请、释放的方法：
在C++中，申请和释放堆中分配的存贮空间，分别使用new和delete的两个运算符来完成：    
指针变量名=new 类型名(初始化式)；
    delete 指针名;
例如：
1、 int *pi=new int(0);
它与下列代码序列大体等价：
2、int ival=0, *pi=&ival;

区别：pi所指向的变量是由库操作符new()分配的，位于程序的堆区中，并且该对象未命名。　　

堆空间申请、释放说明：
⑴.new运算符返回的是一个指向所分配类型变量（对象）的指针。对所创建的变量或对象，都是通过该指针来间接操作的，而且动态创建的对象本身没有名字。
⑵.一般定义变量和对象时要用标识符命名，称命名对象，而动态的称无名对象(请注意与栈区中的临时对象的区别，两者完全不同：生命期不同，操作方法不同，临时变量对程序员是透明的)。
⑶.堆区是不会在分配时做自动初始化的（包括清零），所以必须用初始化式(initializer)来显式初始化。new表达式的操作序列如下：从堆区分配对象，然后用括号中的值初始化该对象。

3.堆空间申请、释放演示：
⑴.用初始化式(initializer)来显式初始化 
int *pi=new int(0);
⑵.当pi生命周期结束时，必须释放pi所指向的目标：
delete pi;

注意这时释放了pi所指的目标的内存空间，也就是撤销了该目标，称动态内存释放（dynamic memory deallocation），但指针pi本身并没有撤销，它自己仍然存在，该指针所占内存空间并未释放。 

下面是关于new 操作的说明 
⑴.new运算符返回的是一个指向所分配类型变量（对象）的指针。对所创建的变量或对象，都是通过该指针来间接操作的，而动态创建的对象本身没有名字。 
⑵.一般定义变量和对象时要用标识符命名，称命名对象，而动态的称无名对象(请注意与栈区中的临时对象的区别，两者完全不同：生命期不同，操作方法不同，临时变量对程序员是透明的)。 
⑶.堆区是不会在分配时做自动初始化的（包括清零），所以必须用初始化式(initializer)来显式初始化。new表达式的操作序列如下：从堆区分配对象，然后用括号中的值初始化该对象。

4. 在堆中建立动态一维数组
①申请数组空间：
指针变量名=new 类型名[下标表达式];
注意：“下标表达式”不是常量表达式，即它的值不必在编译时确定，可以在运行时确定。

②释放数组空间：
delete [ ]指向该数组的指针变量名;

注意：方括号非常重要的，如果delete语句中少了方括号，因编译器认为该指针是指向数组第一个元素的，会产生回收不彻底的问题（只回收了第一个元素所占空间），加了方括号后就转化为指向数组的指针，回收整个数组。delete [ ]的方括号中不需要填数组元素数，系统自知。即使写了，编译器也忽略。
#include <iostream.h>
#include <string.h>
void main(){
     int n;
     char *pc;
     cout<<"请输入动态数组的元素个数"<<endl;
     cin>>n; //n在运行时确定，可输入17
     pc=new char[n]; //申请17个字符（可装8个汉字和一个结束符）的内存空间
     strcpy(pc,“堆内存的动态分配”);//
     cout<<pc<<endl;
     delete []pc;//释放pc所指向的n个字符的内存空间
     return ;
}
 

5. 动态一维数组的说明
① 变量n在编译时没有确定的值，而是在运行中输入，按运行时所需分配堆空间，这一点是动态分配的优点，可克服数组“大开小用”的弊端，在表、排序与查找中的算法，若用动态数组，通用性更佳。一定注意：delete []pc是将n个字符的空间释放，而用delete pc则只释放了一个字符的空间；
② 如果有一个char *pc1，令pc1=p，同样可用delete [] pc1来释放该空间。尽管C++不对数组作边界检查，但在堆空间分配时，对数组分配空间大小是纪录在案的。
③ 没有初始化式（initializer），不可对数组初始化。 

6.指针数组和数组指针
指针类型:
(1)int*ptr;//指针所指向的类型是int 
(2)char*ptr;//指针所指向的的类型是char 
(3)int**ptr;//指针所指向的的类型是int* （也就是一个int * 型指针） 
(4)int(*ptr)[3];//指针所指向的的类型是int()[3] //二维指针的声明

指针数组：
一个数组里存放的都是同一个类型的指针，通常我们把他叫做指针数组。 
比如 int * a[2];它里边放了2个int * 型变量 .
int * a[2]； 
a[0]= new int[3]; 
a[1]=new int[3]; 
delete a[0]; 
delete a[1]; 
注意这里 是一个数组，不能delete [] ; 

数组指针：
一个指向一维或者多维数组的指针.
int * b=new int[10];　指向一维数组的指针b ; 
注意，这个时候释放空间一定要delete [] ,否则会造成内存泄露， b 就成为了空悬指针 

int (*b2)[10]=new int[10][10]; 注意，这里的b2指向了一个二维int型数组的首地址. 
注意：在这里，b2等效于二维数组名，但没有指出其边界，即最高维的元素数量，但是它的最低维数的元素数量必须要指定！就像指向字符的指针，即等效一个字符串,不要把指向字符的指针说成指向字符串的指针。
int(*b3) [30] [20]; //三级指针――>指向三维数组的指针； 
int(*b2) [20];     //二级指针；――>指向二维数组的指针； 
b3=new int [1] [20] [30]; 
b2=new int [30] [20]; 
删除这两个动态数组可用下式： 
delete [] b3; //删除（释放）三维数组； 
delete [] b2; //删除（释放）二维数组；

在堆中建立动态多维数组
new 类型名[下标表达式1] [下标表达式2]……;

例如：建立一个动态三维数组
float (*cp)[30][20] ; //指向一个30行20列数组的指针，指向二维数组的指针
cp=new float [15] [30] [20]; //建立由15个30*20数组组成的数组；

注意：cp等效于三维数组名，但没有指出其边界，即最高维的元素数量，就像指向字符的指针即等效一个字符串,不要把指向字符的指针，说成指向字符串的指针。这与数组的嵌套定义相一致。
 
附：new和delete用法
 
在内存管理上，C++ 和 C 有着完全不同的两套方案。当然，C++的总是同时兼容C。C的那一套方案在C++里同样可行。 

      new ，从字面上看意思为 “新”；而delete 字面意思为“删除”。二者在C++中内存管理中大致的功能，应是一个为“新建”，一个为“删除”。
 
一、new　
 
      new 是 c++ 的一个关键字。被当作像 +、-、* 、/ 一样的操作符。它的操作结果是在申请到一段指定数据类型大小的内存。
 
　 语法： 指针变量 = new 数据类型;
 
     new 将做三件事：
 
　 1、主动计算指定数据类型需要的内存空间大小；
 
     2、返回正确的指针类型；
 
    3、在分配内存的一，将按照语法规则，初始化所分配的内存。
 
　 这是什么意思呢？看看例子吧：
 
　 int* p;
 
     p = new int;
 
　 和以往不一样，p 这回不再“寄人篱下”，并不是指向某个已存在的变量，而是直接指向一段由new 分配而来的新内存空间。
 
　 “p 指向一段由new 分配而来的新内存空间” 这句话等同于： “new 分配一段新的内存空间，然后将该内存空间的地址存入到变量p中。” 所以，最终p中仍然是存储了一个变量的地址，只是，这是一个“无名”变量。
 
　 指向原有的某个变量，和指向一段新分配的内存空间，有什么区别呢？
 
      “原有的变量”，可以比喻成指向一间原有的，并且有主的房间。而“新分配的内存空间”，则像是一个“临时建筑物”。我们必须在不用它的时候，主动将它拆迁。拆迁的工作由delete来完成。
 
　 当指针变量通过 new ，而得到一个内存地址后，我们就可以像以前的所说的，通过该指针，通过*号，而对该内存地址（一个无名的变量），进行操作。
 
     如：
 
     int* p = new int;
 
     *p = 100;
 
     cout << *p << endl;
 
　 屏幕将输出100。
 
二、new时初始化　
 
     new 也可以在申请内存空间时，直接设置该段内存里要放点什么.
 
　 语法： 指针变量 = new 数据类型(初值); 

三、delete
 
     语法： delete 指针变量;
 
　 delete 将释放指定指针所指向的内存空间。 　
 
     注意，当一个指针接受delete操作后，它就又成了一个“指向不明”的指针。尽管我们可以猜测它还是指向“原来的房子”，然而，事实上，那座“房子”已经被delete “拆迁”掉了。
 
四、new[]和delete[]
 
      new / delete 用于分配和释放单个变量的空间，而 new [] / delete[] 则用于分配连续多个变量的存间。
 
    语法: 指针变量 = new 数据类型[元素个数];
 
     语法:   delete [] 指针变量;

