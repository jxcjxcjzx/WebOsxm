您还未登录！|登录|注册|帮助首页业界移动云计算研发论坛博客下载
更多
MoreWindows谁愿长躲在避风的港口，宁有波涛汹涌的自由。 欢迎关注微博-http://weibo.com/MoreWindows
目录视图摘要视图订阅
2013年7月微软MVP申请开始啦！        CSDN博客移动开发排行榜      写“书评”赢下载分！ 
2013年4月微软MVP会员名单揭晓！      来极客头条，赢下载积分      专访关东升：将人文融入到科技产品中
 C/C++变量在内存中的分布
分类： C/C++/C#基础 2011-10-08 10:30 20157人阅读 评论(85) 收藏 举报
fun编译器扩展测试xp
C/C++变量在内存中的分布在笔试时经常考到，虽然简单，但也容易忘记，因此在这作个总结，以加深印象。

先写一个测试程序：

[cpp] view plaincopy
#include <stdio.h>  
#include <malloc.h>  
int g_i = 100;  
int g_j = 200;  
int g_k, g_h;  
int main()  
{  
    const int MAXN = 100;  
    int *p = (int*)malloc(MAXN * sizeof(int));  
    static int s_i = 5;  
    static int s_j = 10;  
    static int s_k;  
    static int s_h;  
    int i = 5;  
    int j = 10;  
    int k = 20;  
    int f, h;  
    char *pstr1 = "MoreWindows123456789";  
    char *pstr2 = "MoreWindows123456789";  
    char *pstr3 = "Hello";  
      
      
    printf("堆中数据地址：0x%08x\n", p);  
      
    putchar('\n');  
    printf("栈中数据地址(有初值)：0x%08x = %d\n", &i, i);  
    printf("栈中数据地址(有初值)：0x%08x = %d\n", &j, j);  
    printf("栈中数据地址(有初值)：0x%08x = %d\n", &k, k);  
    printf("栈中数据地址(无初值)：0x%08x = %d\n", &f, f);  
    printf("栈中数据地址(无初值)：0x%08x = %d\n", &h, h);  
      
    putchar('\n');  
    printf("静态数据地址(有初值)：0x%08x = %d\n", &s_i, s_i);  
    printf("静态数据地址(有初值)：0x%08x = %d\n", &s_j, s_j);  
    printf("静态数据地址(无初值)：0x%08x = %d\n", &s_k, s_k);  
    printf("静态数据地址(无初值)：0x%08x = %d\n", &s_h, s_h);  
      
    putchar('\n');  
    printf("全局数据地址(有初值)：0x%08x = %d\n", &g_i, g_i);  
    printf("全局数据地址(有初值)：0x%08x = %d\n", &g_j, g_j);  
    printf("全局数据地址(无初值)：0x%08x = %d\n", &g_k, g_k);  
    printf("全局数据地址(无初值)：0x%08x = %d\n", &g_h, g_h);  
      
    putchar('\n');  
    printf("字符串常量数据地址：0x%08x 指向 0x%08x 内容为-%s\n", &pstr1, pstr1, pstr1);  
    printf("字符串常量数据地址：0x%08x 指向 0x%08x 内容为-%s\n", &pstr2, pstr2, pstr2);  
    printf("字符串常量数据地址：0x%08x 指向 0x%08x 内容为-%s\n", &pstr3, pstr3, pstr3);  
    free(p);  
    return 0;  
}  
运行结果（Release版本，XP系统）如下：



可以看出：

1.      变量在内存地址的分布为：堆-栈-代码区-全局静态-常量数据

2.      同一区域的各变量按声明的顺序在内存的中依次由低到高分配空间（只有未赋值的全局变量是个例外）。

3.      全局变量和静态变量如果不赋值，默认为0。 栈中的变量如果不赋值，则是一个随机的数据。

4.      编译器会认为全局变量和静态变量是等同的，已初始化的全局变量和静态变量分配在一起，未初始化的全局变量和静态变量分配在另一起。

 

上面程序全在一个主函数中，下面增加函数调用，看看函数的参数和函数中变量会分配在什么地方。

程序如下：

[cpp] view plaincopy
#include <stdio.h>  
void fun(int i)  
{  
    int j = i;  
    static int s_i = 100;  
    static int s_j;  
  
    printf("子函数的参数:        0x%p = %d\n", &i, i);  
    printf("子函数 栈中数据地址: 0x%p = %d\n", &j, j);  
    printf("子函数 静态数据地址(有初值): 0x%p = %d\n", &s_i, s_i);  
    printf("子函数 静态数据地址(无初值): 0x%p = %d\n", &s_j, s_j);  
}  
int main()  
{  
    int i = 5;  
    static int s_i = 100;  
    static int s_j;  
  
    printf("主函数 栈中数据地址: 0x%p = %d\n", &i, i);  
    printf("主函数 静态数据地址(有初值): 0x%p = %d\n", &s_i, s_i);  
    printf("子函数 静态数据地址(无初值): 0x%p = %d\n", &s_j, s_j);  
    putchar('\n');  
  
    fun(i);  
    return 0;  
}  
运行结果如下：



可以看出，主函数中栈的地址都要高于子函数中参数及栈地址，证明了栈的伸展方向是由高地址向低地址扩展的。主函数和子函数中静态数据的地址也是相邻的，说明程序会将已初始化的全局变量和表态变量分配在一起，未初始化的全局变量和表态变量分配在另一起。

 

 

 

转载请标明出处，原文地址：http://blog.csdn.net/morewindows/article/details/6851681

分享到： 
上一篇：Windows系统下搭建MPI（并行计算）环境
下一篇：Windows 各种计时函数总结
顶
85
踩
3

查看评论
63楼 N3verL4nd 2013-03-06 12:32发表 [回复]

win7+VS2010 release
[cpp] view plaincopy
堆中数据地址：0x005b2938  
  
栈中数据地址(有初值)：0x0030f7e0 = 5  
栈中数据地址(有初值)：0x0030f7dc = 10  
栈中数据地址(有初值)：0x0030f7d8 = 20  
栈中数据地址(无初值)：0x0030f7c8 = 14356947  
栈中数据地址(无初值)：0x0030f7c4 = 3209192  
  
静态数据地址(有初值)：0x00db3020 = 5  
静态数据地址(有初值)：0x00db3024 = 10  
静态数据地址(无初值)：0x00db3388 = 0  
静态数据地址(无初值)：0x00db3384 = 0  
  
全局数据地址(有初值)：0x00db3018 = 100  
全局数据地址(有初值)：0x00db301c = 200  
全局数据地址(无初值)：0x00db3380 = 0  
全局数据地址(无初值)：0x00db337c = 0  
  
字符串常量数据地址：0x0030f7d4 指向 0x00db20f4 内容为-MoreWindows123456789  
字符串常量数据地址：0x0030f7d0 指向 0x00db20f4 内容为-MoreWindows123456789  
字符串常量数据地址：0x0030f7cc 指向 0x00db210c 内容为-Hello.  
62楼 Ahh_Freshmeat 2013-02-05 11:05发表 [回复]

学习了 赞楼主这种思路
61楼 shisanyue13BCD 2012-09-02 21:35发表 [回复]

这段代码只能测试自己的机器的内存分配，不同的操作系统还是有不小的区别的，大家可以借鉴这种分析问题的方法，如果真的遇到这种问题的话，还是别那么肯定的说，而是要因系统而异
Re: MoreWindows 2012-09-03 10:26发表 [回复]

回复shisanyue13BCD：在Windows平台下，不同编译器也会略有不同。
60楼 fxl1122 2012-08-20 10:50发表 [回复]

赞一个，非常感谢楼主！
59楼 墨西哥渔夫1991 2012-07-28 12:56发表 [回复]

我觉得楼主写得比较好，因为他提供了一种分析的思路。不过楼主最好是指明自己的编译环境等。不然有人就会说，不同的体系结构，不同的系统平台，不同的编译器，不同的编译选项，等等都会产生不同的结果。楼主可以把会影响结果的因素提及一下，免得误会。继续关注楼主的其他文章。有人说意义不大，我觉得蛮有意思的，C语言的指针就是地址。
Re: MoreWindows 2012-07-28 14:56发表 [回复]

回复shunqiziranhao007：学习是永无止境的，知识是一步步积累的。本文只是在XP+VC6下作了个试验，肯定不能以偏盖全。文章的结论也只是为进一步的知识搜索作基础的。
比如文中结论的第二点：
2. 同一区域的各变量按声明的顺序在内存的中依次由低到高分配空间（只有未赋值的全局变量是个例外）。
当时试验得出这样的结论，后来又发现不同的编译器处理方式会不一样，有的编译器会优化变量的布局从而提高内存使用率。通过这进一步的试验，无疑会对字节对齐有一个更形象的认识。
因此希望读者能将我的代码拿出来大修大改，尝试能否挖掘出其它知识点。
58楼 z82932386 2012-05-31 10:46发表 [回复]

辛苦了，lz
57楼 Unix_Architect 2012-05-16 18:23发表 [回复]

LZ,最好写一个在类中是如何排布的。（我记得C++一本书说是编译器会自己优化变量的排布）。但是我想测试自己一直不会写。
还有就是大小端。
56楼 bingtao1314 2012-04-24 07:28发表 [回复]

不同的系统会有不同的编译结果
Re: MoreWindows 2012-04-24 09:42发表 [回复]

回复bingtao1314：这个是的，呵呵，学知识本来就是个探索的过程，就像从地心说到日心说，然后再发现银河系，宇宙大爆炸等等。这篇文章等过一阵会再次修订下，对一些不足之处进行改进。
55楼 WSJyuehu 2012-04-13 12:54发表 [回复]

菜鸟飘过 学习了
54楼 bingxue7921 2012-04-13 10:13发表 [回复]

我会持续关注博主的文章的，学习了！
53楼 liujiganglovepyy 2012-04-12 20:06发表 [回复]

学习方法很好
52楼 bingxue7921 2012-04-10 17:07发表 [回复]

主函数中栈的地址都要高于子函数中参数及栈地址，证明了栈的伸展方向是由高地址向低地址扩展的。这个也不是绝对的，博主，您看在我机子上WinXP上Release运行的结果，正好与您的这个结果相反，呵呵
[cpp] view plaincopy
主函数 栈中数据地址: 0x0012FF74 = 5  
主函数 静态数据地址(有初值): 0x0040301C = 100  
子函数 静态数据地址(无初值): 0x00403378 = 0  
  
子函数的参数:        0x0012FF7C = 5  
子函数 栈中数据地址: 0x0012FF78 = 5  
子函数 静态数据地址(有初值): 0x00403018 = 100  
子函数 静态数据地址(无初值): 0x00403374 = 0  
请按任意键继续. . .  
Re: MoreWindows 2012-04-11 18:39发表 [回复]

回复bingxue7921：这篇文章是去年写的，过几天来重新整理下。
51楼 bingxue7921 2012-04-10 17:02发表 [回复]

这是我机子在WinXP下Release运行的结果：
[cpp] view plaincopy
堆中数据地址：0x003928b8  
  
栈中数据地址(有初值)：0x0012ff60 = 5  
栈中数据地址(有初值)：0x0012ff64 = 10  
栈中数据地址(有初值)：0x0012ff68 = 20  
栈中数据地址(无初值)：0x0012ff78 = 2018779649  
栈中数据地址(无初值)：0x0012ff7c = 1  
  
静态数据地址(有初值)：0x00403020 = 5  
静态数据地址(有初值)：0x00403024 = 10  
静态数据地址(无初值)：0x00403388 = 0  
静态数据地址(无初值)：0x00403384 = 0  
  
全局数据地址(有初值)：0x00403018 = 100  
全局数据地址(有初值)：0x0040301c = 200  
全局数据地址(无初值)：0x00403380 = 0  
全局数据地址(无初值)：0x0040337c = 0  
  
字符串常量数据地址：0x0012ff6c 指向 0x004020f4 内容为-MoreWindows123456789  
字符串常量数据地址：0x0012ff70 指向 0x004020f4 内容为-MoreWindows123456789  
字符串常量数据地址：0x0012ff74 指向 0x0040210c 内容为-Hello  
请按任意键继续. . .  

同一区域的各变量按声明的顺序在内存的中依次由低到高分配空间（注意，未赋值的全局和静态变量都应该是个例外）。
50楼 jianshiku 2012-04-06 08:27发表 [回复]

多谢楼主，很有感触。
49楼 usareur77 2012-03-31 03:40发表 [回复]

有道理
48楼 beyondzd2000 2011-10-18 20:21发表 [回复]

有想法，简单实用！
47楼 fengmei1372 2011-10-18 15:29发表 [回复]

学了，楼主辛苦啦！
46楼 xiaogang2567 2011-10-17 13:56发表 [回复]

xuexile
45楼 海豚六号 2011-10-14 14:52发表 [回复]

温故而知新。
44楼 Felix 2011-10-14 14:27发表 [回复]

赞！这种分析学习的方法很值得学习！
43楼 xincheng31 2011-10-14 14:11发表 [回复]

楼主很会分析呀。。。。
42楼 小鞋匠 2011-10-13 23:12发表 [回复]

不错，思路非常的清晰。。并且简单容易理解
41楼 ren 2011-10-13 13:14发表 [回复]

引用“MoreWindows”的评论：
回复hanfuleide：你用的是VC6.0的Debug版本，要在Rele...



学习了！！！
40楼 ren 2011-10-13 13:13发表 [回复]

引用“hanfuleide”的评论：
嗯，讲得挺好的，不过：“2. 同一区域的各变量按声明的顺序在内存的中依次由低到高分配空间（...


好！！说的 很明白！学习了！
39楼 nehc 2011-10-13 00:45发表 [回复]

mark ...
38楼 深蓝怒火 2011-10-12 15:07发表 [回复]

好文章，楼主钻研精神非常好
37楼 liushiyang8798 2011-10-12 12:40发表 [回复]

有什么用吗。。。
36楼 aj758461601 2011-10-11 22:55发表 [回复]

很好 很好 学习 学习！！！！
Re: Unix_Architect 2012-05-16 18:21发表 [回复]

回复aj758461601：我感觉没啥用 呵呵
35楼 do_while_2011 2011-10-11 22:49发表 [回复]

哦 我看懂了，linux和windows栈的伸展方向好像不一样，楼主应该注明下，否则会引起我们菜鸟的困惑的。。
Re: MoreWindows 2011-10-12 09:33发表 [回复]

回复do_while_2011：已注明了
34楼 do_while_2011 2011-10-11 22:45发表 [回复]

我以前好像看到书上说堆得伸展方向是由低到高，而栈的伸展方向是由高到底，那为什么执行结果都是从低到高呢？不解。。。
Re: MoreWindows 2011-10-12 09:45发表 [回复]

回复do_while_2011：你说的堆栈伸展方向是正确的，连续调用malloc()分配的地址一般来说会递增的，程序中调用函数，栈的地址也会由高地址向低地址伸展。我对文章新增了些内容，欢迎你再来看看。
33楼 AutoAsm 2011-10-11 22:05发表 [回复]

不同的编译器，不同的体系结构，不同的编译选项，都会产生不同的结果。
32楼 hutu_cn 2011-10-11 17:30发表 [回复]

有专门的指针控制符%p, 并不是所有的机器都是32位。

printf("栈中数据地址(有初值)：0x%08x = %d\n", &i, i); 
==〉
printf("栈中数据地址(有初值)：%p = %d\n", &i, i);
Re: MoreWindows 2011-10-11 20:54发表 [回复]

回复hutu_cn：呵呵，这个确实，不过最好也加个0x即printf("0x%p\n", p);
过几天会对printf()进行总结，希望你来看看。
31楼 q_forest 2011-10-11 17:20发表 [回复]

楼主写的很好，思路一下子就清晰了
30楼 cpfhust 2011-10-11 15:36发表 [回复]

顶啊
29楼 shimin10902 2011-10-11 14:47发表 [回复]

引用“MoreWindows”的评论：
回复hanfuleide：你用的是VC6.0的Debug版本，要在Rele...

想知道为什么会产生这样的差异呢？望解疑。
Re: MoreWindows 2011-10-11 21:26发表 [回复]

回复shimin10902：Debug和Release其实也就是编译参数的区别。可以参见
http://blog.csdn.net/morewindows/article/details/6742078
当然这些编译参数比较枯燥，如果不是专业人员，不须要过多的深入。
28楼 lander9999 2011-10-11 14:42发表 [回复]

要注意编译选项，比如优化开关之类的，结果会完全不一样
27楼 brave_yuyong 2011-10-11 09:53发表 [回复]

麻烦注明下，你的测试环境是WINDOWS
以下是linux测试结果
$
堆中数据地址：0x025d9010

栈中数据地址(有初值)：0xb60993a8 = 5
栈中数据地址(有初值)：0xb60993a4 = 10
栈中数据地址(有初值)：0xb60993a0 = 20
栈中数据地址(无初值)：0xb609939c = 0
栈中数据地址(无初值)：0xb6099398 = 4195568

静态数据地址(有初值)：0x00601040 = 5
静态数据地址(有初值)：0x00601044 = 10
静态数据地址(无初值)：0x00601058 = 0
静态数据地址(无初值)：0x0060105c = 0

全局数据地址(有初值)：0x00601038 = 100
全局数据地址(有初值)：0x0060103c = 200
全局数据地址(无初值)：0x00601064 = 0
全局数据地址(无初值)：0x00601060 = 0

字符串常量数据地址：0xb6099388 指向 0x00400940 内容为-MoreWindows123456789
字符串常量数据地址：0xb6099380 指向 0x00400940 内容为-MoreWindows123456789
字符串常量数据地址：0xb6099378 指向 0x00400955 内容为-Hello
$ 
linux变量布局（地址从地到高）代码段（只读段，包换char * -p = "hello",const 全局(赋值)，const static（赋值））-全局&static(已赋值段)-bss(全局&static(未赋值段))-heap-……-stack-操作系统
Re: MoreWindows 2011-10-11 10:33发表 [回复]

回复brave_yuyong：老大，我BLOG的名字已经注明了：MoreWindows
当然也欢迎linux下的测试结果，我会好好看下你提供的运行结果，谢谢你。
26楼 a317179403 2011-10-10 22:28发表 [回复]

受教了，谢谢了。
25楼 Jinziyatoo 2011-10-10 21:02发表 [回复]

[cpp] view plaincopy
堆中数据地址：0x00392920  
  
栈中数据地址(有初值)：0x0012ff4c = 5  
栈中数据地址(有初值)：0x0012ff40 = 10  
栈中数据地址(有初值)：0x0012ff34 = 20  
栈中数据地址(无初值)：0x0012ff28 = -858993460  
栈中数据地址(无初值)：0x0012ff1c = -858993460  
  
静态数据地址(有初值)：0x00452008 = 5  
静态数据地址(有初值)：0x0045200c = 10  
静态数据地址(无初值)：0x0045302c = 0  
静态数据地址(无初值)：0x00453024 = 0  
  
全局数据地址(有初值)：0x00452000 = 100  
全局数据地址(有初值)：0x00452004 = 200  
全局数据地址(无初值)：0x00453028 = 0  
全局数据地址(无初值)：0x00453020 = 0  
  
字符串常量数据地址：0x0012ff10 指向 0x00444308 内容为-MoreWindows123456789  
字符串常量数据地址：0x0012ff04 指向 0x00444308 内容为-MoreWindows123456789  
字符串常量数据地址：0x0012fef8 指向 0x00444300 内容为-Hello  
请按任意键继续. . .  
  
这是debug下的结果，注意全局和静态，中间怎么是隔8个字节？？到底怎么个分配顺序？  
Re: MoreWindows 2011-10-11 21:10发表 [回复]

回复waicy_2003：不同的机器会略有差别吧，下面是我PC机在Debug下的结果：
[cpp] view plaincopy
堆中数据地址：0x00380fe0  
  
栈中数据地址(有初值)：0x0012ff74 = 5  
栈中数据地址(有初值)：0x0012ff70 = 10  
栈中数据地址(有初值)：0x0012ff6c = 20  
栈中数据地址(无初值)：0x0012ff68 = -858993460  
栈中数据地址(无初值)：0x0012ff64 = -858993460  
  
静态数据地址(有初值)：0x00427320 = 5  
静态数据地址(有初值)：0x00427324 = 10  
静态数据地址(无初值)：0x00427e3c = 0  
静态数据地址(无初值)：0x00427e40 = 0  
  
全局数据地址(有初值)：0x00427318 = 100  
全局数据地址(有初值)：0x0042731c = 200  
全局数据地址(无初值)：0x00427e38 = 0  
全局数据地址(无初值)：0x00427e34 = 0  
  
字符串常量数据地址：0x0012ff60 指向 0x004230d0 内容为-MoreWindows123456789  
字符串常量数据地址：0x0012ff5c 指向 0x004230d0 内容为-MoreWindows123456789  
字符串常量数据地址：0x0012ff58 指向 0x004230c8 内容为-Hello  


你可以调试这个程序并在Memory中输入地址来查看这8个字节到底是什么，呵呵，看到后记得告诉我下。我也想知道这8个字节会是什么？
24楼 Jinziyatoo 2011-10-10 20:52发表 [回复]

为什么debug模式下编译出来的，静态变量和全局变量分配的内存顺序和release的完全不同？楼主可以说下debug下面如何分配的麽？
Re: MoreWindows 2011-10-11 10:30发表 [回复]

回复waicy_2003：不好意思，今天有点忙，等下晚上回答你。
23楼 sanae 2011-10-10 20:10发表 [回复]

受教了～

关于第一点的布局 其实这只是某编译器默认生成的某种布局，如果要求比较高或者其他特殊的环境，gcc下可以自己写ldscript来控制这个布局
22楼 hanfuleide 2011-10-10 19:22发表 [回复]

嗯，讲得挺好的，不过：“2. 同一区域的各变量按声明的顺序在内存的中依次由低到高分配空间（只有未赋值的全局变量是个例外）。”在VC6.0下恰好是反的，呵呵，即栈是由高到低分配空间，未赋值的全局变量也是由高到低，不过静态和全局的确实是由低到高，编译器不同的原因？
Re: MoreWindows 2011-10-11 09:25发表 [回复]

回复hanfuleide：你用的是VC6.0的Debug版本，要在Release版本下运行，这二者在内存布局上会有不小的区别的。
Re: kuaikuai3698 2011-10-13 12:04发表 [回复]

回复MoreWindows：在release版本下栈区也是由高地址到低地址啊
21楼 cardtizen 2011-10-10 17:14发表 [回复]

受教了，谢谢lz~~
20楼 CppCore 2011-10-10 15:29发表 [回复]

简洁明了
19楼 GeekBBer 2011-10-10 13:36发表 [回复]

学习了
18楼 chenchenliliang 2011-10-10 13:09发表 [回复]

顶一下
17楼 LC657913241 2011-10-10 12:58发表 [回复]

非常详细，也非常具体。一目了然。谢谢了
16楼 xingzewen102 2011-10-10 11:29发表 [回复]

学习一下。
15楼 DINGGUOZI 2011-10-10 10:33发表 [回复]

呵呵，支持下
14楼 squiffy 2011-10-10 10:02发表 [回复]

真不错！
13楼 captainlee007 2011-10-10 10:01发表 [回复]

很直观！
12楼 q408384053 2011-10-10 08:54发表 [回复]

学习了，感谢楼主呀！
11楼 东子 2011-10-10 08:29发表 [回复]

非常详细，也非常具体。一目了然。谢谢了。
10楼 jamseyang 2011-10-09 20:57发表 [回复]

结合反汇编分析下就更好了
Re: MoreWindows 2011-10-10 09:02发表 [回复]

回复jamseyang：我对汇编只懂一点点，写不出太多。。。。。
9楼 无趣 2011-10-09 17:26发表 [回复]

总结的好，标记一下。
8楼 蛋痛 2011-10-09 17:13发表 [回复]

学习了
7楼 jjzhoujun2010 2011-10-09 13:00发表 [回复]

不错~学习了，实例加解释~
6楼 silverpot 2011-10-09 13:00发表 [回复]

意义不大
Re: MoreWindows 2011-10-09 14:20发表 [回复]

回复silverpot：不求大，先求好。
Re: wuxupeng999 2011-10-12 18:40发表 [回复]

加油！
楼主还可以加上点细节的东西。考虑到有字节对齐，为优化占用内存空间，编译器可能会对同类变量的存储位置做顺序上的调整。
Re: silverpot 2011-10-10 17:11发表 [回复]

回复MoreWindows：探讨。

因为我觉得你的代码并没有真正说明各种变量在内存中的存贮位置。你代码里输出的位置说明只不过是你对变量定义及语言规定的理解所加上去的。
Re: MoreWindows 2011-10-11 09:32发表 [回复]

回复silverpot：代码里输出的位置是进程空间中的地址，还涉及到虚拟地址与内存硬件上的地址转换，你是想查询这个变量在内存硬件上的地址吗？
Re: Larry_Bi 2011-10-11 11:39发表 [回复]

回复MoreWindows：在windows下编程，的确不需要涉及到虚拟地址和物理地址的映射问题。即使是在嵌入式编程中，大部分情况下，我们对它做到了解难道还不够吗？再譬如在linux下，我们可以通过link script去指定某个段的位置，那也只是指定虚拟地址。
所以纠结内存驻留情况，真的没有什么意思。
Re: MoreWindows 2011-10-11 21:31发表 [回复]

回复Larry_Bi：这个支持，我写这个主要是针对笔试，让大家一看就能记住是我的目的。对于编程的初学者来说，去钻研别的很多方面都比在编译器的具体工作细节上刨根究底要有意思的多。
5楼 whycantpeace 2011-10-09 12:40发表 [回复]

辛苦了，谢谢啊！
4楼 Touch 2011-10-09 12:24发表 [回复]

学习了
3楼 happyeverydayzhh 2011-10-09 11:39发表 [回复]

不错，有收获
2楼 networkwx 2011-10-08 18:25发表 [回复]

不错，代码+结果，很有说服力。
美中不足的是在第4条里面，两处将“静”错写成“表”
Re: MoreWindows 2011-10-08 20:42发表 [回复]

回复networkwx：呵呵，谢谢提醒。已经改正了。
1楼 Forgeting0606 2011-10-08 16:16发表 [回复]

学习了
您还没有登录,请[登录]或[注册]
* 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场

个人资料
  
MoreWindows
 

访问：875843次
积分：11509分
排名：第186名
原创：129篇转载：0篇译文：0篇评论：2372条
博客专栏
	白话经典算法
文章：14篇
阅读：135797
	秒杀多线程面试题系列
文章：15篇
阅读：251633
	Windows C/C++/C# 编程
文章：113篇
阅读：778306
	C++ STL
文章：11篇
阅读：111345
阅读排行
秒杀多线程第一篇 多线程笔试面试题汇总(38079)
白话经典算法系列之七 堆与堆排序(28379)
秒杀多线程第二篇 多线程第一次亲密接触 CreateThread与_beginthreadex本质区别(28012)
STL系列之十 全排列(百度迅雷笔试题)(27779)
微软实习生日记 第一篇 初识微软(26965)
秒杀多线程第七篇 经典线程同步 互斥量Mutex(22601)
秒杀多线程第四篇 一个经典的多线程同步问题(21185)
C/C++变量在内存中的分布(20156)
秒杀多线程第三篇 原子操作 Interlocked系列函数(18104)
白话经典算法系列之五 归并排序的实现(18058)
MoreWindows微博

文章分类
白话经典算法系列(13)
Windows编程(74)
Windows多线程(15)
STL 他山之石(11)
OpenCV入门指南(13)
C/C++/C#基础(14)
VC6.0及VS2008使用技巧(7)
HTML/javascript/PHP(12)
评论排行
微软实习生日记 第一篇 初识微软(100)
秒杀多线程第六篇 经典线程同步 事件Event(88)
C/C++变量在内存中的分布(85)
位操作基础篇之位操作全面总结(84)
热门智力题 过桥问题和倒水问题(82)
秒杀多线程第一篇 多线程笔试面试题汇总(82)
STL系列之十 全排列(百度迅雷笔试题)(78)
秒杀多线程第五篇 经典线程同步 关键段CS(75)
秒杀多线程第二篇 多线程第一次亲密接触 CreateThread与_beginthreadex本质区别(73)
秒杀多线程第三篇 原子操作 Interlocked系列函数(70)
最新评论
秒杀多线程第五篇 经典线程同步 关键段CS
bycn: 测试了下，线程A调用EnterCriticalSection，线程B调用LeaveCriticalS...
【CSDN博客之星】本博客得到915票，排名第二名。谢谢大家。祝大家新春快乐，万事如意。
刘勇水: 赞，支持，想你好好学习。
【白话经典算法系列之十四】腾讯2012年实习生笔试加分题
Naruto_ahu: 思路清晰。向LZ学习。赞！
【OpenCV入门指南】第四篇 图像的二值化
朝露昙花: 妹子十分养眼
【白话经典算法系列之十四】腾讯2012年实习生笔试加分题
lengshuilangren: 欢迎大家讨论。祝师弟师妹们笔试顺利过关。
【白话经典算法系列之十二】数组中只出现1次的两个数字(百度面试题)
plexr: 知道是一个数的时候使用异或操作，但怎么想找不到两个数的突破口，这个方法太棒了，将问题拆分为两个子问题...
【白话经典算法系列之十四】腾讯2012年实习生笔试加分题
plexr: 不小心自己想出来了，噶嘎嘎
【白话经典算法系列之十二】数组中只出现1次的两个数字(百度面试题)
hust_枫: 博主你好，关于分组，可以通过之前得到的temp 计算mytemplate = temp & (~te...
白话经典算法系列之一 冒泡排序的三种实现
sun999_sun999: 数据结构学的不好，看的头疼，膜拜一下
Windows界面编程第六篇 动画启动效果（动画效果显示及隐藏窗口）
luckyxiaoxuan: 很棒耶，赞一个！
公司简介|招贤纳士|广告服务|银行汇款帐号|联系方式|版权声明|法律顾问|问题报告
QQ客服 微博客服 论坛反馈 联系邮箱：webmaster@csdn.net 服务热线：400-600-2320
京 ICP 证 070598 号
北京创新乐知信息技术有限公司 版权所有
世纪乐知(北京)网络技术有限公司 提供技术支持
江苏乐知网络技术有限公司 提供商务支持
Copyright © 1999-2012, CSDN.NET, All Rights Reserved 
 
