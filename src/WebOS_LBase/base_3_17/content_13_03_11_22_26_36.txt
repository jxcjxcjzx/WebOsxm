
   忘记密码   免费注册	查看新帖 | 论坛精华区


  平台： 论坛 博客 文库 沙龙 自测 下载 订阅 搜索 访谈录 频道： 自动化运维 虚拟化 服务器 储存备份 C/C++ PHP MySQL 嵌入式 Linux系统	
  
·买域名送域名 海外主机免备案
·2013年中国数据库技术大会现七折优惠
·Linux试题大全 入门精通面面关
·年度社区积极会员评选提名活动
›论坛›程序设计›C/C++›如何用非递归的算法来求解一个"全排列"
1234下一页
最近访问板块 
查看: 1890 | 回复: 32
  
[算法] 如何用非递归的算法来求解一个"全排列" [复制链接] 0 0
weichuang02

白手起家
帖子138主题80精华0可用积分36 专家积分0 在线时间98 小时注册时间2012-06-28最后登录2013-03-11
串门好友博客消息
论坛徽章:0
电梯直达1楼[收藏(0)][报告]
 发表于 2012-09-02 15:28:25 |只看该作者 |倒序浏览
求一个数列的全排列，用递归的方法很容易描述，网上也有很多例子

但是如果要求必须不能用递归，可以用堆栈来求解，这个算法/代码应该如何描述呢? 我在纸上试了一下，没出来。

大家有什么思路么?
本版精华
文库|博客
我的编程生涯 - 已更新到第21集跟我一起写 Makefile出现频率最高的笔试题strcpy写法[原创]贡献一个unix的贪吃蛇小游戏对CURL的一些研究Linux Kernel 2.6，listen(5)，永不 accept，到底能建立成功多少个连接？已知一个函数f可以得到1-5间的随机数，问怎么得到1-7的随机数华为面试题(8分钟写出代码)一个web服务器的实现[翻译]《The New C》——几篇介绍C99特性的文章 2010年4月30日更新
《Openstack云系统》课程，几乎免费的逆向收 ...  |  在oracle 10g中，是不是使用fast-start on- ...  |  [求助]35岁，求职DBA会不会很难？  |  vage 大哥，帮帮忙看下cache buffers chain ...  
_Rayx

富足长乐

帖子781主题44精华0可用积分5186 专家积分0 在线时间1389 小时注册时间2012-03-25最后登录2013-01-28
串门好友博客消息
论坛徽章:0
2楼[报告]
 发表于 2012-09-02 15:31:49 |只看该作者
很容易啊，求一个排列的下一个排列是O（n）的算法。
很排好序，当作第一个排列，然后一直求下一个排序，直接没有下一个即可。
当今主流WEB开发工具谁独领风骚| 安全解决方案研讨会 | 分布式文件系统 Lustre路在何方 | 数据挖掘编程工具大讨论
weichuang02

白手起家
帖子138主题80精华0可用积分36 专家积分0 在线时间98 小时注册时间2012-06-28最后登录2013-03-11
串门好友博客消息
论坛徽章:0
3楼[报告]
 发表于 2012-09-02 19:09:33 |只看该作者
_Rayx 发表于 2012-09-02 15:31 
很容易啊，求一个排列的下一个排列是O（n）的算法。
很排好序，当作第一个排列，然后一直求下一个排序，直 ...


能否稍微详细一点呢? 我想展开这个思路发现还是卡住了。
当今主流WEB开发工具谁独领风骚| 安全解决方案研讨会 | 分布式文件系统 Lustre路在何方 | 数据挖掘编程工具大讨论
sacry

丰衣足食

帖子275主题0精华0可用积分558 专家积分0 在线时间1140 小时注册时间2012-02-16最后登录2013-03-07
串门好友博客消息
论坛徽章:0
4楼[报告]
 发表于 2012-09-02 19:23:24 |只看该作者
回复 3# weichuang02 

关键字
lexicographic permutation 或者 next permutation


   
当今主流WEB开发工具谁独领风骚| 安全解决方案研讨会 | 分布式文件系统 Lustre路在何方 | 数据挖掘编程工具大讨论
_Rayx

富足长乐

帖子781主题44精华0可用积分5186 专家积分0 在线时间1389 小时注册时间2012-03-25最后登录2013-01-28
串门好友博客消息
论坛徽章:0
5楼[报告]
 发表于 2012-09-02 19:28:15 |只看该作者
回复 3# weichuang02 


    假设中间某一个排列是　１　３　４　５　９　７　２
它的下一个排列是１　３　４　７　２　５　９
其实就是发现２《7 7<9 9>5,于是找到比5大的最小数，7，交换变成1 3 4 7 9 5 2,再将7后面的数首尾交换，变成1 3 4 7 2 5 9
这样就是下一个排列了。
当今主流WEB开发工具谁独领风骚| 安全解决方案研讨会 | 分布式文件系统 Lustre路在何方 | 数据挖掘编程工具大讨论
sacry

丰衣足食

帖子275主题0精华0可用积分558 专家积分0 在线时间1140 小时注册时间2012-02-16最后登录2013-03-07
串门好友博客消息
论坛徽章:0
6楼[报告]
 发表于 2012-09-02 21:05:11 |只看该作者
回复 5# _Rayx 

假设中间某一个排列是　１　３　４　５　９　７　２
它的下一个排列是１　３　４　７　２　５　９
其实就是发现２《7 7<9 9>5,于是找到比5大的最小数，7，交换变成1 3 4 7 9 5 2,再将7后面的数首尾交换，变成1 3 4 7 2 5 9
这样就是下一个排列了。


这例子后半组正好3个数字，会让人误解的...
准确地说应该是reverse。
   
当今主流WEB开发工具谁独领风骚| 安全解决方案研讨会 | 分布式文件系统 Lustre路在何方 | 数据挖掘编程工具大讨论
KanonInD

丰衣足食

帖子446主题4精华0可用积分610 专家积分0 在线时间750 小时注册时间2010-09-09最后登录2013-02-20
串门好友博客消息
论坛徽章:0
7楼[报告]
 发表于 2012-09-02 21:25:45 |只看该作者
本帖最后由 KanonInD 于 2012-09-02 21:26 编辑


lexicographic permutation 用Python写的：http://en.wikipedia.org/wiki/Per ... lexicographic_order
def permutation(ls):
    length = len(ls)
    print(ls)
    while True:
        k = -1
        for i in range(length-1):
            if ls[i] < ls[i+1]:
                k = i
        if k == -1:break
        l = 0
        for i in range(k,length):
            if ls[k] < ls[i]:
                l = i
        ls[k],ls[l] = ls[l],ls[k]
        ls[k+1:] = ls[k+1:][::-1]
        print(ls)
复制代码
http://projecteuler.net/
当今主流WEB开发工具谁独领风骚| 安全解决方案研讨会 | 分布式文件系统 Lustre路在何方 | 数据挖掘编程工具大讨论
starwing83
拾荒者

巨富豪门

帖子3384主题55精华1可用积分23315 专家积分15 在线时间2837 小时注册时间2008-08-16最后登录2013-03-11
串门好友博客消息
论坛徽章:0
8楼[报告]
 发表于 2012-09-02 22:16:07 |只看该作者
http://yzfy.org/dis/listpost.php?tid=498&page=16#pid169692
当今主流WEB开发工具谁独领风骚| 安全解决方案研讨会 | 分布式文件系统 Lustre路在何方 | 数据挖掘编程工具大讨论
_Rayx

富足长乐

帖子781主题44精华0可用积分5186 专家积分0 在线时间1389 小时注册时间2012-03-25最后登录2013-01-28
串门好友博客消息
论坛徽章:0
9楼[报告]
 发表于 2012-09-03 07:52:13 |只看该作者
回复 6# sacry 


    you are right.
当今主流WEB开发工具谁独领风骚| 安全解决方案研讨会 | 分布式文件系统 Lustre路在何方 | 数据挖掘编程工具大讨论
cjaizss

版主

帖子10626主题413精华4可用积分24568 专家积分65 在线时间7322 小时注册时间2005-05-26最后登录2013-03-11
串门好友博客消息
论坛徽章:1

10楼[报告]
 发表于 2012-09-18 16:44:46 |只看该作者
weichuang02 发表于 2012-09-02 15:28 
求一个数列的全排列，用递归的方法很容易描述，网上也有很多例子

但是如果要求必须不能用递归，可以用堆 ...

正好之前写了个
#include <stdio.h>

#include <stdlib.h>

int *flag;

void print(int*a,int num)

{

        int i;

        num--;

        for(i=0;i<num;i++)

                printf("%d->",a[i]);

        printf("%d\n",a[num]);

}



int next(int*a,int m, int n,int how)

{

        int i,j,k,x;

        if(how) {

                for(j=n-1;j>=0;j--) {

                        for(i=a[j];i<m;i++)

                                if(flag[i]==0)

                                        break;

                        if(i<m) {

                                flag[a[j]-1]=0;

                                a[j]=i+1;

                                flag[i]=1;



                                for(x=0,k=j+1;k<n;k++) {

                                        while(flag[x]==1)x++;

                                        a[k]=x+1;

                                        flag[x]=1;

                                }

                                return 0;

                        }

                        flag[a[j]-1]=0;

                }

        }

        else {

                if(a[n-1]<m) {

                        a[n-1]++;

                        return 0;

                }

                for(i=n-1;i>0;i--)

                        if(a[i]>a[i-1]+1)

                                break;

                if(i>0) {

                        a[i-1]++;

                        for(;i<n;i++)

                                a[i]=a[i-1]+1;

                        return 0;

                }

        }

        return 1;

}



int main(int argc,char**argv)

{

        int *a,i;

        char c;

        int m,n;

        int how=0;

        c=argv[3][0];

        sscanf(argv[1],"%d",&m);

        sscanf(argv[2],"%d",&n);

        if(!(0<n&&n<=m)||(c!='P'&&c!='p'&&c!='C'&&c!='c'))

                return 1;

        a = malloc(sizeof(int)*n);

        if(c=='P'||c=='p') {

                how =1;

                flag = malloc(sizeof(int)*m);

                for(i=0;i<n;i++)

                        flag[i]=1;

                for(;i<m;i++)

                        flag[i]=0;

        }

        if(a==NULL)

                return 1;

        for(i=0;i<n;i++)

                a[i]=i+1;

        while(1) {

                print(a,n);

                if(next(a,m,n,how))

                        return 0;

        }

}
复制代码
echo '++++++++++[>++++++++++[>+<-]<-]>>-.+++++++.---------.++++++++.>>++++[<++++[<+>-]>-]<<+.-------..' | sed '
s/\([-+]\)/\1\1*p;/g
s/</p--;/g
s/>/p++;/g
s/\./putchar(*p);/g
s/\[/while(*p){/g
s/\]/}/g
1s/^/main(){char*p=calloc(1,6);/
$s/$/}/
/./!d'|gcc -xc - 2>/dev/null&&./a.out
当今主流WEB开发工具谁独领风骚| 安全解决方案研讨会 | 分布式文件系统 Lustre路在何方 | 数据挖掘编程工具大讨论
    热门内容推荐
  IT168产品库推荐：苹果 iPod touch4(8G)  摩托罗拉 XT615  三星 i9003  索尼爱立信 X8  华为 S8600 火花  现代博恩 XB-D04  
1234下一页返回列表
ChinaUnix.net›论坛›程序设计›C/C++›如何用非递归的算法来求解一个"全排列"
高级模式
BColorImageLinkQuoteCodeSmilies
您需要登录后才可以回帖 登录 | 注册  
发表回复 回帖后跳转到最后一页
北京皓辰网域网络信息技术有限公司. 版权所有 京ICP证:060528号 北京市公安局海淀分局网监中心备案编号：1101082001
广播电视节目制作经营许可证(京) 字第1234号 中国互联网协会会员  联系我们： 
感谢所有关心和支持过ChinaUnix的朋友们 转载本站内容请注明原作者名及出处
清除 Cookies - ChinaUnix - Archiver - WAP - TOP
  

