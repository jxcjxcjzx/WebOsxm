



mikespook
 
懒猫开始新生活——猫眼看世界
本人乃好事之徒，找骂者请自便
PS：如果哪天我不跟坎子找茬了，那我就是死了。^_^
 

随笔 - 121, 文章 - 0, 评论 - 567, 引用 - 5
 




linux下多进程编程简介



两年前的文章，拿过来充充门面。

————————————————————————

linux下多进程编程简介
 
( 作者：mikespook | 发布日期：2002-12-8 | 浏览次数：272 )
 


关键字：Linux,多进程,fork(),wait()



前言： 
    本文章只是为了给广大和我一样的菜鸟一个指引。如果你是高手，或对编程毫无兴趣。建议请不要在此浪费时间。 

　　多进程是一个非常有用的东西。记得我上次介绍的那个TCP connect扫描器么，是不是很慢？如果你使用多进程分段扫描端口，你会发现速度大大提升。下面我们就来看看怎么在Linux下进行多进程编程。
     首先，简单介绍一下我们要用的函数:fork()、wait()。 
    fork()函数是一个很有意思的函数。他可以建立一个新进程，把当前的进程分为父进程和子进程。原来进程的所有页面在调用fork()函数时被分为相同的两份，所以父进程和子进程都使用相同的映像。该函数与普通函数的不同之处是函数如果调用成功会返回两次，在父进程中返回子进程的PID；在子进程中返回0。成功后，父进程和子进程都在fork()函数后继续执行。如果函数调用不成功，则返回一次，返回值为 -1。
     由于在进程运行时，如果子进程先退出，它不会从进程列表里清除。而要发一个SIGCHLD（或SIGCLD）信号给父进程，父进程确认后子进程才会退出。在等待父进程确认期间，子进程处于“zombie”状态。所以我们就需要使用wait()函数。如果调用wait()函数时已经有一个处于“zombie”状态的子进程，那么函数立即返回的同时该子进程从内存中清除出去；否则，主进程会被挂起，直到其中一个进程退出。直接调用wait()函数有个很明显的缺点就是父进程会被挂起而无法进行其他任务。解决办法就是拦截处理信号SIGCHLD（或SIGCLD），这我会在以后讲信号处理的文章中给大家简单的说说。
 
老规矩，通过源代码来学习多进程编程。 

/*--------------------------fork.c------------------------------*/ 
/* mikespook */ 
/* exercise function fork() and wait()*/ 
/* 2002.5.28 */ 

#include <stdio.h> 
#include <sys/types.h> 
#include <unistd.h>
#define FAC_N 65535 

/* 子进程调用的函数，这里我为了模拟一个很大的后台操作用了一个循环。 */ 
void big_loop(int n); 
/* 父进程调用的函数，其实不放到函数里也可以，不过为了程序的结构更好看还是放到函数里的好 */ 
void input_information(); 

int main() 
{ 
  /* 进程号 */ 
  pid_t pid; 
  /* 程序在这里“分叉”，新的进程创建了 */ 
  pid = fork(); 
  /* 通过fork()的返回值来判断是父进程还是子进程 */ 
  switch(pid){ 
    /* 返回 -1，很不幸，创建进程失败了。可能是没有足够的内存空间，也可能已经开起了太多的进程。 */ 
    case -1: 
      perror("fork\n"); 
      break; 
    /* 返回 0，现在是在子进程里运行，那就调用子进程的操作函数。 */ 
    case 0: 
      /* 一个运行65535次的循环，如果你的机子太快，不能看清楚两个进程同时运行的效果，那就再加大循环次数。或用sleep()函数 */ 
      big_loop(FAC_N); 
      /* 取得子进程的PID，你可以看清楚子进程和父进程的PID是不同的（子进程的PID比父进程的要大，因为是在父进程运行后才创建的）。*/ 
      printf("PID:%d\n", getpid()); 
      break; 
    /* 哈哈，返回的即不是错误，又不是子进程，那就是父进程喽。*/ 
    default: 
      /* 这里让用户输入了4个数 */ 
      input_information(); 
      /* 取得子进程的PID。*/ 
      printf("PID:%d\n", getpid()); 
      break; 
  } 
  /* 等着吧，子进程不退出，你父进程也不能退出的。 */    
  wait(); 
  exit(0);   
} 

/*big_loop: 简单，一看就明白，不解释了。*/ 
void big_loop(int n) 
{ 
  int i; 
  for(i = 0; i < n; i++){ 
    switch(i % 4){ 
      case 0: 
        putchar('-'); 
        break; 
      case 1: 
        putchar('/'); 
        break; 
      case 2: 
        putchar('|'); 
        break; 
      case 3: 
        putchar('\\'); 
        break; 
    } 
    putchar('\b'); 
  } 
} 

/*input_information: 简单，一看就明白，也不解释了。*/ 
void input_information() 
{ 
  int n_table[4], i; 

  for(i = 0; i < 4; i++){ 
    printf("Number %d:\t", i); 
    scanf("%d", &n_table[i]); 
  } 

   printf("Number1\tNumber2\tNumber3\tNumber4\n"); 
   printf("%d\t%d\t%d\t%d\n", n_table[0], n_table[1], n_table[2], n_table[3]); 
} 
/*--------------------------fork.c------------------------------*/ 

　　同样，我再给大家补充几点，以供参考。 
　　多进程的好处是同时并行的运行多个任务。由于各自使用独立的内存空间，所以不容易由于冲突而出错。但是这样就给进程间的通信带来了一定的麻烦。当然有很多办法，比如管道，消息等等可以解决这个问题。多进程还有一个问题就是内存空间的浪费。一个进程就是一个完整的内存映像，有一些数据重复放置，这样对内存空间浪费是很严重的（我想这也就是多线程比多进程要优越的原因，可惜我还没有完全搞明白linux下的多线程，要不然也和大家讨论讨论。过段时间吧！）。还有，我要提示的是上面这个例子我在最后用了wait()函数，这样父进程运行完后回等着子进程退出才退出。你可以试试把wait();这个语句去掉，看看什么效果？父进程运行完退出了，我们回到了[mikespook @ lazycat]$的提示符下，而子进程继续在运行。有时我们可以利用这个把一个进程放到后台去运行（比如木马……当然啦，我不是建议你做木马！）。
 　　好啦，Linux下的多进程编程就怎么点内容，是不是很简单呢？其实，让两个进程独立运行很容易，关键的难点是父进程和子进程共享数据，进行通信。我会在以后的文章中慢慢和大家讨论的（其实关键是有一些东西还没有悟透，不敢拿出来丢人^%^）。
 
给大家个好站：http://www.opengroup.org/onlinepubs/007908799/  在线的man手册，有什么不明白的地方可以到这里查询。可惜，是E文的。
 由于我是菜鸟，或许有什么不对的地方。也可能一些细节我没有考虑到。如果你知道的话希望不惜指教。小弟感激不尽！！ 






分类: 编程
 

绿色通道： 好文要顶 关注我 收藏该文与我联系 




mikespook
 关注 - 0
 粉丝 - 4 



+加关注 


0

0


 (请您对文章做出评价) 


« 博主上一篇：linux下信号编程简介——不可靠的信号
» 博主下一篇：win2000下 PHP+MySql 的安装

 
posted on 2004-06-25 21:55 mikespook 阅读(4002) 评论(0) 编辑 收藏

 


刷新评论刷新页面返回顶部
 

注册用户登录后才能发表评论，请 登录 或 注册，访问网站首页。

 
博客园首页博问新闻闪存程序员招聘知识库
 





最新IT新闻:
 · 美国著名影评网站“影评情报”即将关闭
 · 咖啡的“逆袭”：网络的价值 传统门店求变
 · Google Reader猝死启示录：互联网无法永远免费
 · 深圳威武！全球最廉价手机只需10美元
 · 是什么造就了优秀的开发者/工程师文化？
» 更多新闻...

最新知识库文章:

 · 处理 JavaScript 异常的一个想法
 · SQL Server表分区详解
 · 漫谈重构
 · 云计算里AWS和Azure的探究
 · SQL Server 高性能写入的一些总结

» 更多知识库文章... 





导航
 博客园
 首页
 新随笔
 联系
 订阅 
管理
 







<

2004年6月

>

 


日

一

二

三

四

五

六



30

31

1

2

3

4

5



6

7

8

9

10

11

12



13

14

15

16

17

18

19



20

21

22

23

24

25

26



27

28

29

30

1

2

3



4

5

6

7

8

9

10

 
公告
 

昵称：mikespook
园龄：8年3个月
粉丝：4
关注：0
+加关注

 

搜索
 
 
 
 
 
常用链接
 我的随笔
我的评论
我的参与
最新评论
我的标签
 


最新随笔
 
1. 发现不少朋友给我的 blog 链接还是这里
2. 又建立了一个新BLOG
3. 在博客园申请了PHP博客
4. 每日一翻，今日完成
5. 翻译记录
6. 翻译 Debian 软件包简介信息
7. 【收藏】让错误的程序看得出错
8. 魔力论坛2.1.4转PHPWind4.3.2程序
9. 一些PHP相关的数据比较
10. 赋诗一首另杂论点点
 
随笔分类
编程(40)
技术杂谈(41)
系统(9)
做人与编程(32)

随笔档案
2010年6月 (1)
2007年6月 (1)
2006年8月 (3)
2006年7月 (1)
2006年6月 (3)
2006年4月 (2)
2006年3月 (3)
2006年1月 (2)
2005年12月 (2)
2005年11月 (9)
2005年10月 (3)
2005年9月 (6)
2005年8月 (6)
2005年7月 (6)
2005年6月 (8)
2005年5月 (7)
2005年4月 (9)
2005年3月 (4)
2005年2月 (2)
2005年1月 (5)
2004年12月 (7)

相册


linuxsir
jimmy3719's blog(rss)
赵光的blog

常用
Wallop

好站
codeproject
Joel on Software
PHP Security Consortium
sourceforge
巴蛮子的新破茅屋(rss)
洪朝貴的首頁
胡旻波的Blog(rss)
王垠的主页
一风一云的文档(rss)

朋友
IceSharK - PP.Poet(rss)
桂枝香在故国晚秋(rss)
如果有一天...(rss)

团队
CIO 孵化器
计算机图形学

自己的站
mikespook new blog(rss)

积分与排名
 积分 - 183561 
排名 - 518 

最新评论
 


阅读排行榜
 

1. 图解Windows98安装(26222)
2. 这个公司的制度比较牛—— 软媒电子科技开发（深圳）有限公司(13160)
3. 按部就班——图解配置IIS5的SSL安全访问(8857)
4. 任务管理器全接触(8583)
5. linux下多进程编程简介(4002)
 
评论排行榜
 

1. 这个公司的制度比较牛—— 软媒电子科技开发（深圳）有限公司(150)
2. 图解Windows98安装(55)
3. 俺们邢家也很荣耀啊(54)
4. 按部就班——图解配置IIS5的SSL安全访问(31)
5. 批驳吕起民发佛语(15)
 
推荐排行榜
 

1. 按部就班——图解配置IIS5的SSL安全访问(2)
2. linux下信号编程简介——不可靠的信号(1)
 


Powered by: 
博客园
Copyright © mikespook 

