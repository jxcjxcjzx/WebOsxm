
您还未登录！|登录|注册|帮助
 首页
 业界
 移动
 云计算
 研发
 论坛
 博客
 下载
 
更多
 







孟岩

Salute Julian Assange


 


目录视图
摘要视图
订阅
 . 



博客专家信息更新登记表        专访卜茂霞：嵌入式汽车开发潜力巨大      云计算最低优惠仅剩1天 
专访陈勇： 敏捷开发现状及发展之路        “传统商家移动化之路”会议        下载频道3月领任务~赚下载分！ 



function/bind的救赎（上） 
.
2010-10-09 00:0429950人阅读评论(108)收藏举报
 
smalltalkbutton语言.netwindowscomponents

 
这是那篇C++0X的正文。太长，先写上半部分发了。

Function/bind可以是一个很简单的话题，因为它其实不过就是一个泛型的函数指针。但是如果那么来谈，就没意思了，也犯不上写这篇东西。在我看来，这个事情要讲的话，就应该讲透，讲到回调（callback）、代理（delegate）、信号（signal）和消息传递（messaging）的层面，因为它确实是太重要了。这个话题不但与面向对象的核心思想密切相关，而且是面向对象两大流派之间交锋的中心。围绕这个问题的思考和争论，几乎把20年来所有主流的编程平台和编程语言都搅进来了。所以，如果详尽铺陈，这个话题直接可以写一本书。

写书我当然没那个水平，但这个题目确实一直想动一动。然而这个主题实在太大，我实在没有精力把它完整的写下来；这个主题也很深，特别是涉及到并发环境有关的话题，我的理解还非常肤浅，总觉得我认识的很多高手都比我更有资格写这个话题。所以犹豫了很久，要不要现在写，该怎么写。最后我觉得，确实不能把一篇博客文章写成一本20年面向对象技术史记，所以决定保留大的架构，但是对其中具体的技术细节点到为止。我不会去详细地列举代码，分析对象的内存布局，画示意图，但是会把最重要的结论和观点写下来，说得好听一点是提纲挈领，说的不好听就是语焉不详。但无论如何，我想这样一篇东西，一是谈谈我对这个事情的看法，二是“抛砖引玉”，引来高手的关注，引出更深刻和完整的叙述。

下面开始。

0. 程序设计有一个范式（paradigm）问题。所谓范式，就是组织程序的基本思想，而这个基本思想，反映了程序设计者对程序的一个基本的哲学观，也就是说，他认为程序的本质是什么，他认为一个大的程序是由什么组成的。而这，又跟他对于现实世界的看法有关。显然，这样的看法不可能有很多种。编程作为一门行业，独立存在快60年了，但是所出现的范式不过三种——过程范式、函数范式、对象范式。其中函数范式与现实世界差距比较大，在这里不讨论。而过程范式和对象范式可以视为对程序本质的两种根本不同的看法，而且能够分别在现实世界中找到相应的映射。
•过程范式认为，程序是由一个又一个过程经过顺序、选择和循环的结构组合而成。反映在现实世界，过程范式体现了劳动分工之前“全能人”的工作特点——所有的事情都能干，所有的资源都是我的，只不过得具体的事情得一步步地来做。 
•对象范式则反映了劳动分工之后的团队协作的工作特点——每个人各有所长，各司其职，有各自的私有资源，工件和信息在人们之间彼此传递，最后完成工作。因此，对象范式也就形成了自己对程序的看法——程序是由一组对象组成，这些对象各有所能，通过消息传递实现协作。 

对象范式与过程范式相比，有三个突出的优势，第一，由于实现了逻辑上的分工，降低了大规模程序的开发难度。第二，灵活性更好——若干对象在一起，可以灵活组合，可以以不同的方式协作，完成不同的任务，也可以灵活的替换和升级。第三，对象范式更加适应图形化、网络化、消息驱动的现代计算环境。

所以，较之于过程范式，对象范式，或者说“面向对象”，确实是更具优势的编程范式。最近看到一些文章抨击面向对象，说面向对象是胡扯，我认为要具体分析。对面向对象的一部分批评，是冲着主流的“面向对象”语言去的，这确实是有道理的，我在下面也会谈到，而且会骂得更狠。而另一个批评的声音，主要而来自STL之父Alex Stepanov，他说的当然有他的道理，不过要知道该牛人是前苏联莫斯科国立罗蒙诺索夫大学数学系博士，你只要翻翻前苏联的大学数学教材就知道了，能够在莫大拿到数学博士的，根本就是披着人皮的外星高等智慧。而我们编写地球上的程序，可能还是应该以地球人的观点为主。

1. 重复一遍对象范式的两个基本观念：
•程序是由对象组成的； 
•对象之间互相发送消息，协作完成任务； 

请注意，这两个观念与后来我们熟知的面向对象三要素“封装、继承、多态”根本不在一个层面上，倒是与再后来的“组件、接口”神合。

2. 世界上第一个面向对象语言是Simula-67，第二个面向对象语言是Smalltalk-71。Smalltalk受到了Simula-67的启发，基本出发点相同，但也有重大的不同。先说相同之处，Simula和Smalltalk都秉承上述对象范式的两个基本观念，为了方便对象的构造，也都引入了类、继承等概念。也就是说，类、继承这些机制是为了实现对象范式原则而构造出来的第二位的、工具性的机制，那么为什么后来这些第二位的东西篡了主位，后面我会再来分析。而Simula和Smalltalk最重大的不同，就是Simula用方法调用的方式向对象发送消息，而Smalltalk构造了更灵活和更纯粹的消息发送机制。

具体的说，向一个Simula对象中发送消息，就是调用这个对象的一个方法，或者称成员函数。那么你怎么知道能够在这个对象上调用这个成员函数呢？或者说，你怎么知道能够向这个对象发送某个消息呢？这就要求你必须确保这个对象具有合适的类型，也就是说，你得先知道哦这个对象是什么，才能向它发消息。而消息的实现方式被直接处理为成员函数调用，或虚函数调用。

而Smalltalk在这一点上做了一个历史性的跨越，它实现了一个与目标对象无关的消息发送机制，不管那个对象是谁，也不管它是不是能正确的处理一个消息，作为发送消息的对象来说，可以毫无顾忌地抓住一个对象就发消息过去。接到消息的对象，要尝试理解这个消息，并最后调用自己的过程来处理消息。如果这个消息能被处理，那个对象自然会处理好，如果不能被处理，Smalltalk系统会向消息的发送者回传一个doesNotUnderstand消息，予以通知。对象不用关心消息是如何传递给另一个对象的，传递过程被分离出来（而不是像Simula那样明确地被以成员函数调用的方式实现），可以是在内存中复制，也可以是进程间通讯。到了Smalltalk-80时，消息传递甚至可以跨越网络。

为了方便后面的讨论，不妨把源自Simula的消息机制称为“静态消息机制”，把源自Smalltalk的消息机制称为“动态消息机制”。

Simula与Smalltalk之间对于消息机制的不同选择，主要是因为两者于用途。前者是用于仿真程序开发，而后者用于图形界面环境构建，看上去各自合情合理。然而，就是这么一点简单的区别，却造成了巨大的历史后果。

3. 到了1980年代，C++出现了。Bjarne Stroustrup在博士期间深入研究过Simula，非常欣赏其思想，于是就在C语言语法的基础之上，几乎把Simula的思想照搬过来，形成了最初的C++。C++问世以之初，主要用于解决规模稍大的传统类型的编程问题，迅速取得了巨大的成功，也证明了对象范式本身所具有的威力。

大约在同期，Brad Cox根据Smalltalk的思想设计了Objective-C，可是由于其语法怪异，没有流行起来。只有Steve Jobs这种具有禅宗美学鉴赏力的世外高人，把它奉为瑰宝，与1988年连锅把Objective-C的团队和产品一口气买了下来。

4. 就在同一时期，GUI成为热门。虽然GUI的本质是对象范型的，但是当时（1980年代中期）的面向对象语言，包括C++语言，还远不成熟，因此最初的GUI系统无一例外是使用C和汇编语言开发的。或者说，最初的GUI开发者硬是用抽象级别更低的语言构造了一个面向对象系统。熟悉Win32 SDK开发的人，应该知道我在说什么。

5. 当时很多人以为，如果C++更成熟些，直接用C++来构造Windows系统会大大地容易。也有人觉得，尽管Windows系统本身使用C写的，但是其面向对象的本质与C++更契合，所以在其基础上包装一个C++的GUI framework一定是轻而易举。可是一动手人们就发现，完全不是那么回事。用C++开发Windows框架难得要死。为什么呢？主要就是Windows系统中的消息机制实际上是动态的，与C++的静态消息机制根本配合不到一起去。在Windows里，你可以向任何一个窗口发送消息，这个窗口自己会在自己的wndproc里来处理这个消息，如果它处理不了，就交给default window/dialog proc去处理。而在C++里，你要向一个窗口发消息，就得确保这个窗口能处理这个消息，或者说，具有合适的类型。这样一来的话，就会导致一个错综复杂的窗口类层次结构，无法实现。而如果你要让所有的窗口类都能处理所有可能的消息，且不论这样在逻辑上就行不通（用户定义的消息怎么处理？），单在实现上就不可接受——为一个小小的不同就得创造一个新的窗口类，每一个小小的窗口类都要背上一个多达数百项的v-table，而其中可能99%的项都是浪费，不要说在当时，就是在今天，内存数量非常丰富的时候，如果每一个GUI程序都这么搞，用户也吃不消。

6. 实际上C++的静态消息机制还引起了更深严重的问题——扭曲了人们对面向对象的理解。既然必须要先知道对象的类型，才能向对象发消息，那么“类”这个概念就特别重要了，而对象只不过是类这个模子里造出来的东西，反而不重要。渐渐的，“面向对象编程”变成了“面向类编程”，“面向类编程”变成了“构造类继承树”。放在眼前的鲜活的对象活动不重要了，反而是其背后的静态类型系统成为关键。“封装、继承”这些第二等的特性，喧宾夺主，俨然成了面向对象的要素。每个程序员似乎都要先成为领域专家，然后成为领域分类学专家，然后构造一个完整的继承树，然后才能new出对象，让程序跑起来。正是因为这个过程太漫长，太困难，再加上C++本身的复杂度就很大，所以C++出现这么多年，真正堪称经典的面向对象类库和框架，几乎屈指可数。很多流行的库，比如MFC、iostream，都暴露出不少问题。一般程序员总觉得是自己的水平不够，于是下更大功夫去练剑。殊不知根本上是方向错了，脱离了对象范式的本质，企图用静态分类法来对现实世界建模，去刻画变化万千的动态世界。这么难的事，你水平再高也很难做好。

可以从一个具体的例子来理解这个道理，比如在一个GUI系统里，一个 Push Button 的设计问题。事实上在一个实际的程序里，一个 push button 到底“是不是”一个 button，进而是不是一个 window/widget，并不重要，本质上我根本不关心它是什么，它从属于哪一个类，在继承树里处于什么位置，只要那里有这么一个东西，我可以点它，点完了可以发生相应的效果，就可以了。可是Simula –> C++ 所鼓励的面向对象设计风格，非要上来就想清楚，a Push Button is-a Button, a Button is-a Command-Target Control, a Command-Target Control is-a Control, a Control is-a Window. 把这一圈都想透彻之后，才能 new 一个 Push Button，然后才能让它工作。这就形而上学了，这就脱离实际了。所以很难做好。你看到 MFC 的类继承树，觉得设计者太牛了，能把这些层次概念都想清楚，自己的水平还不够，还得修炼。实际上呢，这个设计是经过数不清的失败和钱磨出来、砸出来的，MFC的前身 Afx 不是就失败了吗？1995年还有一个叫做 Taligent 的大项目，召集了包括 Eric Gamma 在内的一大堆牛人，要用C++做一个一统天下的application framework，最后也以惨败告终，连公司都倒闭了，CEO车祸身亡，牛人们悉数遣散。附带说一下，这个Taligent项目是为了跟NextSTEP和Microsoft Cairo竞争，前者用Objective-C编写，后来发展为Cocoa，后者用传统的Win32 + COM作为基础架构，后来发展为Windows NT。而Objective-C和COM，恰恰就在动态消息分派方面，与C++迥然不同。后面还会谈到。

客观地说，“面向类的设计”并不是没有意义。来源于实践又高于实践的抽象和概念，往往能更有力地把握住现实世界的本质，比如MVC架构，就是这样的有力的抽象。但是这种抽象，应该是来源于长期最佳实践的总结和提高，而不是面对问题时主要的解决思路。过于强调这种抽象，无异于假定程序员各个都是哲学家，具有对现实世界准确而深刻的抽象能力，当然是不符合实际情况的。结果呢，刚学习面向对象没几天的程序员，对眼前鲜活的对象世界视而不见，一个个都煞有介事地去搞哲学冥想，企图越过现实世界，去抽象出其背后本质，当然败得很惨。

其实C++问世之后不久，这个问题就暴露出来了。第一个C++编译器 Cfront 1.0 是单继承，而到了 Cfront 2.0，加入了多继承。为什么？就是因为使用中人们发现逻辑上似乎完美的静态单继承关系，碰到复杂灵活的现实世界，就破绽百出——蝙蝠是鸟也是兽，水上飞机能飞也能游，它们该如何归类呢？本来这应该促使大家反思继承这个机制本身，但是那个时候全世界陷入继承狂热，于是就开始给继承打补丁，加入多继承，进而加入虚继承，。到了虚继承，明眼人一看便知，这只是一个语法补丁，是为了逃避职责而制造的一块无用的遮羞布，它已经完全已经脱离实践了——有谁在事前能够判断是否应该对基类进行虚继承呢？

到了1990年代中期，问题已经十分明显。UML中有一个对象活动图，其描述的就是运行时对象之间相互传递消息的模型。1994年Robert C. Martin在《Object-Oriented C++ Design Using Booch Method》中，曾建议面向对象设计从对象活动图入手，而不是从类图入手。而1995年出版的经典作品《Design Patterns》中，建议优先考虑组合而不是继承，这也是尽人皆知的事情。这些迹象表明，在那个时候，面向对象社区里的思想领袖们，已经意识到“面向类的设计”并不好用。只可惜他们的革命精神还不够。

7. 你可能要问，Java 和.NET也是用继承关系组织类库，并进行设计的啊，怎么那么成功呢？这里有三点应该注意。第一，C++的难不仅仅在于其静态结构体系，还有很多源于语言设计上的包袱，比如对C的兼容，比如没有垃圾收集机制，比如对效率的强调，等等。一旦把这些包袱丢掉，设计的难度确实可以大大下降。第二，Java和.NET的核心类库是在C++十几年成功和失败的经验教训基础之上，结合COM体系优点设计实现的，自然要好上一大块。事实上，在Java和.NET核心类库的设计中很多地方，体现的是基于接口的设计，和真正的基于对象的设计。有了这两个主角站台，“面向类的设计”不能喧宾夺主，也能发挥一些好的作用。第三，如后文指出，Java和.NET中分别对C++最大的问题——缺少对象级别的delegate机制做出了自己的回应，这就大大弥补了原来的问题。

尽管如此，Java还是沾染上了“面向类设计”的癌症，基础类库里就有很多架床叠屋的设计，而J2EE/Java EE当中，这种形而上学的设计也很普遍，所以也引发了好几次轻量化的运动。这方面我并不是太懂，可能需要真正的Java高手出来现身说法。我对Java的看法以前就讲过——平台和语言核心非常好，但风气不好，崇尚华丽繁复的设计，装牛逼的人太多。

至于.NET，我听陈榕介绍过，在设计.NET的时候，微软内部对于是否允许继承爆发了非常激烈的争论。很多资深高人都强烈反对继承。至于最后引入继承，很大程度上是营销需要压倒了技术理性。尽管如此，由于有COM的基础，又实现了非常彻底的delegate，所以 .NET 的设计水平还是很高的。它的主要问题不在这，在于太急于求胜，更新速度太快，基础不牢。当然，根本问题还是微软没有能够在Web和Mobile领域里占到多大的优势，也就使得.NET没有用武之地。

8. COM。COM的要义是，软件是由COM Components组成，components之间彼此通过接口相互通讯。这是否让你回想起本文开篇所提出的对象范型的两个基本原则？有趣的是，在COM的术语里，“COM Component ” 与“object ”通假，这就使COM的心思昭然若揭了。Don Box在Essential COM里开篇就说，COM是更好的C++，事实上就是告诉大家，形而上学的“面向类设计”不好使，还是回到对象吧。

用COM开发的时候，一个组件“是什么”不重要，它具有什么接口，也就是说，能够对它发什么消息，才是重要的。你可以用IUnknown::QueryInterface问组件能对哪一组消息作出反应。向组件分派消息也不一定要被绑定在方法调用上，如果实现了 IDispatch，还可以实现“自动化”调用，也就是COM术语里的 Automation，而通过 列集（mashal），可以跨进程、跨网络向另一组件发送消息，通过 moniker，可以在分布式系统里定位和发现组件。如果你抱着“对象——消息”的观念去看COM的设计，就会意识到，整个COM体系就是用规范如何做对象，如何发消息的。或者更直白一点，COM就是用C/C++硬是模拟出一个Smalltalk。而且COM的概念世界里没有继承，就其纯洁性而言，比Smalltalk还Smalltalk。在对象泛型上，COM达到了一个高峰，领先于那个时代，甚至于比它的继任.NET还要纯洁。

COM的主要问题是它的学习难度和安全问题，而且，它过于追求纯洁性，完全放弃了“面向类设计” 的机制，显得有点过。

9. 好像有点扯远了，其实还是在说正事。上面说到由于C++的静态消息机制，导致了形而上学的“面向类的设计”，祸害无穷。但实际上，C++是有一个补救机会的，那就是实现对象级别的delegate机制。学过.NET的人，一听delegate这个词就知道是什么意思，但Java里没有对应机制。在C++的术语体系里，所谓对象级别delegate，就是一个对象回调机制。通过delegate，一个对象A可以把一个特定工作，比如处理用户的鼠标事件，委托给另一个对象B的一个方法来完成。A不必知道B的名字，也不用知道它的类型，甚至都不需要知道B的存在，只要求B对象具有一个签名正确的方法，就可以通过delegate把工作交给B的这个方法来执行。在C语言里，这个机制是通过函数指针实现的，所以很自然的，在C++里，我们希望通过指向成员函数的指针来解决类似问题。

然而就在这个问题上，C++让人扼腕痛惜。
 
分享到： 

上一篇：周鸿祎，高司令
下一篇：悼念 Benoit MandelBrot
 . 


查看评论
 
83楼 tangtangzizi 2013-03-09 15:10发表[回复] 作为一个菜鸟级程序学员，都能感觉到这篇文章写得非常好，一口气读完，虽然有一些语言大神什么的不懂，但从根本上觉得，我们所学的面向对象编程还真的是面向类编程，茅塞顿开，谢谢指导！！82楼 FrankHB1989 2012-01-13 22:17发表[回复] programing paradigm可不是一层简单地分类。英文维基上就可以看到一长串。81楼 cpper_2007 2011-09-23 20:14发表[回复] 期待下文80楼 newrain021011 2011-03-24 12:58发表[回复] 程序是有对象组成，对象之间发送消息。消息的接收与处理，需要具体的函数去实现。函数不是对象，自然就无法达到对象之间发送消息的功能，C++的仿函数虽然实现了函数成为对象的可能，因为不是内建的，所以提供的安全保障实在有限。79楼 无趣 2011-03-15 11:14发表[回复] 下集出来了吗78楼 dumbledoreho 2011-01-15 20:16发表[回复] “A不必知道B的名字，也不用知道它的类型，甚至都不需要知道B的存在，只要求B对象具有一个签名正确的方法，就可以通过delegate把工作交给B的这个方法来执行。” 这点上Objective-C就做得很好。孟老大快出下集吧，等得好辛苦啊~77楼 stallboy 2011-01-14 19:40发表[回复] 每隔一些天都来看看有没更新，严重期待下集，孟老大，更新啊。76楼 moyanjwb 2011-01-13 14:51发表[回复] 全是废话，没一点用75楼 baibaichen 2010-12-22 10:27发表[回复] test74楼 lishihua514 2010-12-13 22:31发表[回复] 孟大侠，懂这么多，你的脑袋直接可以当CPU了，一开启，就不停的进出01010010100100000000000101010100101010010110100101010101010000000000101010100000,什么时候熄火。73楼 angowb 2010-12-13 10:10发表[回复] 严重期待下篇72楼 justyan 2010-12-10 09:31发表[回复] 老孟写的太精彩了，看的很过瘾[e06]
这是我第二次看这篇文章，还是有新的收获的。最后的结尾就像写小说一样，戛然而止。。。很期待下文啊，赶紧发吧[e01]71楼 有趣之极 2010-12-01 13:52发表[回复] 当年的偶像，侯捷干什么去了，他的网站也打不开了。。。70楼 coolmeme 2010-11-03 15:21发表[回复] 孟老大快发下文啊！69楼 wb197 2010-10-25 22:49发表[回复] 又想马儿跑，又想马儿不吃草，一切又都何尝不是正交并纠结着呢？
没错，现在是用上python了，可又如何呢？因为一个拼写错误而查很久，因为要下一个断点而连续的修改代码输出，动态语言或半动态语言的运行效率实在让人无法恭维，用C/C++想尽办法省下的那点效率被几下函数调用就消耗于无形了，当python遇上C，唉，为什么非得这样做呢？提高了开发效率吗？降低了项目风险吗？还是为了那无法放到台面上的利益？
我甚至开始怀疑所谓的信息隐蔽原则实质上是基于利益划分原则？其实设计过程不如说是一场圈地运动？哈哈，这一切都是浮云……68楼 zkkpkk 2010-10-16 23:26发表[回复] 对象指针是我的命67楼 WindYou 2010-10-15 10:09发表[回复] C++真正让人纠结的还是垃圾回收的问题！系统大了，对象多了，对象到底是被谁控制的，应该由谁来销毁就成了问题，COM想通过引用计数+SmartPtr来解决，但是不成功的。至于动态、静态，include、using、import能有多大的区别？设计一个程序时，上来就写下class CXxx是工作经验、设计思想的问题，非C++之过Re: wanruirui 2011-03-15 16:04发表[回复] 回复 WindYou：智能指针真的不能解决吗?抱怨这个只能说你是一个不负责任的男人。Re: lvan100 2012-07-29 20:44发表[回复] 回复wanruirui：I agree with you66楼 mattus_zhao 2010-10-15 09:45发表[回复] Rob Pike设计的Go语言，强调基于对象，而不是面向对象。
Go语言基于轻量级的类型系统，并且完全没有继承的概念。
同时，通过Interface{}实现隐式接口。
使用Goroutine+Channel实现并发。

是不是Rob Pike也考虑到面向对象（或者说面向类）并不是最好的解决问题的范式，而更加适合的是基于对象的范式？

另外，我不同明白，为什么Go语言要设计成隐式实现接口，而不是显式实现接口？

最后，孟岩能不能谈谈对在语言中增加垃圾回收的看法？比如，Java，C#，Objective-C和Go语言，都有垃圾回收的功能。Re: dancercl 2011-04-17 23:03发表[回复] 回复 mattus_zhao：
Go的隐式实现接口可以让你在外部扩充一个对象的行为，在C++/Java/C#中你必须要改动对象的实现才可以
这个应该是学习Haskell的type class，简洁强大65楼 弟十六 2010-10-15 09:19发表[回复] 最后那个关于delegate的描述最好像之前一样：套个GUI PushButton的例子描述一下，个人认为读者理解的会深些。64楼 begges 2010-10-14 14:39发表[回复] c++编写的程序是跑在传统的操作系统上的，编译出来的二进制码是在硬件上跑的。java和.net是在虚拟机上跑的，所以可以摆脱传统机器的某些束缚。63楼 cnmhx 2010-10-14 12:19发表[回复] [e01][e04][e03]62楼 wenkai168 2010-10-14 09:54发表[回复] 还没看完，学习了，先收藏。61楼 heguo 2010-10-13 21:42发表[回复] 计算机哲学，长进不少。[e03]60楼 BlueDog 2010-10-13 20:32发表[回复] 个人觉得也不一定要把function/bind升到那样的高度，也就是一个语法糖之类的东东，最多就是个回调和代理，还谈不上信号和消息机制，而且也不象C#原生的event和delegate好用，另外它无法解决，异步事件的问题。其次它的成本也是比较高的，一个function为了兼容钻石继承的类成员函数，它至少需要32个字节，速度也不快。未必比FastDelegate好用。
因为c++本意是在一种贴近机器的基础上来实现多种编程方式，因此它没有实现delegate和event，我想未来也不会有这些东东。c++的优点是可以用各种奇怪的手段来实现某个功能，其实未必是好事。毕竟我们只需要实现某个功能就好。
感觉现在c++库太多，可是象字符串这个常用的东东，都面临着一大堆选择。可能很多人用了多年的c++，仍对c++感到陌生。
个人越来越喜欢python了，够用就行。程序员有必要要掌握茴字的所有写法么？Re: myan 2010-10-14 11:42发表[回复] 回复 BlueDog：我也是 FastDelegate 的拥护者，对 function / bind 并没有那么高的评价，等下部分写完了请再指教。59楼 BaiyanHuang 2010-10-13 14:59发表[回复] 孟兄多次提到C#吸取了COM体系设计的优点从而胜出于C++，可否具体讲一下C#哪些方面吸取了COM的哪些优点？58楼 MagiSu 2010-10-13 10:04发表[回复] 前面有人提到了Qt，感觉性能上还是差了点。当然在新机器上不太看得出来，但是在老机器上KDE明显比GTK慢，我有开发的Qt程序也明显感觉迟钝。Qt的消息传递是传递字符串让我感到非常郁闷。

我的理解，C++现在是被人用的歪门邪道太多。太多的人过分浸淫在了抽象体系中，而忽略了具体项目的应用，导致代码过分抽象。这是C++程序员非常容易犯的错误。

我用C++到现在，逐渐喜欢上了小类，将对类的操作抽出类本身变成名字空间里的函数，抽象尽量用模板来实现。感觉还是受到STL的影响比较多。

说到多重继承，感觉C++如果能够限制多重继承，比如禁止钻石型继承什么的，还是比较好的。我觉得Ruby的MIXIN手段很丑陋，不直观。

callback是一种越用越有趣的手段。Re: zy498420 2010-10-13 16:25发表[回复] 回复 MagiSu：QEvent类定义没有Q_OBJECT也没不是QObject,哪里来的字符串（object name或者class name）哦。

和任何框架一样，QEvent包含type信息的，short类型我想还是开销得起的。如果连type都没有，那只能强耦合了（原来是我叫某人干某事，变成我拉着某人的手干某事，区别在于怎么干都要我来指定了）
也就是先生喜欢的，狭义的回调了。

至于信号槽之类的，是用来一些地方gui方便的。不要经常定义或者发射自定义信号就是了。我用qt2,3,4。直到4.6之前，qt都挺清爽的。不过nokia3天2头让他兼容mameo,symbian,meego,已经有朝超级大库发展的潜质了。Re: bfzhao 2010-10-13 16:19发表[回复] 回复 MagiSu：另，关于使用静态语言实现动态类型系统，我专门写了一个短文讨论。尽管很简单，还是可以看出其中性能损失是在哪里。http://blog.csdn.net/bfzhao/archive/2010/10/12/5935332.aspx。Re: bfzhao 2010-10-13 16:03发表[回复] 回复 MagiSu：要想使用动态消息，使用字符串基本上是最优的选择了。静态类型系统一般通过使用函数签名来区别不同的消息，动态系统则使用不同的字符串，字符串是让人容易理解和阅读的最简单的形式。

您说的使用小类确实是一门有用技巧，这也是单职责原理要求的。

你说的抽象是指OO抽象吗？如果是，抽象和模板你是怎么联系起来的？可以给一个具体的例子说明吗？模板确实依赖于特定的型，而型是抽象的结果。好像一般认为模板和OO是正交的。

至于多重继承，本来就是为接口继承准备的。C++流库做了一个很坏的实现继承的榜样，基本也是定论了吧。Re: myan 2010-10-13 10:23发表[回复] 回复 MagiSu：老兄，你的观点与我心有戚戚焉。不过我对Qt的性能并没有太大意见，在C++的静态本质上加上动态特征，传递和解释字符串可能也是迫不得已而为之。57楼 whatcanhumdo 2010-10-13 09:23发表[回复] [e01][e01][e01]严重期待第二篇56楼 chenmalin865410981 2010-10-12 18:58发表[回复] 写的真好，学习55楼 qy300 2010-10-12 18:51发表[回复] 在设计.NET的时候，微软内部对于是否允许继承爆发了非常激烈的争论
==========================================
很怀疑这句，现在还有那种严肃的语言不支持继承的？.net的设计师不可能在这个问题上争论，倒是可能在是否允许多重继承有争论。54楼 luofuliang 2010-10-12 18:06发表[回复] C++更新标准的速度太慢了，虽然说语言特性不应该常变，而应该通过库形式来实现。
C确实太强大了，难怪那么多的动态语言都是基于C来实现的。
C++历史的包袱本来就重，又变化不灵活。53楼 wxt 2010-10-12 14:21发表[回复] 非常期待下篇52楼 llflw_ukey 2010-10-12 12:55发表[回复] 建议把原文链接贴出来[e01]51楼 G_cofa 2010-10-12 09:11发表[回复] [e03] 非常期待下篇啊。50楼 bfzhao 2010-10-11 16:14发表[回复] 无法大段回复，我贴在这里了http://blog.csdn.net/bfzhao/archive/2010/10/11/5933708.aspx。谢谢指教49楼 zufeng_chen 2010-10-11 15:34发表[回复] 额...几乎是history，还没看到bind/function的妙处48楼 Aniao 2010-10-11 15:15发表[回复] 其实很多东西都是要代价的，如果从底层内存来考虑，其实C++真的是在设计和效率之间做了很多平衡了。如果加入那么动态的东西，比如按照签名来调用接口，那需要很多元数据，而不是以前那样编译出来如C一样简洁的汇编语言。而至于委托，函数指针虽然不好用，但是真的是如汇编一般高效。
 其实总结来说我不知道LZ的意思是否是要效率C就足够了，要开发速度真的要用动态一点的语言。47楼 bfzhao 2010-10-11 12:49发表[回复] 孟老大的文章不错。让人纠结的唯一的问题，讨论其中任何一点都需要大量的文字。非常佩服掌握了如此多的材料，但是不幸的是，结果是错的。先在这里列一个简要的提纲，分别论述。
1. 区分技术和工具
2. 区分型和类
3. 名词的准确定义以及使用
4. OO思想及其在不同语言中的实现
5. damn it！C++46楼 chenyu2202863 2010-10-11 11:47发表[回复] bind/function确实能提高不少的开发效率，只是对目前的C++标准来说，还有一些缺陷。

软件业的历史才能揭示真谛，瞻前的前提是要顾后！45楼 younker 2010-10-11 10:04发表[回复] 所以说Object-C还是很牛B的，虽然效率上可能有所牺牲，但是在动态消息的处理上绝对是当今最牛的实现了。44楼 yshuise 2010-10-11 09:44发表[回复] 知识面很广，令人佩服。[e04][e04][e04][e04][e04]43楼 redredbird 2010-10-11 00:18发表[回复] 其实c++导致后来出现的静态的“面向类型”的情况也是不得已啊，那时候机器效率比开发效率重要，现在觉得动态语言多么多么好也是源于硬件的进步。在驱动软件等领域还是c/c++占统治地位。42楼 shendl 2010-10-10 23:21发表[回复] 我感觉孟老大的意思是，动态语言比静态语言强。因为静态语言必须要知道目标对象所属的类型！
 这一点我并不认同。 有一个反例----OCaml语言！ 它是静态的函数式语言，也拥有完备的面向对象机制实现了类和多继承、接口，自动内存管理。
 并且可以直接编译成机器码，执行速度和C程序一样快。 我不明白的是这么好的语言为什么排名一直垫底？

 静态语言的优势是，编译器可以检查出类型错误。 编译器可以对代码进行优化。 因此静态语言比动态语言执行速度更快。 动态语言的优点是灵活，甚至可以运行时修改类型，修改对象。Re: zhblue 2010-10-14 07:51发表[回复] 回复 shendl：
我猜这么好的东西，对人的要求也一定跟高，以至于要会用脑编译的人才能熟练掌握吧。41楼 shendl 2010-10-10 23:13发表[回复] DCOM那个RPC也没什么。而且现在已经不流行二进制的RPC了，流行基于文本的RPC，如JSON-RPC.XML-RPC,WebService等。 标准C的RPC也很多。 
COM还是太复杂了。 微软太能吹了，.NET刚出来时还叫做COM++。 很迷惑了我一阵，其实.NET和COM.COM+屁关系都没有！40楼 shendl 2010-10-10 23:09发表[回复] 没觉得COM好。可能是我对COM研究得不深。
COM就是一个引用计数，用来自动管理内存。DCOM就是有一个网络程序，stub和Server。实现了RPC而已。
 其实COM就这点，其它和普通的C没什么区别， 我认为COM没有存在的必要，C就可以了。
GTK的底层是GObject库，实现得比COM好，还简单。 我自己也做过类似的更简单的C语言的面向对象框架，实现多线程安全和内存自动管理（也使用引用计数），过几天有空拿出来给大家看看吧[e04]Re: shendl 2010-10-10 23:24发表[回复] 回复 shendl：
COM还修改了编译器。COM还只能在Windows上跑。 Linux上跑不了的东西，没什么意义了。

 另外， C++里做GUI比较成功的QT也修改了编译器。39楼 shendl 2010-10-10 23:05发表[回复] 写得不错[e01] 继续！
 但我觉得C语言写GUI也不错的。GTK就很棒。 用C模拟类，实现继承，用函数指针实现事件，都挺好的。
Java的Swing也写得不错，就是相对动态语言，有些复杂了而已。38楼 hlg5555 2010-10-10 22:24发表[回复] [e01]37楼 lebrone 2010-10-10 21:58发表[回复] 好啊[e01]36楼 steel_de_lee 2010-10-10 20:57发表[回复] 不知道孟老大要表达什么意思，C++很烂，Java也很烂？COM和.Net好一点？但是COM和.Net能直接和C++比吗？QT在孟老大的体系中算个什么地位？

这文章看着似乎很有营养，实际上什么都没有说出来35楼 csuchao 2010-10-10 20:10发表[回复] 同意longshanks的观点，C++中public方法是属于类的，不是属于对象的，也就是孟岩所说的面向类的。这使得对象交互时不去看对象有什么接口，而是去看对象所属的类有什么接口。

C++编码之前必须先将现实事物高度抽象为类，这和我们对现实世界的认知是不一样的，凭空增加了我们编码的难度和工作量。34楼 epm240 2010-10-10 15:48发表[回复] 过程，对象，函数什么的都是浮云啊。

重要的是事实空间中的逻辑关系，和状态迁移过程中逻辑关系的变化。一旦时态逻辑引入程序设计语言中，逻辑编程的时代就到了。33楼 wuxiwx 2010-10-10 14:07发表[回复] 现在看不太懂啊，但还是[e01]一下32楼 tigerVC 2010-10-10 11:40发表[回复] 好好学习，实用第一，这么深的东西知之甚少。31楼 longshanks 2010-10-10 09:56发表[回复] OOP语言的用类型作为接口的实现手段，是它们烦恼的根源。用一个类型代表一组类型，天生就会引发悖论。接口必须是独立于类型的实体。
OOP本身的问题在于，把所有的东西都作为对象，那么谁来处理对象间的关系？当然可以创建负责处理对象关系的对象，但这样不是将问题复杂化了么？软件需要准确地模拟现实世界，但编程不应如此。
另外，从实践出发，实现标准OOP消息的语言只能动态化，没有了类型检测，大量错误被推迟到运行时发现，对于程序质量有很大的影响。对于web或界面程序问题不大，但对于服务级和系统级软件是个大麻烦。30楼 sf450359023 2010-10-10 09:36发表[回复] [e01][e01][e01]29楼 土著巫师 2010-10-10 00:51发表[回复] 庆幸我使用C++BUILDER做为开发工具，使用过C++BUILDER的程序员早知道怎么样用一个CLASS（组件）的成员方法响应另一个CLASS（组件）的属性事件了，程序员根本感觉不到回调的存在。28楼 csuchao 2010-10-10 00:25发表[回复] 太好了，是我所看过最有意义的一篇文章了。

之前看过陈硕的一篇讲function和bind的文章，我感觉用接口来实现回调也没啥区别，现在看来是我境界太低了。

我的理解：C++中对象之间传递消息（方法调用），实际上就是一个内存地址（函数指针或者成员函数指针），从这一观点来看，对象A甚至不用知道对象B的名称和类型就可以调用B中的方法了。孟老大，我的理解正确否？Re: myan 2010-10-10 09:36发表[回复] 回复 csuchao：严格的说，是迟绑定，到运行时才知道B的具体情况。Re: zy498420 2010-10-10 13:29发表[回复] 回复 myan：bind不能用于虚函数，就是实际中没几个人用的原因。这也是qt不用模版而用预处理来玩信号槽的缘故（当然和移植性也有关）Re: Solstice 2010-10-10 20:04发表[回复] 回复 zy498420：bind 可以用于虚函数。 http://gist.github.com/619185Re: zy498420 2010-10-10 21:52发表[回复] 回复 Solstice：再啰嗦2句，多继承条件下也测试通过了。（也是明摆着的事实）。有覆盖的情况时，和直觉思考的结果相同。gcc4.2Re: zy498420 2010-10-10 21:43发表[回复] 回复 Solstice：再费话2句（也许是我比较弱，比较啰嗦）。tr1和boost的bind语义是一致的；mem_fun等一系列老适配器和虚函数居然也能融洽配合（我真的感觉我比较弱了，想一下这些东西的实现最后都落到了一个p-&gt;x()身上，不多态才怪。平时光用不想，该打板子）Re: zy498420 2010-10-10 21:31发表[回复] 回复 Solstice：谢谢陈大家的纠正。这些东西平时少用，真的没注意阿。27楼 zy498420 2010-10-10 00:17发表[回复] my opinion: 用c（或c++的c语言部分）来设计模块（横向划分），用c++（的类和多态）来分层（纵向划分）。交换工作会给非超大牛人士带来很多苦恼。 

绝大多数人对设计二字的理解要么是只有模块，要么就只有分层。我见过太多了。 

只有模块的设计绝大多数依然是好程序，只有分层的设计基本都是失败品。这就是有厨房，卧室，大厅的平房和每一层都只有2-3平方米居住面积的20层高楼之间的区别。能够有工程师把2个都设计好，就是成功的高楼大厦了。 

用c++来设计模块的人最后都抱怨c++凭空添加了好多麻烦，并且降低了模块的内聚（linux之父就这样认为，可惜他的有些攻击c++的言论常常被厌恶c++和死忠c++的人断章取义。哎，大师其实很孤独）。symbian就这样，博主说的对，symbian以为程序员都是哲学家（另外繁杂的内存管理还要求你是水利工程师，擅长查漏补缺）。　　　　　　　　　　　　


用c来分层（前提是正确的分层哈，要点水平）其实本质都是在把c++作的事情在作一遍。君不见linux之用来封装文件操作的file_operations结构体，不就是一个虚表嘛，里面装的函数指针个个都带this指针作参数的。用句柄而不用指针来索引这些虚表是因为这个虚表是内核空间的（奇怪的是很少有人抱怨，实际驱动程序中，这个结构体里面的指针绝大多附值都是空，浪费内存，而且还是常驻内存不能换页的。而对mfc却要求这么苛刻）。总之linux里面的内核代码分层，把函数指针晃来晃去其实都是把c++编译器作的事情提升到内核空间做了一遍。用c来分层的，其实也就是显示了下自己的nb：“我实现了c++的虚函数”。com更nb,在c++标准出来之前实现了一个和c++对象模型差不多的c模型,还有win附带的异常体系。c++正式标准一出来，连vc编译器多继承的布局都要倒来兼容com。瞬间com就成了跨语言的家伙。哎，如今还有谁写com的程序呢，写activex的人只怕也不多了。感慨了。 

其实世界上绝大多数问题的解决方法都是用正确的工具作正确的事。软件嘛，还需要合适的人去做合适的事。


用c来分层的其实本质都是在把c++作的事情在作一遍。君不见Re: bfzhao 2010-10-11 17:17发表[回复] 回复 zy498420：才看到你的回复，确实如此！使用C实现对象的机制的代码多了去了，我们认为这是高手；回过头来却批评C++的实现方式这不好那不好。其实语言定义和编译器实现的OO要比绝大多数的手工实现不知要好多少倍。有人说，不理解Unix，注定要重新发明Unix。这里我们其实也可以说，不理解OO思想以及C++如何实现OO的，注定也要重新发明C++。Re: cplusplus_tmp 2010-10-11 10:19发表[回复] 回复 zy498420：回复 zy498420：不要想着通过语言来做设计做分层，这么做没有生命力，最终力竭而死Re: zy498420 2010-10-11 14:04发表[回复] 回复 cplusplus_tmp： 表达你的思想，需要一个好的工具。我知道法语很美，但是我不可能选择法语表达我的思想。我知道汇编很美，但是我不会用用汇编来（对人）表达我的任何设计。底层的语言可以描述一切细节，但是并不能很直观的表达（人的）设计。上层的语言很直观，但是并不一定能准确的描述一些细节。我知道uml很美，但是uml作的类图（我）仅仅用于沟通，实现往往都和uml的设计差别很大（谁敢在实际工程中用case工具的正向工程生成代码？）。做合适的事情选择合适的工具，不要被所谓的“语言不重要，思想（设计）才是一切”之类的大话忽悠了，那是对有中国特色的“懒”字的展开。代码大全２有一句（和原话有出入但就这个意思）：你能有多少思想取决于你表达思想的语言。我的理解：无法表达或者很生涩的表达甚至用外星人的高级语言来表达的思想是没有生命力的。26楼 universee 2010-10-09 23:09发表[回复] 任何时候都不要面向对象，那将会把系统设计带入泥潭Re: myan 2010-10-10 07:19发表[回复] 回复 universee：要是应付得来，完全不用对象范式当然也是挺好的，我不反对。25楼 universee 2010-10-09 23:08发表[回复] 伟大的STL之父Alex Stepanov讲出了普适之真理，猛烈抨击“一切都是对象”，却被我所欣赏的孟岩认为是“披着人皮的外星高等智慧”，啊呀，孟岩啊，廉颇老矣，尚能饭否？---------太极语言之父Re: healer_kx 2010-10-09 23:31发表[回复] 回复 universee：
嘿嘿。24楼 鼠 2010-10-09 21:23发表[回复] [e01][e03]牛人就是牛人，期待下篇～～23楼 pass86 2010-10-09 19:04发表[回复] 代码写得好看不一定好调试。22楼 pass86 2010-10-09 19:04发表[回复] 代码写的好看比一定好调试。21楼 chenchao868 2010-10-09 17:34发表[回复] 经典好文，不能不顶[e01]20楼 caobob 2010-10-09 17:29发表[回复] 比较深刻。为什么不把面向过程和面向对象结合起来处理现实的问题？这样往往事半功倍。19楼 GARY 2010-10-09 17:29发表[回复] 我会仔细阅读。[e01]18楼 cswluo 2010-10-09 17:09发表[回复] 先[e01]再说17楼 xzjxylophone 2010-10-09 15:43发表[回复] 先顶在说16楼 jokeesloat 2010-10-09 15:38发表[回复] 都是大神！仔细阅读！15楼 cplusplus_tmp 2010-10-09 14:37发表[回复] c++的class在h文件里对private成员的裸露，这是我认为c++最丑陋的地方之一。
我对c++的干法是：以c的风格结合stl/boost用之。stl的function/bind确实很优雅14楼 DaNmarner 2010-10-09 14:27发表[回复] 写的太好了！一语道破了当今所谓面向对象的myth。以前看到牛说Javascript是class-free的有多好多好一直不明白是个什么道理。看完您的论述之后醍醐灌顶了：JS没有class，直接从对象层进行操作其实更接近对象范式的原始思想，解放了开发者抽象的负担！13楼 cplusplus_tmp 2010-10-09 14:14发表[回复] 对我来说，c和c++的区别不是太重要。我的思想认同从c到c++而后回到c，而从来没有去过java/.net之类，根本的原因在于它们失去了user的“控制”。java之类比之c++在后台做了更多暗无天日的控制和限制，这是我不能认同它们之根本所在。
跟linux一样，我认为c++的这种“面向类”的语言，标志性地发展出mfc之类的大物，是一个过度庸俗化的过程，不值得推崇。
大道至简！12楼 cplusplus_tmp 2010-10-09 12:33发表[回复] Linux说的对，重要的不是语言，是思想[e04]11楼 cplusplus_tmp 2010-10-09 12:32发表[回复] 我没有用过Smalltalk。但是，Smalltalk language是否“仅是一门语言”，我有很大的怀疑。
相比asm/C/C++之类，Smalltalk language实现的那个“消息机制”，应该可称之为“Smalltalk OS”了吧。仅当猜测。
如果真是如此，那就不难理解为什么Smalltalk language这么曲高和寡了:一门和OS绑在一起的“语言”，!#^#$&amp;&amp;%%$#$@#@))*&amp;%^#Re: myan 2010-10-09 12:46发表[回复] 回复 cplusplus_tmp：你猜的对啊，Smalltalk是语言，也是平台。10楼 Dion 2010-10-09 12:21发表[回复] 谢谢孟岩9楼 wjp_116 2010-10-09 11:45发表[回复] 绝对的牛人，我再多活2辈子也达不到这个程度，悲哀[e01]8楼 buxieyigu 2010-10-09 11:04发表[回复] 醍醐灌顶7楼 cplusplus_tmp 2010-10-09 11:00发表[回复] C++是强类型语言，很多人对这句话的内涵没有给予足够的重视和体味6楼 halida 2010-10-09 09:44发表[回复] 同意面向对象, 而不是面向类. 
复杂的逻辑用分而治之的方法得到的是一块块的&quot;对象&quot;已经他们之间清晰的通讯方式.
文章细节太多了. 期待下篇关于C++的部分.5楼 Solstice 2010-10-09 09:04发表[回复] 深刻！
doseNotUnderstand -&gt; doesNotUnderstandRe: myan 2010-10-09 09:17发表[回复] 回复 Solstice：改了，多谢。4楼 yuanlm189 2010-10-09 08:47发表[回复] 好文章！请问COM比.NET先进体现在哪里？QueryInterface与反射有什么异同？C#语言将会发展成使用“动态消息机制”么？Re: myan 2010-10-09 09:17发表[回复] 回复 yuanlm189：不是先进性，是纯洁性。原文我已经改了。C#怎么发展我都不惊讶，但是其实这是它的问题：发展太快了。3楼 ljtxa 2010-10-09 08:29发表[回复] 期待续！收藏之。2楼 xingcpp 2010-10-09 07:37发表[回复] 孟老大，有一个笔误：
STL之夫Alex StepanovRe: myan 2010-10-09 08:38发表[回复] 回复 xingcpp：已修改，多谢。1楼 liigo 2010-10-09 00:36发表[回复] [e01][e03] 得仔细阅读。
 


您还没有登录,请[登录]或[注册]
 
* 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场
 








个人资料

myan
 



访问：2293143次
积分：21311分
排名：第66名
.原创：163篇
转载：3篇
译文：0篇
评论：6459条
. 
文章搜索

. 
文章分类CSDN和《程序员》杂志(5)
产业(13)
技术(12)
数学(1)
杂文(4)
 
文章存档
2010年11月(1).
2010年10月(2).
2010年09月(4).
2009年05月(1).
2008年12月(2).
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

展开.
 
阅读排行放弃理想，未必能成就现实(123714)
9月17日Stan Lippman访谈录文字节选(98011)
理解矩阵（一）(68792)
Linux之父话糙理不糙(54360)
技术路线的选择重要但不具有决定性(50376)
理解矩阵（二）(47508)
不同地区技术人才需求量的统计和分析(45780)
快速掌握一个语言最常用的50%(37210)
Java替代C语言的可能性(36879)
理解矩阵（三）(36696)
 
评论排行Java替代C语言的可能性(227)
Linux之父话糙理不糙(205)
周鸿祎，高司令(188)
终于有人说出来了——Java不适合于作为主要编程教学语言(185)
9月17日Stan Lippman访谈录文字节选(160)
理解矩阵（二）(156)
技术路线的选择重要但不具有决定性(155)
理解矩阵（一）(152)
动态语言，别再说不(132)
关于C++复杂性的零碎思考(131)
 
推荐文章 
最新评论 function/bind的救赎（上）
tangtangzizi: 作为一个菜鸟级程序学员，都能感觉到这篇文章写得非常好，一口气读完，虽然有一些语言大神什么的不懂，但从... 

技术路线的选择重要但不具有决定性
m1111121: 做哪类人，我目前还不想过多的考虑。但是这句很有意义：正确的态度应该是着重于你要干的事情，然后认真把这... 

对于技术术语专业化的思考
skycat1980: 呀，再补充下，我了个大去啊，都是7年前的老物了，真是相见恨晚呀。嘿嘿！ 

对于技术术语专业化的思考
skycat1980: 说的太好了，我在别处看了文章前部分，就觉得实在是鞭辟入里，十分感谢您的分析和分享！总感觉国人太把技术... 

理解矩阵（一）
moonlight_: 谢谢老师分享，这根本性问题，我都遇到过，再次感谢！ 

书非K不能读
buck_: 见了题目，第一反应还以为是评论knuth的书或者K&R那本，进来发现原来这里k是个动词。人的精力是有... 

周鸿祎，高司令
zirandeai: 孟老师说的大实话。不要仅仅从技术人员的角度看问题，企业作为一个经济体，要拿出手的是产品，拿回来的得是... 

理解矩阵（二）
fishOnFly: 吼吼，太美了！矩阵用于对变换的一种描述：从线性空间内点到点变换，到线性空间之间的点到点变换，对于后者... 

理解矩阵（一）
fishOnFly: 原来这种思维方式的术语叫做“直觉性”...和大多数路人一样，现代也考砸了，谢谢孟老师，该系列太棒了！ 

Linux之父话糙理不糙
kangear: 2007-09-08的文章，后生拜读了，很激烈！但是我看最近的语言排名是1 C 2Java3Obje... 



. 
公司简介|招贤纳士|广告服务|银行汇款帐号|联系方式|版权声明|法律顾问|问题报告京 ICP 证 070598 号北京创新乐知信息技术有限公司 版权所有世纪乐知(北京)网络技术有限公司 提供技术支持江苏乐知网络技术有限公司 提供商务支持 联系邮箱：webmaster(at)csdn.netCopyright © 1999-2012, CSDN.NET, All Rights Reserved  
