
汇编中的test和cmp比较

 
首先看看:状态寄存器(即标志寄存器)

PSW(Program Flag)程序状态字(即标志)寄存器,是一个16位寄存器,由条件码标志(flag)和控制标志构成,
如下所示:

15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 
　 　 　 　 OF DF IF TF SF ZF 　 AF 　 PF 　 CF

条件码：
①OF(Overflow Flag)溢出标志,溢出时为1,否则置0.标明一个溢出了的计算,如:结构和目标不匹配.
②SF(Sign Flag)符号标志,结果为负时置1,否则置0.
③ZF(Zero Flag)零标志,运算结果为0时置1,否则置0.
④CF(Carry Flag)进位标志,进位时置1,否则置0.注意:Carry标志中存放计算后最右的位.
⑤AF(Auxiliary carry Flag)辅助进位标志，记录运算时第3位(半个字节)产生的进位置。
有进位时1,否则置0.
⑥PF(Parity Flag)奇偶标志.结果操作数中1的个数为偶数时置1,否则置0.

控制标志位：
⑦DF(Direction Flag)方向标志，在串处理指令中控制信息的方向。
⑧IF(Interrupt Flag)中断标志。
⑨TF(Trap Flag)陷井标志。


为举例方便说一下jnz和jz
测试条件
JZ ZF=1 
JNZ ZF=0 
即Jz＝jump if zero (结果为0则设置ZF零标志为1,跳转)
Jnz＝jump if not zero

好,接着来看test和cmp

*******************************************************************************
test属于逻辑运算指令

功能: 执行BIT与BIT之间的逻辑运算
测试(两操作数作与运算,仅修改标志位,不回送结果). 
Test对两个参数(目标，源)执行AND逻辑操作,并根据结果设置标志寄存器,结果本身不会保存。EST AX,BX 与 AND AX,BX 命令有相同效果

语法: TEST r/m,r/m/data
影响标志: C,O,P,Z,S(其中C与O两个标志会被设为0)

运用举例:
1.Test用来测试一个位,例如寄存器:

test eax, 100b; b后缀意为二进制
jnz ******; 如果eax右数第三个位为1,jnz将会跳转

我是这样想的,jnz跳转的条件是ZF=0,ZF=0意味着ZF(零标志)没被置位,即逻辑与结果为1.

2.Test的一个非常普遍的用法是用来测试一方寄存器是否为空:

test ecx, ecx
jz somewhere

如果ecx为零,设置ZF零标志为1,Jz跳转

*******************************************************************************
CMP属于算术运算指令

功能: 比较两个值(寄存器,内存,直接数值) 
语法: CMP r/m,r/m/data 
标志位: C,P,A,Z,O

CMP比较.(两操作数作减法,仅修改标志位,不回送结果). 
cmp实际上是只设置标志不保存结构的减法,并设置Z-flag(零标志).
零标志很像carry,也是内部标志寄存器的一位.

例如:
Cmp eax, 2; 如果eax-2=0即eax＝2就设置零标志为1
Jz ****; 如果设置了零标志就跳转


*******************************************************************************
我得出的结论
test逻辑与运算结果为零,就把ZF(零标志)置1;
cmp 算术减法运算结果为零,就把ZF(零标志)置1.

 

从看雪转载的，今天在做免杀，遇到一个经常的指令段

