
seg cs是什么意思，看看这里就知道了！ 

分类： linux-0.11学习2011-04-07 21:44403人阅读评论(0)收藏举报
 
汇编linux语言

 
【转帖】
 
先讲一下寄存器的默认组合问题，比如指令mov   [si],   ax表示将ax中的内容存入ds:si指向的内存单元，也就是说在寄存器间接寻址的情况下,以si间接寻址时总是默认以ds为相应的段地址寄存器。同样di是以es为默认的段地址寄存器。 
第二个要了解的是“段超越”的问题，就是在某些时候你不想使用默认的段地址寄存器，那 
么你可以强制指定一个段地址寄存器（当然这种强制是在允许的情况下，建议看一下汇编 
教材上的说明），同上例mov   [si],ax表示存入ds:si中，但如果你想存入cs指向的段中可 
以这样mov   cs:[si],ax，   这样就强制指定将ax中的内容存入cs:si的内存单元。 
第三个要明白的是seg   cs这样的语句只影响到它下一条指令，比如在linux启动代码中的一段： 
      seg   cs 
      mov   sectors,ax 
      mov   ax,#INITSEG 
要说明两点： 
    第一，seg   cs   只影响到mov   sectors,ax而不影响mov   ax,#INITSEG 
    第二，如果以Masm语法写，seg   cs和mov   sectors,ax两句合起来等 
                价于mov   cs:[sectors],ax，这里使用了间接寻址方式。 
                重复一下前面的解释，mov   [sectors],ax表示将ax中的内容 
                存入ds:sectors内存单元，而mov   cs:[sectors],ax强制以 
                cs作为段地址寄存器，因此是将ax的内容存入cs:sectors内存 
                单元，一般来说cs与ds的值是不同的，如果cs和ds的值一样， 
                那两条指令的运行结果会是一样的。（编译后的指令后者比前 
                者一般长一个字节，多了一个前缀。） 
    结论，seg   cs只是表明紧跟它的下一条语句将使用段超越，因为在编 
                译后的代码中可以清楚的看出段超越本质上就是加了一个字节 
                的指令前缀，因此as86把它单独作为一条指令来写也是合理的。 
基本情况就是这样，因为Linux使用了as86的汇编语言，与国内教科书上教的存在一些差 
异。

