
C++中的.hpp资料与.h文件 




www.MyException.Cn   发布于：2012-07-15 20:20:06   浏览：25次 







C++中的.hpp文件与.h文件

      1、是Header   Plus   Plus 的简写。
 

2、与*.h类似，hpp是C++程序头文件 。
 
3、是VCL专用的头文件,已预编译。
 
4、是一般模板类的头文件。
 
5、一般来说，*.h里面只有声明，没有实现，而*.hpp里声明实现都有，后者可以减 少.cpp的数量。
 
6、*.h里面可以有using   namespace   std，而*.hpp里则无。
 
7、*.hpp要注意的问题有：
 
      a)不可包含全局对象和全局函数
 
     由于hpp本质上是作为.h被调用者include，所以当hpp文件中存在全局对象或者全局函数，而该hpp被多个
 
    调用者include时，将在链接时导致符号重定义错误。要避免这种情况，需要去除全局对象，将全局函数封
 
    装为类的静态方法。
 
      b)类之间不可循环调用
 
      在.h和.cpp的场景中，当两个类或者多个类之间有循环调用关系时，只要预先在头文件做被调用类的声明
 
    即可，如下：
 
    class B;
 
    class A{
 
    public:
 
         void someMethod(B b);
 
    };
 
    class B{
 
    public:
 
         void someMethod(A a);
 
    };
 
    在hpp场景中，由于定义与实现都已经存在于一个文件，调用者必需明确知道被调用者的所有定义，而不能等到cpp
 
    中去编译。因此hpp中必须整理类之间调用关系，不可产生循环调用。同理，对于当两个类A和B分别定义在各自的 
 
    hpp文件中，形如以下的循环调用也将导致编译错误：
 
    //a.hpp
 
    #include "b.hpp"
 
    class A{
 
    public:
 
        void someMethod(B b);
 
    };
 
 
 
    //b.hpp
 
    #include "a.hpp"
 
    class B{
 
    public:
 
        void someMethod(A a);
 
    }
 
      c)不可使用静态成员
 
      静态成员的使用限制在于如果类含有静态成员，则在hpp中必需加入静态成员初始化代码，当该hpp被多个文档include时，将产生符号重定义错误。唯 一的例外是const static整型成员，因为在vs2003中，该类型允许在定义时初始化，如：
 
    class A{
 
    public:
 
       const static int intValue = 123;
 
    };
 
    由于静态成员的使用是很常见的场景，无法强制清除，因此可以考虑以下几种方式（以下示例均为同一类中方法）
 
   一、类中仅有一个静态成员时，且仅有一个调用者时，可以通过局域静态变量模拟
 
    //方法模拟获取静态成员
 
    someType getMember()
 
    {
 
       static someType value(xxx);//作用域内静态变量
 
       return value;
 
    }
 
   二、.类中有多个方法需要调用静态成员，而且可能存在多个静态成员时，可以将每个静态成员封装一个模拟方法，供其他方法调用。
 
 
 
    someType getMemberA()
 
    {
 
       static someType value(xxx);//作用域内静态变量
 
       return value;
 
    }
 
    someType getMemberB()
 
    {
 
       static someType value(xxx);//作用域内静态变量
 
       return value;
 
    }
 
   void accessMemberA()
 
    {
 
       someType member = getMemberA();//获取静态成员
 
    };
 
    //获取两个静态成员
 
    void accessStaticMember()
 
    {
 
       someType a = getMemberA();//获取静态成员
 
       someType b = getMemberB();
 
    };
 
 
 
    三、第二种方法对于大部分情况是通用的，但是当所需的静态成员过多时，编写封装方法的工作量将非常
 
    巨大，在此种情况下，建议使用Singleton模式，将被调用类定义成普通类，然后使用Singleton将其变为 
 
   全局唯一的对象进行调用。
 
    如原h+cpp下的定义如下：
 
    class A{
 
    public:
 
        type getMember(){
 
           return member;
 
        }
 
        static type member;//静态成员
 
    }
 
 
 
    采用singleton方式，实现代码可能如下（singleton实现请自行查阅相关文档）
 
    //实际实现类
 
    class Aprovider{
 
    public:
 
        type getMember(){
 
           return member;
 
        }
 
        type member;//变为普通成员
 
    }
 
 
 
    //提供给调用者的接口类
 
    class A{
 
    public:
 
        type getMember(){
 
           return Singleton<AProvider>::getInstance()->getMember();
 
        }
 
    }

