嵌入式开发的一些基本问题

分类： 美妙世界linux 2010-10-09 01:17 195人阅读 评论(0) 收藏 举报
嵌入式数据结构file嵌入式操作系统存储工作
1.嵌入式处理器有哪些特点？
答：有4个基本特点。
●     对实时多任务有很强的支持能力，能完成多任务并且有较短的中断响应时间，从而使内部的代码和实时内核的执行时间减少到最低限度。
●     具有功能很强的存储区保护功能。这是由于嵌入式系统的软件结构已经模块化，而为了避免在软件模块之间出现错误的交叉作用，需要设计强大的存储区保护功能，同时也有利于软件诊断。
●     可扩展的处理器结构，一边最迅速的开发出买组应用的高性能的嵌入式设备。
●     嵌入式微处理器必须功耗很低，尤其适用于便携式的无限级移动的计算机和通信设备中靠电池供电的嵌入式系统更是如此。
2.选择ARM处理器的准则有哪些?
答：ARM微处理器一般需要关注以下4个主要方面。
n         ARM处理器内核的选择；
n         系统的工作频率；
n         晶片内部存储体的容量；
n         晶片内部周围电路的选择。
3.嵌入式系统由哪几部份组成？
   嵌入式系统一般由硬件平台和软件平台两部分组成，其中硬件平台由嵌入式微处理器和外围硬件设备组成，而软件平台由嵌入式操作系统和应用软件组成。
4.嵌入式ARM Linux系统的一般开发步骤是什么？
答：通常基于ARM平台的嵌入式Linux开发步骤如下：
n         开发目标硬件系统；
n         建立交叉编译工具；
n         开发Bootloader；
n         开发Linux内核；
n         开发一个根文件系统；
n         开发特定硬件的驱动程序；
n         开发上层的应用程序。
5.在Makefile文件中，特殊符号$@、$*、$？、$^、$<、$()和#分别表示什么？
  $@——完整的目标文件，包括扩展名；
  $*——目标文件去掉后缀的部分；
  $^——所有的依赖文件；
  $<——比目标文件更新的依赖文件；
  $?——表示杯修改的文件；
  $()——变量引用；
#  —— 注释
学习的思考：学习就是思考的实验，不断琢磨，下定论，又自己推翻定论
6.如何理解ARM体系结构？
●     架构——采用RISC;
●     流水线操作结构——ARM7三级流水线结构，ARM9五级流水线结构，ARM10E六级流水线
●     地址空间——从V3开始，从26位变为32位地址空间;
●     指令结构——指令不断完善，如V2增加乘法指令并且支持协处理指令，V4增加半字节指令的读取和写入指令；V5增加DSP指令，JAVA指令，V6增加Media指令。两种指令集，ARM/Thumb指令。
7.ARM处理器有哪几种工作模式？
●     用户模式（usr）——ARM处理器正常的程序执行状态；
●     系统模式（sys）——运行具有特权的操作系统任务；
●     快速中断模式（fiq）——用于高速数据传输或通道处理；
●     外部中断模式（irq）——用于通用的中断处理；
●     管理模式（svc）——操作系统使用的保护模式；
●     数据访问终止模式（abt）——当数据或指令预取终止时进入该模式，可用于虚拟存储及存储保护；
●     未定义指令终止模式（und）——当未定义的指令执行时进入该模式，可用于支持硬件协处理器的软件仿真。
8.ARM处理器有哪些寄存器，如何访问？
ARM处理器共有37个32位寄存器：31个通用寄存器、6个状态寄存器，其中状态寄存器只使用了其中的12位。
状态寄存器：用于标识CPU的工作状态及程序的运行状态。
 
   用户模式与系统模式一组，使用的寄存器组和状态寄存器一样，则31个寄存器，6个状态寄存器刚好分成6组对应每种工作模式，如上图。
    在ARM状态下，任何时刻，通用寄存器R0~R14,程序计数器R15（PC）、一个或两个状态寄存器都是可以访问的。由图可以看出系统模式和用户模式可以访问16个通用寄存器，除去系统模式和用户模式的5种异常模式可以访问的是相应模式组的16个通用寄存器和状态寄存器CPSR、SPSR.
9.ARM处理器的指令集主要有哪几大类？
主要分为6大类：
●     加载/存储指令
●     数据处理指令
●     跳转指令
●     程序状态寄存器（PSR）处理指令
●     协处理器指令
●     异常产生指令
10．ARM指令有几种寻址方式？
   指令寻址的方式有7种方式：
●     立即数寻址
●     寄存器寻址
●     多寄存器寻址
●     寄存器间接寻址
●     基址变址寻址
●     相对寻址
●     堆栈寻址
 
学习的思考：坚持，时间会验证价值。
 
11.常用的BootLoader有哪些？
   BootLoader是操作系统内核运行前运行的一段小程序。这段程序可以初始化必要的硬件设备，创建内核需要的一些信息并将这些信息通过相关机制传递给内核，这样，系统硬件和软件都达到一个合适的状态，可以调用操作系统内核，作用就是引导和加载内核。常用的BootLoader有U-Boot、VIVI、ARMboot、RedBoot、Blob等
12.通常BootLoader的Stage1都实现哪些功能？
●     设置异常向量表；
●     初始化看门狗和外围电路；
●     初始化存储器；
●     初始化堆栈；
●     初始化数据区；
●     跳转到C程序的Main函数。
 
U-Boot的Stage1是start.s 汇编实现，stage2是Lib_arm/board.c C语言实现！stage2主要完成以下工作：
（1）初始化系统频率；
（2）初始化I/O端口；
（3）初始化中断处理程序表；
（4）串口初始化；
（5）其他部分的初始化；
（6）主程序循环
u-boot移植软件环境：
U-Boot源码下载http://sourceforge.net/projects/u-boot 
arm-linux-gcc ftp//:ftp.arm.kernel.org.uk
13.linux系统中，CPU对I/O端口的编址方式有哪两种？
   一、I/O映射。如X86处理器，有两个地址空间，空间分为——内存地址空间和I/O地址空间，CPU是通过专门的I/O指令来操作I/O端口。
二、内存映射。 ARM处理器有32位地址空间，只实现一个物理地址空间。所有的寄存器，I/O部件，内存都映射都这一32位地址空间。所有的操作都可以看做对内存资源的操作。
 
学习的思考：思维——剑走偏锋，为人——中庸之道。
 14.当一个异常出现以后，ARM处理器会执行哪些操作？
   异常出现，一般会执行以下4步操作：
●     保存处理器当前状态、中断屏蔽位以及各条件标志位；
●     设置当前程序状态寄存器（CPSR）中相应的位；
●     将寄存器ir_mode（当异常出现或者调用函数时保存下一条指令的位置）设置成返回地址；
●     将程序计数器（R15）值设置成该异常中断的中断向量地址，从而跳转到相应的异常中断处理程序处执行。 
15.请对设备驱动程序工作的原理做简单的描述
   用户进程利用系统调用，对/dev下的设备文件进行诸如open/close,read/write等操作时，系统调用通过设备文件的主设备号（内核启动生成的/proc/devices可以找到），找到相应的设备驱动程序，然后读取文件操作file_operations这个数据结构相应的函数指针，把控制权交给该函数。因此，编写设备驱动程序的主要工作就是编写子函数来填充file_operations。
16.字符设备驱动相关的有哪些数据结构？
  从用户进程往下看，可以知道有file、inode、和file_operations 3个结构。这3个数据结构非常重要，都被定义在include/linux/fs.h文件中。看一下他们之间的关系。
File结构标识一个打开的文件的描述符，不是仅仅给设备驱动程序用，系统中每一个打开的文件在内核中都有一个关联的struct file结构。它由内核在用户进程open时创建，并传递给在文件上操作的任何函数。File结构是具体文件在内核中的表示，file结构指向inode结构，inode和file都是file_operation中大多操作的传递参数其两个重要成员是
dev_t i_rdev
struct cdev *i_cdev
说明：内核用dev_t类型来保存设备编号，dev_t是一个32位的数，12位表示主设备号，20为表示次设备号。获取主次设备号可以用MAJOR(dev_t dev)、MINOR(dev_t dev)，将主次设备号转化为dev_t类型用MKDEV(int major,int minor) 。i_rdev包含了设备编号。Cdev是设备的抽象数据结构。
开发驱动程序首先要获取主次设备号
int register_chrdev_region(dev_t first, unsigned int count, char *name);//指定设备编号
int alloc_chrdev_region(dev_t *dev, unsigned int firstminor,unsigned int count, char *name); //动态生成设备编号
void unregister_chrdev_region(dev_t first, unsigned int count); //释放设备编号
一般主设备号给内核知道驱动程序，次设备号给驱动程序找到具体的设备。因为一个驱动可能很多个设备在用。
17.内核的短延迟函数有哪些？
   内核已经实现的延迟函数在Linux/delay.h有定义；
#include <Linux/delay.h>
void ndelay(unsigned long nsecs);
void udelay(unsigned long usecs); //软件循环延迟指定数目的微秒数
void mdelay(unsigned long msecs); //使用 udelay 做循环
这三个延迟都是忙等待函数。LDD3中还说到，实现毫秒级延迟还有另外一种方法，不涉及忙等待。文件 <linux/delay.h> 声明这些函数:

void msleep(unsigned int millisecs);
unsigned long msleep_interruptible(unsigned int millisecs);
void ssleep(unsigned int seconds)
 
