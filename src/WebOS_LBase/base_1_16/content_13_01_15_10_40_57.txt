




首页
投稿
私信
存档
RSS


情定海伦





12年06月03 
Yacc工具的使用



本节我们介绍一个著名的编译程序自动产生工具YACC（Yet Another Compiler-Compiler）。它是由S.C.Johnson等人在AT&T贝尔实验室研制开发的，早期作为UNIX操作系统中的一个实用程序。现在YACC得到广泛使用，借助于它已构造了许多编译程序。

从字面上理解，YACC是一个编译程序的编译程序，但严格说它还不是一个编译程序自动产生器，因为它不能产生完整的编译程序。YACC输入用户提供的语言的语法描述规格说明，基于LALR语法分析的原理，自动构造一个该语言的语法分析器（如图5.13所示），同时，它还能根据规格说明中给出的语义子程序建立规定的翻译。

YACC规格说明（或称YACC源程序）由说明部分、翻译规则和辅助过程三部分组成，其形式如下：

说明部分

％％

翻译规则

％％

辅助过程

下面以构造台式计算器的翻译程序为例，介绍关于YACC的规格说明。该台式计算器读一个算术表达式进行求值，然后打印其结果。设算术表达式的文法如下：

         E→E＋T | T

         T→T*F | F                                                           (5.14)

         F→(E) | digit

其中digit表示0…9的数字。根据这一文法写出YACC的规格说明如下：

% {

#include <ctype.h>

% }

token DIGIT

%%

line         :      expr‘\n’       {printf (⊃2;%d\n⊃2;, $1);}

              ;

expr        :      expr‘+’term         {$$=$1+$3;}

              |      term

term        :      term‘*’ factor   {$$=$1*$3;}

              |      factor

              ;

factor      :      ‘(’ expr ‘)’    {$$=$2;}

              |      DIGIT

              ;

%%

yylex () {

              int c;

              c=getchar ( );

              if (isditig (c)) {

                     yylval=c-‘0’;

                     return DIGIT;

                     }

                     return c;

              }

在YACC的规格说明里，说明部分包括可供选择的两部分。用%{和%}括起来的部分是C语言程序的正规说明，可以说明翻译规则和辅助过程里使用的变量和函数的类型。例中只有一个语句

# include <ctype.h>

它将导致C预处理器把包含isdigit函数说明的头文件<ctype.h>引入进来。语句

% token DIGIT

指出DIGIT是token类型的词汇，供后面两部分引用。

在第一个%%之后是翻译规则，每条规则由文法的产生式和相关的语义动作组成。形如

              左部→候选1 | 候选2 | … | 候选n |

的产生式，在YACC规格说明里写成

             左部：  候选1            {语义动作1}

                   |      候选2            {语义动作2}

                   ……

                   |      候选n            {语义动作n}

                   ；

在YACC产生式里，用单引号括起来的单个字符‘c’看成是终结符号c，没括起来并且也没被说明成token类型的字母数字串看成是非终结符号。产生式的左部非终结符之后是一个冒号，右部候选式之间可以用竖线分隔。在产生式的末尾，即其所有右部和语义动作之后，用分号表示结束。第一个产生式的左部非终结符看成是文法的开始符号。

YACC的语义动作是C语言的语句序列。在语义动作里，符号$$表示和左部非终结符相关的属性值，$1表示和产生式右部第一个文法符号（终结符或非终结符）相关的属性值，$3表示和产生式右部第三个文法符号相关的属性值。由于语义动作都放在产生式可选右部的末尾，所以，在归约时执行相关的语义动作。这样，可以在每个$i的值都求出之后再求$$的值。在上述的规格说明里，产生式   E→E＋T | T   及相关的语义动作表示为

expr        :      expr‘+’term      {$$=$1+$3;}

              |      term

              ;

表示产生式右部非终结符expr的属性值加上非终结符term的属性值，结果作为左部非终结符expr的属性值，从而规定出按照这一产生式进行求值的语义动作。我们省略了第二个产生式候选求值的语义动作；本来这一行的末尾应该设置

                         {$$=$1;}

但考虑这样原封不动进行复制的语义动作没有意义，所以省略。在YACC源程序中，我们加入了一个新的开始产生式：

          line      :      expr‘\n’{printf (⊃2;%d\n⊃2;, $1);}

表示，关于台式计算器的输入是一个算术表达式，其后用一个换行符表示输入结束；与该产生式相关的语义动作

                   {printf (⊃2;%d\n⊃2;, $1);}

打印关于非终结符expr的属性值，即表达式的结果值。

第二个％％之后是辅助过程，它由一些C语言函数组成，其中必须包含名为yylex的词法分析器。其它例程，如error错误处理例程，可根据需要加入。每次调用函数yylex ( )时，得到一个单词符号，该单词符号包括两部分，一部分是单词种别。单词种别必须在YACC源程序中第一部分说明；另一部分是单词自身值，通过YACC定义的全程变量yylval传递给语法分析器。

下面我们介绍YACC是如何处理二义文法的。

我们扩充关于台式计算器的规格说明，使之更具应用价值。第一，允许输入几个表达式，每个表达式占一行，并且允许出现空行。第二，表达式中可以出现数而不仅仅是单个数字，算术运算可以有＋，－，*，/。这样，表达式的文法可以写成下列形式：

  E→E＋E | E－E | E*E  |E/E | (E) | －E | number

按这一文法写出的YACC规格说明如下：

% {

#include <ctype.h>

#include <stdio.h>

#define YYSTYPE double      /* double type for YACC stack */

% }

token NUMBER

%left‘+’ ‘－’

%left‘*’ ‘/’

%right UMINUS

%%

lines        :      lines expr‘\n’         {printf (⊃2;%g\n⊃2;, $2);}

              |      lines‘\n’

              |      /* e */

              ;

expr        :      expr‘+’expr                  {$$=$1+$3;}

              |      expr‘－’expr                 {$$=$1-$3;}

              |      expr‘*’ expr                 {$$=$1*$3;}

              |      expr‘/’expr                          {$$=$1/$3;}

              |      ‘(’ expr‘)’                               {$$=$2;}

              |      ‘－’expr %prec UMINUS     {$$=－$2;}

              |      NUMBER

              ;

%%

yylex ( ) {

       int c;

       while ( (c=getchar ( ))==‘’);

       if ( (c==‘.’)||(isdigit (c))){

              ungetc (c,stdin);

              scanf (⊃2;%1f⊃2;,&yylval);

              return NUMBER;

       }

       return c;

}

由于上述文法具有二义性，YACC建立LALR分析表时将产生冲突的动作。在这种情况下，YACC将报告所产生的冲突动作的个数。YACC可以生成一个辅助文件，其中包含LR项目集的核心、冲突的动作和说明如何解决冲突的LALR分析表。

如果不另外指明，YACC将使用下列规则解决语法分析中的动作冲突：

1. 当产生“归约—归约”冲突时，按照规则说明中产生式的排列顺序，选择排在前边的产生式进行归约。

2. 当产生“移进—归约”冲突时，选择执行移进动作。

因为上述省缺规则不是总能满足编译器设计者的要求，因此，YACC提供了解决“移进—归约”冲突的机制。在说明部分，可以给终结符赋予优先级和结合性。在上述规格说明中

                % left‘＋’‘－’

规定＋和－具有相同的优先级和左结合性。类似地，用

                % right UMINUS

表示UMINUS（一元－）具有右结合性。此外，用% nonarsoc可以使二元运算不具有结合性。

单词符号的优先级由它们在同一说明部分中出现的次序决定，越在后，级别越高。因此，在上述规格说明中，UMINUS比它之前的五个终结符的优先级都高。

由此可见，YACC解决“移进—归约”冲突的办法是对有冲突的每个产生式以及每个终结符规定优先级和结合性。如果必须在待移的输入符号和待归约产生式A→a之间进行选择的话，则：

如果产生式的优先级比a高，或如果优先级相同且产生式的结合性为左结合，则YACC选择归约；

否则，选择移进。

通常，产生式的优先级被当作与最右边的终结符相同。这在大多数情况下是明智的。例如，给定产生式：

                       E→E＋E | E*E

当面临的符号为＋时，我们会用E→E＋E归约，因为产生式右边的＋与面临的符号＋具有相同的优先级，但具有左相合性。如果面临的符号为*，我们会选择移进，因为面临的符号*比产生式中＋的优先级高。

在有的场合下，可以用标志%prec指定其后的终结符的优先级，例如前述规格说明中产生式

                     expr      :‘－’expr

后面的标志%prec UMINUS使得该产生式中的一元－具有比其它操作符更高的优先级。
 


« 上一篇


下一篇 »

 © 2012 情定海伦. Powered by diandian.com






博客描述

消沉了一年的时间之后，我想开始新的生活
在点点记录自己以后走的每一步，持之以恒

永远不会忘记周老师的那句话："其实我是一个演员",
我也要勇敢说出：”其实我是一个开发人员“

欢迎投稿：

分享技术思考，资讯见闻，生活感悟
Share your thinking with the world.


热门标签
■linuxsystem
■code
■华为
■Desktop
■情感故事
■zsh
■compiler
■system structure
■WindowsXP::cdkey


博客成员
■情定海伦



 
