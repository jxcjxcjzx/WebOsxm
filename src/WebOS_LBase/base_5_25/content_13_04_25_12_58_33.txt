



争气
 
静心方能尽力...

 
首页
 博问
 闪存
 
联系
 订阅 
管理
 
随笔-26  文章-0  评论-39  






华为机试第五篇




备注，本人博客上与找工作有关的文章的doc以及答案均已上传至本人网络硬盘，并持续更新，需要共享的点这里，给我留言【留言形式为你的邮箱】
 
1:选秀节目打分，分为专家评委和大众评委，score[]数组里面存储每个评委打的分数，judge_type[]里存储与score[]数组对应的评委类别，judge_type[i] == 1，表示专家评委，judge_type[i] == 2，表示大众评委，n表示评委总数。打分规则如下：专家评委和大众评委的分数分别取一个平均分（平均分取整），然后，总分 = 专家分*0.6 + 大众评委*0.4，总分取整。如果没有大众评委，则总分 = 专家评委平均分，总分取整。函数最终返回选手得分。函数接口：int cal_score(int score[],int judge_type[],int n)
 



?




1

2

3

4

5

6

7

8

9

10 



//judge_type里面存储的是评委类型，只能有两种，此题很简单，不做解释

//力求代码最简

int cal_score(int score[],int judge_type[],int n)

{

    int sumExpert=0,sumE=0,sumNormal=0,sumN=0;

    for(int i=0;i<n;i++){

        judge_type[i]==1?(sumExpert+=score[i],++sumE):(sumNormal+=score[i],++sumN);

    }

    return !sumNormal?sumExpert/sumE:(sumExpert/sumE*0.6+sumNormal/sumN*0.4);

} 


　　
 
2、给定一个数组input[] ，如果数组长度n为奇数，则将数组中最大的元素放到 output[] 数组最中间的位置，如果数组长度n为偶 
数，则将数组中最大的元素放到 output[] 数组中间两个位置偏右的那个位置上，然后再按从大到小的顺序，依次在第一个位置的 
两边，按照一左一右的顺序，依次存放剩下的数。
例如：
input[] = {3, 6, 1, 9, 7} 
output[] = {3, 7, 9, 6, 1}; 
input[] = {3, 6, 1, 9, 7, 8} 
output[] = {1, 6, 8, 9, 7, 3}
函数接口如下:
Void sort(int input[],int n, int output[]);
 



?




1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23 



//此题就是进行排序，基本算法~~~

void sort(int input[],int n, int output[])

{

    bool flag=false;//标志左右操作

    int left=1,right=0;

    for(int i=0;i<n;i++)//对input数据进行一次冒泡排序

    {

        for(int j=0;j<n-i-1;j++)

        {

            if(input[j]>input[j+1])

            {

                input[j]=input[j]^input[j+1];

                input[j+1]=input[j]^input[j+1];

                input[j]=input[j]^input[j+1];

            }

        }

        if(flag&&(n/2-left)>=0)

            output[n/2-(left++)]=input[n-i-1];

        else if(!flag&&(n/2+right)<n)

            output[n/2+(right++)]=input[n-i-1];

        flag=!flag;

    }    

} 


　　
 
3、操作系统任务调度问题。操作系统任务分为系统任务和用户任务两种。其中，系统任务的优先级 <50，用户任务的优先级>= 50且 <= 255。优先级大于255的为非法任务，应予以剔除。现有一任务队列task[]，长度为n，task中的元素值表示任务的优先级，数值越小，优先级越高。函数scheduler实现如下功能，将task[] 中的任务按照系统任务、用户任务依次存放到 system_task[] 数组和 user_task[] 数组中（数组中元素的值是任务在task[] 数组中的下标），并且优先级高的任务排在前面，数组元素为-1表示结束。 
例如：
task[] = {0,30,155,1,80,300,170,40,99} 
system_task[] = {0, 3, 1, 7, -1} 
user_task[] = {4, 8, 2, 6, -1}
函数接口 void scheduler(int task[], int n, int system_task[], int user_task[])
 



?




1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18 



void scheduler(int task[], int n, int system_task[], int user_task[])

{ 

    int tmpS=0,tmpU=0;

    for(int i=0;i<n;i++)//此方法效率不高，不想想了~~~

    {

        int tmp=-1;

        if(task[i]>255||task[i]<0)

            continue;//非法任务，跳过

        for(int j=0;j<n;j++)

            //求考虎优先级相等的情况，>=可以用来处理，但不稳定~~~~~~

            //就写到这了~~

            if(task[i]<50&&task[i]>=task[j])

                ++tmp;

            else if(task[i]>=50&&task[j]>=50&&task[i]>=task[j])

                ++tmp;

            task[i]<50?(++tmpS,system_task[tmp]=i):(++tmpU,user_task[tmp]=i);//有点懒了，不想写长了

    }

} 


 

 



分类: 找工作--华为篇
 

绿色通道： 好文要顶 关注我 收藏该文与我联系 




星空雾雨
 关注 - 1
 粉丝 - 39 



+加关注 


0

0


 (请您对文章做出评价) 


« 博主上一篇：Linux驱动程序第二篇
» 博主下一篇：Linux驱动编程第三篇

 
posted @ 2012-11-13 20:07 星空雾雨 阅读(99) 评论(0) 编辑 收藏
 



刷新评论刷新页面返回顶部
 

注册用户登录后才能发表评论，请 登录 或 注册，访问网站首页。

找优秀程序员，就在博客园

 
博客园首页博问新闻闪存程序员招聘知识库
 





最新IT新闻:
 · 英活动家呼吁政府颁布杀手机器人研发禁令
 · 能看漫画的日本智能眼镜 要抢在谷歌前面上市！
 · 787客机即将重返蓝天 波音交出漂亮财报
 · 复盘互联网巨头打通寻人平台过程：大灾面前泯恩仇
 · 江民发生人事动荡：多名创业元老离职
» 更多新闻...

最新知识库文章:

 · 谈谈对BPM的理解
 · 遗留系统的技术栈迁移
 · 架构 － 业务流程管理介绍（BPM）
 · 中文女和程序员的爱情奇遇
 · HTTP负载测试

» 更多知识库文章... 







公告


昵称：星空雾雨
园龄：1年1个月
粉丝：39
关注：1
+加关注
 





随笔分类(26)
AndRoid 
C/C++(3) 
JAVA(1) 
Visaul C++ 
Wince程序以及感悟(2) 
嵌入式编程与开发(8) 
软件设计模式(1) 
数据结构与算法 
找工作--谷歌篇(1) 
找工作--华为篇(6) 
找工作--混杂篇(1) 
找工作--中兴篇(3) 


积分与排名
 积分 - 15933 
排名 - 7736 


阅读排行榜

1. 华为机试第一篇(3417)
2. 谷歌笔试第一篇(2480)
3. 华为机试第三篇(1957)
4. Linux源码printf函数实现(1711)
5. 华为机试第四篇(1601)
6. 将Ubuntu打包成实时操作系统(RTAI)(1432)
7. WinCE下的计算器实现源码(1116)
8. Linux驱动程序第二篇(1049)
9. Linux源码之进程终止函数(920)
10. Linux驱动编程第三篇(837)
11. getchar的缓存机制(789)
12. 华为机试第二篇(729)
13. assert的源码分析以及用法(677)
14. 设计模式总结(646)
15. 华为机试第六篇(320)
16. SD卡烧写WinCE启动过程解析(298)
17. Linux驱动编程第四篇(268)
18. Linux源码之sleep_on【不可中断休眠】(229)
19. 小米网站批量修改密码软件(172)
20. 笔试杂汇(137)
21. Linux驱动程序第一篇【笔记】(127)
22. 华为机试第五篇(99)
23. 中兴Java面试汇总三(33)
24. 中兴Java面试汇总一(25)
25. 中兴Java面试汇总二(23)
26. 操作符重载(19)
 

评论排行榜

1. 华为机试第三篇(13)
2. 华为机试第四篇(11)
3. getchar的缓存机制(8)
4. 华为机试第六篇(1)
5. 设计模式总结(1)
6. 谷歌笔试第一篇(1)
7. 笔试杂汇(1)
8. 小米网站批量修改密码软件(1)
9. 华为机试第一篇(1)
10. Linux源码之进程终止函数(0)
11. Linux源码之sleep_on【不可中断休眠】(0)
12. Linux驱动编程第三篇(0)
13. 华为机试第五篇(0)
14. Linux驱动程序第二篇(0)
15. Linux驱动程序第一篇【笔记】(0)
16. 将Ubuntu打包成实时操作系统(RTAI)(0)
17. SD卡烧写WinCE启动过程解析(0)
18. assert的源码分析以及用法(0)
19. Linux源码printf函数实现(0)
20. 华为机试第二篇(0)
21. 中兴Java面试汇总三(0)
22. 中兴Java面试汇总二(0)
23. 中兴Java面试汇总一(0)
24. 操作符重载(0)
25. WinCE下的计算器实现源码(0)
26. Linux驱动编程第四篇(0)
 

推荐排行榜
 
1. 华为机试第六篇(6)
2. 华为机试第一篇(4)
3. 华为机试第三篇(4)
4. 华为机试第四篇(2)
5. assert的源码分析以及用法(2)
6. 谷歌笔试第一篇(1)
7. Linux驱动编程第三篇(1)
8. Linux驱动程序第二篇(1)
9. Linux源码printf函数实现(1)
10. 华为机试第二篇(1)
11. getchar的缓存机制(1)
12. Linux驱动编程第四篇(1)
13. 设计模式总结(1)
14. WinCE下的计算器实现源码(1)
 


Copyright ©2013 星空雾雨 

