
您还未登录！|登录|注册|帮助
 首页
 业界
 移动
 云计算
 研发
 论坛
 博客
 下载
 
更多
 







结构之法 算法之道

Google或baidu搜索：“结构之法”，进入本博客


 


目录视图
摘要视图
订阅
 . 



【免费有礼】欧美最新网络营销技巧分享        博客导入工具      【限时优惠】第五届云计算大会社区门票抢购 
探究云计算数据中心节能增效之道      专访邓凡平：Android开发路上的快速学习之道      CSDN博客第二期最佳移动开发博主评选 



程序员编程艺术：第六章、求解500万以内的亲和数 
.
 分类： 11.TAOPP（编程艺术）20.number operations2011-05-24 02:5615188人阅读评论(116)收藏举报
 
编程数据结构算法面试classblog

 
                      第六章、亲和数问题--求解500万以内的亲和数
 

作者：上善若水、July、yansha。
出处：http://blog.csdn.net/v_JULY_v 。
 

前奏
    本章陆续开始，除了继续保持原有的字符串、数组等面试题之外，会有意识的间断性节选一些有关数字趣味小而巧的面试题目，重在突出思路的“巧”，和“妙”。本章亲和数问题之关键字，“500万”，“线性复杂度”。
 
 
 
第一节、亲和数问题
题目描述：
求500万以内的所有亲和数
如果两个数a和b，a的所有真因数之和等于b,b的所有真因数之和等于a,则称a,b是一对亲和数。
例如220和284，1184和1210，2620和2924。
 
分析：
    首先得明确到底是什么是亲和数?
 
亲和数问题最早是由毕达哥拉斯学派发现和研究的。他们在研究数字的规律的时候发现有以下性质特点的两个数：
220的真因子是：1、2、4、5、10、11、20、22、44、55、110；
284的真因子是：1、2、4、71、142。
而这两个数恰恰等于对方的真因子各自加起来的和（sum[i]表示数i 的各个真因子的和），即
220=1+2+4+71+142=sum[284],
284=1+2+4+5+10+11+20+22+44+55+110=sum[220]。
得284的真因子之和sum[284]=220，且220的真因子之和sum[220]=284，即有sum[220]=sum[sum[284]]=284。
 
如此，是否已看出丝毫端倪?
 
如上所示，考虑到1是每个整数的因子，把出去整数本身之外的所有因子叫做这个数的“真因子”。如果两个整数，其中每一个真因子的和都恰好等于另一个数，那么这两个数，就构成一对“亲和数”（有关亲和数的更多讨论，可参考这：http://t.cn/hesH09）。
 
 
 
求解：
    了解了什么是亲和数，接下来咱们一步一步来解决上面提出的问题（以下内容大部引自水的原话，同时水哥有一句原话，“在你真正弄弄懂这个范例之前，你不配说你懂数据结构和算法”）。
 1.看到这个问题后，第一想法是什么？模拟搜索+剪枝？回溯？时间复杂度有多大？其中bn为an的伪亲和数，即bn是an的真因数之和大约是多少？至少是10^13（@iicup：N^1.5 对于5*10^6 , 次数大致 10^10 而不是 10^13.）的数量级的。那么对于每秒千万次运算的计算机来说，大概在1000多天也就是3年内就可以搞定了（iicup的计算: 10^13 / 10^7 =1000000(秒) 大约 278 小时. ）。如果是基于这个基数在优化，你无法在一天内得到结果的。
 2.一个不错的算法应该在半小时之内搞定这个问题，当然这样的算法有很多。节约时间的做法是可以生成伴随数组，也就是空间换时间，但是那样，空间代价太大，因为数据规模庞大。
 3.在稍后的算法中，依然使用的伴随数组，只不过，因为题目的特殊性，只是它方便和巧妙地利用了下标作为伴随数组，来节约时间。同时，将回溯的思想换成递推的思想（预处理数组的时间复杂度为logN（调和级数）*N，扫描数组的时间复杂度为线性O（N）。所以，总的时间复杂度为O（N*logN+N）（其中logN为调和级数）  ）。
 

第二节、伴随数组线性遍历
依据上文中的第3点思路，编写如下代码：
 




01.//求解亲和数问题  
02.  
03.//第一个for和第二个for循环是logn（调和级数）*N次遍历,第三个for循环扫描O（N）。  
04.//所以总的时间复杂度为 O（n*logn）+O（n）=O（N*logN）（其中logN为调和级数）。  
05.  
06.//关于第一个for和第二个for寻找中，调和级数的说明：  
07.//比如给2的倍数加2，那么应该是  n/2次，3的倍数加3 应该是 n/3次，...  
08.//那么其实就是n*（1+1/2+1/3+1/4+...1/(n/2)）=n*（调和级数）=n*logn。  
09.  
10.//copyright@ 上善若水  
11.//July、updated，2011.05.24。  
12.#include<stdio.h>  
13.  
14.int sum[5000010];   //为防越界  
15.  
16.int main()   
17.{  
18.    int i, j;  
19.    for (i = 0; i <= 5000000; i++)   
20.        sum[i] = 1;  //1是所有数的真因数所以全部置1  
21.      
22.    for (i = 2; i + i <= 5000000; i++)  //预处理，预处理是logN（调和级数）*N。  
23.        //@litaoye：调和级数1/2 + 1/3 + 1/4......的和近似为ln(n)，  
24.        //因此O(n *(1/2 + 1/3 + 1/4......)) = O(n * ln(n)) = O(N*log(N))。  
25.    {    
26.        //5000000以下最大的真因数是不超过它的一半的  
27.        j = i + i;  //因为真因数，所以不能算本身，所以从它的2倍开始  
28.        while (j <= 5000000)   
29.        {    
30.            //将所有i的倍数的位置上加i  
31.            sum[j] += i;    
32.            j += i;       
33.        }  
34.    }  
35.      
36.    for (i = 220; i <= 5000000; i++)   //扫描，O（N）。  
37.    {  
38.        // 一次遍历，因为知道最小是220和284因此从220开始  
39.        if (sum[i] > i && sum[i] <= 5000000 && sum[sum[i]] == i)  
40.        {  
41.            //去重，不越界，满足亲和  
42.            printf("%d %d/n",i,sum[i]);  
43.        }  
44.    }  
45.    return 0;  
46.}  
 

运行结果：
 



    @上善若水：
 
    1、可能大家理解的还不是很清晰，我们建立一个5 000 000 的数组，从1到2 500 000 开始，在每一个下标是i的倍数的位置上加上i，那么在循环结束之后，我们得到的是什么？是 类似埃斯托拉晒求素数的数组（当然里面有真的亲和数），然后只需要一次遍历就可以轻松找到所有的亲和数了。时间复杂度，线性。
 
    2、我们可以清晰的发现连续数据的映射可以通过数组结构本身的特点替代，用来节约空间，这是数据结构的艺术。在大规模连续数据的回溯处理上，可以通过转化为递推生成的方法，逆向思维操作，这是算法的艺术。
 
    3、把最简单的东西运用的最巧妙的人，要比用复杂方法解决复杂问题的人要头脑清晰。
 

第三节、程序的构造与解释
    我再来具体解释下上述程序的原理，ok，举个例子，假设是求10以内的亲和数，求解步骤如下：
 
因为所有数的真因数都包含1，所以，先在各个数的下方全部置1
 1.然后取i=2,3,4,5（i<=10/2），j依次对应的位置为j=（4、6、8、10），（6、9）,（8）,（10）各数所对应的位置。
 2.依据j所找到的位置，在j所指的各个数的下面加上各个真因子i（i=2、3、4、5）。
整个过程，即如下图所示（如sum[6]=1+2+3=6，sum[10]=1+2+5=8.）：
1  2  3  4  5  6  7  8  9  10
1  1  1  1  1  1  1  1  1  1
           2      2      2      2
                   3          3 
                           4
                                   5
 3.然后一次遍历i从220开始到5000000，i每遍历一个数后，
将i对应的数下面的各个真因子加起来得到一个和sum[i]，如果这个和sum[i]==某个i’，且sum[i‘]=i，
那么这两个数i和i’，即为一对亲和数。
 4.i=2；sum[4]+=2，sum[6]+=2，sum[8]+=2，sum[10]+=2，sum[12]+=2...
i=3，sum[6]+=3，sum[9]+=3...
......
 5.i=220时，sum[220]=284，i=284时，sum[284]=220；即sum[220]=sum[sum[284]]=284，
得出220与284是一对亲和数。所以，最终输出220、284，...
 
特别鸣谢
 
      litaoye专门为本亲和数问题开帖子继续阐述，有兴趣的朋友可继续参见：http://topic.csdn.net/u/20110526/21/129c2235-1f44-42e9-a55f-878920c21e19.html。同时，任何人对本亲和数问题有任何问题，也可以回复到上述帖子上。
 





01.//求解亲和数问题  
02.//copyright@ litaoye  
03.//July、胡滨，updated，2011.05.26。  
04.using System;  
05.using System.Collections.Generic;  
06.  
07.namespace CSharpTest  
08.{  
09.    class Program  
10.    {  
11.        public static void Main()  
12.        {  
13.            int max = 5000000;  
14.            DateTime start = DateTime.Now;  
15.            int[] counter = CreateCounter(max);  
16.              
17.            for (int i = 0; i < counter.Length; i++)  
18.            {  
19.                int num = counter[i] - i;  
20.                //if (num < counter.Length && num > i && counter[num] == counter[i])  
21.                // Console.WriteLine("{0} {1}", i, num);  
22.            }  
23.            Console.WriteLine((DateTime.Now - start).TotalSeconds);  
24.              
25.            Console.ReadKey();  
26.        }  
27.          
28.        static int[] CreateCounter(int n)  
29.        {  
30.            List<int> primes = new List<int>();  
31.            int[] counter = new int[n + 1];  
32.            counter[1] = 1;  
33.              
34.            for (int i = 2; i <= n; i++)  
35.            {  
36.                if (counter[i] == 0)  
37.                {  
38.                    counter[i] = i + 1;  
39.                    primes.Add(i);  
40.                }  
41.                  
42.                for (int j = 0; j < primes.Count; j++)  
43.                {  
44.                    if (primes[j] * i > n)   
45.                        break;  
46.                      
47.                    if (i % primes[j] == 0)  
48.                    {  
49.                        int k = i;  
50.                        int l = primes[j] * primes[j];  
51.                          
52.                        while (k % primes[j] == 0)  
53.                        {  
54.                            l *= primes[j];  
55.                            k /= primes[j];  
56.                        }  
57.                          
58.                        counter[primes[j] * i] = counter[k] * (l - 1) / (primes[j] - 1);  
59.                        break;  
60.                    }  
61.                    else  
62.                        counter[primes[j] * i] = counter[i] * (primes[j] + 1);  
63.                }  
64.            }  
65.              
66.            return counter;  
67.        }  
68.    }  
69.}  
70.  
71./* 
72.测试结果： 
73.0.484375   
74.0.484375 
75.0.46875 
76.单位second。 
77.*/  
 

本章完。
 3.3续、求给定区间内的第K小（大）元素 第九章、闲话链表追赶问题 第十章、如何给10^7个数据量的磁盘文件排序 
面试题征集令
 1.十三个经典算法研究系列+附、红黑树系列（国内有史以来最为经典的红黑树教程），共计20+6=26篇文章，带目录+标签的PDF文档，耗时近一个星期，足足346页（够一本书的分量了），已在花明月暗的帮助下，正式制作完成。
 2.想要的，发一道你自认为较好的面试题（c，c++，数据结构，算法，智力题，数字逻辑或运算题）至我的邮箱：zhoulei0907@yahoo.cn，即可。我收到后，三天之内传送此PDF文件。July、20110.5.24.此声明永久有效。
 


--------------------------------------------------------------------------------


 
 
版权所有，本人对本blog内所有任何内容享有版权及著作权。实要转载，请以链接形式注明出处。
 
分享到： 

上一篇：十四、第三章再续：快速选择SELECT算法的深入分析与实现
下一篇：程序员编程艺术：第七章、求连续子数组的最大和
 . 


查看评论
 
73楼 LQ731371663 2012-07-16 18:32发表[回复] 偶然看到这篇文章，YM一下LZ，竟然写了那么多的算法的东西。 “ //5000000以下最大的真因数是不超过它的一半的”，其实这里可以优化吧， 最大的真因数是不超过它开方数(sqrt(n))Re: wj120943839 2013-03-28 10:04发表[回复] 回复LQ731371663：16 的真因数2 4 8，72楼 registcn 2012-04-30 18:12发表[回复] 楼主啊，“至少是10^13（@iicup：N^1.5 对于5*10^6 , 次数大致 10^10 而不是 10^13.）的数量级的。那么对于每秒千万次运算的计算机来说，大概在1000多天也就是3年内就可以搞定了（iicup的计算: 10^13 / 10^7 =1000000(秒) 大约 278 小时. ）”怎么得到的？或者有群吗？我去里面问问呢71楼 oyaking 2012-03-11 22:21发表[回复] 收藏了70楼 eyualuo 2011-11-12 14:46发表[回复] 220=1+2+4+71+142=sum[284],
284=1+2+4+5+10+11+20+22+44+55+110=sum[220]。
写反了Re: xiaowaiwaia 2012-05-11 09:45发表[回复] 没反你再仔细看看吧69楼 C_bird_ 2011-06-21 16:47发表[回复] [e01]68楼 pupingpp 2011-06-19 22:05发表[回复] [e01]67楼 coolcodetan 2011-06-12 14:49发表[回复] 写的漂亮。66楼 ao929929fei 2011-06-08 16:28发表[回复] 文章的思路比较清晰，看一两遍就明白了[e01]
算法稍微改一下就是列出1至Num中的所有质数65楼 amblue 2011-06-05 21:49发表[回复] int sum[5,000,000] !
20M的栈空间，太奢侈了Re: hahaha 2011-06-07 22:42发表[回复] 回复 amblue：可以在堆上申请。其实20m在堆上不算啥。一些图像处理的程序，读个几千万像素的图片就要几百M呢Re: v_JULY_v 2011-06-05 21:54发表[回复] 回复 amblue：恩，为了凸显算法的思想，细节未有严格考究。日后注意。Re: haoni123321 2011-12-20 14:28发表[回复] 回复v_JULY_v：那个如果刚开始那样写的话，是通不过，只能在堆上申请才可以运行。64楼 denghui0815 2011-06-03 21:11发表[回复] 亲和数：
一个自然数的各约数之和与该数本身的比率，即 R(n)。如果两个不相同的自然数的比率相等，那么这样的数称为一对“亲和数”（friendly numbers）。Re: v_JULY_v 2011-06-05 17:54发表[回复] 回复 denghui0815：[e03]63楼 denghui0815 2011-06-03 21:10发表[回复] 相亲数：
对于一对不相同的整数，如果其中一个整数的正约数（proper divisors）之和等于第二个整数，且反之亦然，那么这对整数便可称之为一对“相亲数”（amicable numbers）。62楼 burellow 2011-06-02 09:25发表[回复] [e01]
美妙！
有个小的建议：
#define SIZE 5000000
或者
const int SIZE = 5000000;
用SIZE来代替重复出现的5000000。Re: v_JULY_v 2011-06-05 17:54发表[回复] 回复 burellow：非常不错的建议，以后勘误修改时定采纳，谢谢你，[e10]61楼 crazypig23 2011-05-30 23:11发表[回复] [e01][e03]60楼 fjksdafj 2011-05-30 10:53发表[回复] [e01]59楼 wanghongbiaohao 2011-05-30 10:42发表[回复] 这篇文章不错啊，很实用，学习一下！Re: v_JULY_v 2011-06-05 17:54发表[回复] 回复 wanghongbiaohao：[e10]58楼 cwm5511 2011-05-30 06:55发表[回复] 谢谢分享，学习了！！！57楼 cslxw 2011-05-29 22:26发表[回复] 很好，学习了[e03]56楼 liuzhengxi2010 2011-05-29 16:27发表[回复] 真是好巧妙啊！！！！55楼 xxoodws 2011-05-29 10:46发表[回复] [e01][e01]学习了 楼主V5啊 [e01][e01]54楼 tengkai 2011-05-29 09:44发表[回复] [e06]不太懂呀！！！！努力呀53楼 v_JULY_v 2011-05-28 00:07发表[回复] 调和级数，n(1/2+1/3+...+1/n),等于n[ log(n+1)+r],r是欧拉常数，约等于0.57。52楼 冯河 2011-05-28 00:03发表[回复] [e01]51楼 ming1234hua 2011-05-27 15:22发表[回复] 好LZ有功力。[e01]50楼 woaiwofengkuang 2011-05-27 12:05发表[回复] 哎看了这个才知道，偶的数学真不怎么地呀。49楼 v_JULY_v 2011-05-27 10:12发表[回复] 对本文，水哥有一句原话，“在你真正弄弄懂这个范例之前，你不配说你懂数据结构和算法”。48楼 qyfanghui 2011-05-26 23:09发表[回复] [e01]47楼 iicup 2011-05-26 23:04发表[回复] 计算因子,时间sqrt(N),
每个数计算: N^1.5
对于5*10^6 , 次数大致 10^10 而不是 10^13.Re: v_JULY_v 2011-05-26 23:09发表[回复] 回复 iicup：[e10]，谢谢指正46楼 iicup 2011-05-26 23:00发表[回复] 至少是10^13的数量级的。那么对于每秒千万次运算的计算机来说，大概在1000多天也就是3年内就可以搞定了。

我的计算:
10^13 / 10^7 =1000000(秒)
大约 278 小时.Re: v_JULY_v 2011-05-26 23:09发表[回复] 回复 iicup：[e03]45楼 luwangjun1227 2011-05-26 22:53发表[回复] [e01]44楼 caixialian999 2011-05-26 22:20发表[回复] 为什么可以定义那么大的数组呢？求解释。谢谢！[e08]43楼 v_JULY_v 2011-05-26 21:50发表[回复] litaoye 的帖子已经贴到了本文文末部分，有兴趣的可以点击查看。42楼 WinmanL 2011-05-26 21:28发表[回复] [e01]厉害啊41楼 v_JULY_v 2011-05-26 17:00发表[回复] 任何读者有任何问题，也可以直接发送到我的第二个邮箱，786165179@qq.com。40楼 qiuxiang2007 2011-05-26 16:33发表[回复] 刚刚仔细看了看，你怎么知道i=220是5百万的第一亲和数,这个也应该由算法计算出来吧。Re: v_JULY_v 2011-05-26 16:59发表[回复] 回复 qiuxiang2007：貌似，的确该这样，[e03]39楼 bxyill 2011-05-26 15:17发表[回复] [e01]38楼 v_JULY_v 2011-05-26 08:46发表[回复] 33?...37楼 adeljan 2011-05-26 04:04发表[回复] [e04][e04][e04][e04]36楼 adeljan 2011-05-26 04:04发表[回复] 3335楼 adeljan 2011-05-26 04:04发表[回复] 33334楼 adeljan 2011-05-26 04:04发表[回复] [e05][e04][e05]33楼 eltonlong 2011-05-26 01:49发表[回复] 非常有用 ，而且非常清晰！感叹楼主的功力！[e03]32楼 johnharvard_hust 2011-05-25 17:40发表[回复] 给博主一个建议：像for循环里面的i+i，我觉得直接用移位操作比较好，虽然意义不大，但是当i逐渐增大以后加法操作的开销大于移位操作的开销Re: v_JULY_v 2011-05-25 20:20发表[回复] 回复 johnharvard_hust：恩，非常不错的建议，采纳，晚点修正过来，谢谢，[e10]31楼 断无忌 2011-05-25 15:12发表[回复] 这个CSDN的评论屏蔽回车，还真是麻烦[e08]30楼 断无忌 2011-05-25 15:10发表[回复] 如上所示，考虑到1是每个整数的因子，把出去整数本身之外的所有因子叫做这个数


“出去”打错了，改一下吧。“除去”。

另外那个代码中的时间复杂度是O（N*LogN）有点迷糊啊，让我好好消化一下~许久没关注复杂度了，现在来考量复杂度还真是难以调整过来呢……Re: v_JULY_v 2011-05-25 20:22发表[回复] 回复 xovel：[e10]Re: 断无忌 2011-05-26 13:54发表[回复] 回复 v_JULY_v：貌似木有改哈[e08]29楼 sjzzy 2011-05-25 13:38发表[回复] 主要是算法上的意义吧28楼 dfasri 2011-05-25 09:38发表[回复] 我想知道亲和数, 在什么领域有实际应用价值?27楼 liyanjing1987 2011-05-25 09:37发表[回复] 不错26楼 litaoye 2011-05-24 22:23发表[回复] ：设n = p1^a1 * p2^a2 * .... pn^an(p1-pn为因数分解，a1-an为幂)，则n的亲和数 = (p1^(a1+1) - 1) * (p2^(a2+1) - 1) * .... (pn^(an+1) - 1)/(p1-1)(p2-1).......(pn-1)25楼 A583577906 2011-05-24 20:28发表[回复] sum[6]=1+2+3=6 这个应该算什么??Re: v_JULY_v 2011-05-24 20:35发表[回复] 回复 A583577906：完全数。24楼 wentao308 2011-05-24 19:25发表[回复] 为什么可以从i = 220 开始，前面直接排除呢？Re: v_JULY_v 2011-05-24 19:41发表[回复] 回复 wentao308：这是事先计算得到的已知的结果，23楼 adam_tang 2011-05-24 17:16发表[回复] 短而精炼，好文章[e03]22楼 v_JULY_v 2011-05-24 15:18发表[回复] 文章，已经全面更新。21楼 JsonGood 2011-05-24 15:13发表[回复] [e03]20楼 v_JULY_v 2011-05-24 14:43发表[回复] 狂想曲第六章刚发现一个严重的bug，即文中所给的程序不是线性复杂度。幸亏经多位读者指出，所谓群众的眼睛是雪亮的。还带进一步验证。19楼 myhope88 2011-05-24 14:29发表[回复] [e03]18楼 litaoye 2011-05-24 14:11发表[回复] 回复 v_JULY_v：应该不是线性的，应该是n*log(n)的。跟质数筛法是一样的，不过这个题有线性的方法，也许还有低于线性的构造法，lz可以继续想一想Re: gbb21 2011-05-25 03:29发表[回复] 回复 litaoye：[e03]我一直在等你来说这个事～[e10][e10]Re: v_JULY_v 2011-05-25 08:09发表[回复] 回复 gbb21：貌似，你是他的粉丝阿...[e04]Re: gbb21 2011-05-25 08:45发表[回复] 回复 v_JULY_v：
老人中我心中的CSDN 三大牛人:
FancyMouse: God of Math &amp; Algo
Bihacker: God of Prgl &amp; Algo
litaoye: God of Algo &amp; Math
不过长江后浪推前浪，像你们虽是小辈，但也绝不可小觑~Re: litaoye 2011-05-25 21:40发表[回复] 回复 gbb21：哎呀，咱可不算牛人，（FM和飞雪）都比我强多了，另外还有像math和mysword这样的大牛，虽然不常来，偶尔惊鸿一瞥还是很强的Re: 天下第一好大人 2011-05-26 12:13发表[回复] 回复 litaoye：你怎么不说线性构造法啊？望眼欲穿了都！[e07]Re: litaoye 2011-05-26 13:33发表[回复] 回复 gogdizzy：后面写了，可是发不上来，每次长度不能超过150个字Re: v_JULY_v 2011-05-26 16:58发表[回复] 回复 litaoye：加入狂想曲wiki中，编辑到这里面去吧，http://tctop.wikispaces.com/。或者直接通过qq发给我，我更新到文章中去。Re: 天下第一好大人 2011-05-26 16:53发表[回复] 回复 litaoye：额，那大致说一下思路？Re: litaoye 2011-05-26 21:20发表[回复] 回复 gogdizzy：在算法版发了个帖子，大概思路就是修改一下质数线性筛法就可以了Re: gbb21 2011-05-26 02:39发表[回复] 回复 litaoye：不常来的人就不知道了，但是相信前辈还是肯定有很多的～ 你虽然可能理论没他们扎实，但是实践还是很强的 ～[e03]Re: v_JULY_v 2011-05-25 09:24发表[回复] 回复 gbb21：是的，不少问题的确需要某些读者的提醒，与修正。Re: v_JULY_v 2011-05-24 14:28发表[回复] 回复 litaoye：?是否详细说明下?..Re: litaoye 2011-05-24 14:32发表[回复] 回复 v_JULY_v：调和级数1/2 + 1/3 + 1/4......的和近似为ln(n)，因此O(n *(1/2 + 1/3 + 1/4......)) = O(n * ln(n)) = O(n*log(N))Re: v_JULY_v 2011-05-24 14:33发表[回复] 回复 litaoye：那这题线性的方法列?或者低于线性的构造法列?Re: hjxhjh 2011-05-24 14:19发表[回复] 回复 litaoye：是个调和级数的一般部分乘以N是吧？O（N（1/2+1/3+1/4+1/5+.......+1/(N/2)））?不清楚这个和式如何化简。Re: v_JULY_v 2011-05-24 16:06发表[回复] 回复 hjxhjh：文章，已更新。Re: hjxhjh 2011-05-24 18:46发表[回复] 回复 v_JULY_v：[e03]17楼 beyondcom 2011-05-24 12:54发表[回复] 第二个for循环复杂度是否O(nlogn)?Re: v_JULY_v 2011-05-24 14:36发表[回复] 回复 beyondcom：偶貌似说错了，请看文章更新。Re: v_JULY_v 2011-05-24 14:17发表[回复] 回复 beyondcom：O（N^2）是 预处理部分，加上 第三个 for循环的线性遍历，所以总的时间复杂度为 O（n^2）+O（n）。你是对的，[e10]Re: v_JULY_v 2011-05-24 13:12发表[回复] 回复 beyondcom：不是的，线性O（N）。16楼 tianqing568 2011-05-24 11:47发表[回复] [e01]不错，真是不错。学习了15楼 appleheno 2011-05-24 11:41发表[回复] 像是0(n^2)14楼 appleheno 2011-05-24 11:35发表[回复] 算法不错。不过，在计算真因子数之各的时候，复杂度是多少呢？
n/2+n/3+...+1=n(1/2+1/3+...+1/n),这个好像是无穷大啊13楼 aimin2049 2011-05-24 11:09发表[回复] [e01]12楼 hjxhjh 2011-05-24 11:05发表[回复] [e01]，短文章不错~~赞，楼主~~
下次早点来顶~~11楼 lbw888 2011-05-24 10:51发表[回复] 【重在思路的“巧”，和“秒”】，应该改成：【重在思路的“巧”，和“妙”】[e10]Re: v_JULY_v 2011-05-24 11:07发表[回复] 回复 lbw888：[e03]，是的，立马修改10楼 christine_lin 2011-05-24 10:39发表[回复] [e01][e01][e01] 这篇短，上班时间偷偷看~~9楼 十一文 2011-05-24 10:09发表[回复] 前排占位[e01]Re: v_JULY_v 2011-05-24 10:12发表[回复] 回复 xming4321：哈，后排了列8楼 ruanjian1986 2011-05-24 10:01发表[回复] 文章又短又清晰，赞lz的功力。Re: v_JULY_v 2011-05-24 10:03发表[回复] 回复 ruanjian1986：谢谢，你是群内的朋友么?Re: ruanjian1986 2011-05-24 10:08发表[回复] 回复 v_JULY_v：不是，不过一直在关注Re: v_JULY_v 2011-05-24 10:11发表[回复] 回复 ruanjian1986：en，欢迎你加入：http://tctop.wikispaces.com/。7楼 ruanjian1986 2011-05-24 09:56发表[回复] lz对每个数的真因子之和的求解太巧妙了。6楼 v_JULY_v 2011-05-24 09:54发表[回复] 如果各位阅读本章，没有看懂时，一定要指出来告诉我，我好修改完善。毕竟，此文不完全是我原创的。5楼 liubing_2010 2011-05-24 09:43发表[回复] [e03]4楼 ruanjian1986 2011-05-24 09:35发表[回复] 昨天刚看到亲和数的历史介绍，挺有趣的概念。
先是希腊人发现了220与284的关系，并定义了亲和数。
随后13世纪阿拉伯数学家伊本&#183;阿&#183;巴纳发现了17296和18416，17世纪勒内&#183;笛卡儿发现了亲和数9363584和9437056，然后18世纪莱昂哈德&#183;欧拉，一口气发现了60对亲和数。Re: v_JULY_v 2011-05-24 09:37发表[回复] 回复 ruanjian1986：en，是的。你也可以运行上文中的程序，看看500万以内的亲和数，[e04]3楼 我的职业是看店铺的 2011-05-24 09:32发表[回复] [e10]2楼 yjhfghg 2011-05-24 09:23发表[回复] [e01]先顶一个，待会儿有时间了再细细看Re: v_JULY_v 2011-05-24 09:25发表[回复] 回复 yjhfghg：[e10]1楼 v_JULY_v 2011-05-24 03:25发表[回复] 文章越写越短了，这是好事。晚安。Re: zhoujk 2011-05-25 23:47发表[回复] 回复 v_JULY_v：[e03]
 


您还没有登录,请[登录]或[注册]
 
* 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场
 








个人资料 

v_JULY_v 






访问：4195669次
积分：25982分
排名：第50名
 . 原创：134篇
转载：0篇
译文：5篇
评论：10137条
 . 
博客公告 ①.本blog开通于2010年10月11日，高级C /Algorithms交流群：149977547；北京程序员联盟：172727781。②.狂热算法，热爱数据挖掘，关注机器学习、统计分析，爱好文学数学。③.微博：研究者July，邮箱：zhoulei0907@yahoo.cn，July，二零一三年三月二十九日。 
我的微博 
文章分类 03.Algorithms（实现）(9) 
01.Algorithms（研究）(27) 
02.Algorithms（后续）(22) 
04.Algorithms（讨论）(1) 
05.MS 100' original(7) 
06.MS 100' answers(13) 
07.MS 100' classify(4) 
08.MS 100' one Keys(6) 
09.MS 100' follow-up(3) 
10.MS 100' comments(4) 
11.TAOPP（编程艺术）(26) 
12.TAOPP string(6) 
13.TAOPP array(10) 
14.TAOPP list(2) 
15.stack/heap/queue(0) 
16.TAOPP tree(1) 
17.TAOPP c/c++(2) 
18.TAOPP function(2) 
19.TAOPP algorithms(7) 
20.number operations(1) 
21.Essays(8) 
22.Big Data Processing(5) 
23.Redis/MongoDB(0) 
24.data structures(12) 
25.Red-black tree(7) 
26.Image Processing(3) 
27.Architecture design(4) 
28.Source analysis(3) 
29.Recommend&Search(4) 
30.Machine L&Data Mining(5) 

博客专栏




微软面试100题系列
文章：17篇
阅读：1246089 





程序员编程艺术
文章：24篇
阅读：859706 





经典算法研究
文章：32篇
阅读：1110608 

阅读排行 程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦(186260) 
九月十月百度人搜，阿里巴巴，腾讯华为笔试面试八十题(第331-410题)(141609) 
教你如何迅速秒杀掉：99%的海量数据处理面试题(137438) 
横空出世，席卷互联网--评微软等公司数据结构+算法面试100题(127653) 
从B树、B+树、B*树谈到R 树(122026) 
十道海量数据处理面试题与十个方法大总结(101549) 
九月腾讯，创新工场，淘宝等公司最新面试三十题（第171-200题）(87330) 
十一、从头到尾彻底解析Hash表算法(78387) 
微软公司等数据结构+算法面试100题(第1-100题)全部出炉(75912) 
支持向量机通俗导论（理解SVM的三层境界）(74609) 

评论排行 程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦(371) 
九月十月百度人搜，阿里巴巴，腾讯华为笔试面试八十题(第331-410题)(361) 
九月腾讯，创新工场，淘宝等公司最新面试三十题（第171-200题）(331) 
当今世界最为经典的十大算法--投票进行时(320) 
从B树、B+树、B*树谈到R 树(264) 
横空出世，席卷互联网--评微软等公司数据结构+算法面试100题(263) 
十三个经典算法研究与总结、目录+索引(216) 
我的大学生涯(214) 
程序员编程艺术第一章、左旋转字符串(203) 
三五杆枪，可干革命，三五个人，可以创业(198) 

最新评论 程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦
v_JULY_v: @q1w2ok11:替我感谢你的同事:-) 

程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦
q1w2ok11: 同事推荐，太给力了，必须好好学习，楼主辛苦 

程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦
kiritor: 谢谢博主的分享,先收藏了 

程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦
v_JULY_v: @zhouqinxiong:哪个学校呢？替我谢谢你的老师:-) 

程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦
zhouqinxiong: 老师推荐的，lz，你的博客非常给力 

快速排序算法
康天崽: 太给力了，我喜欢，爱死你了 

我的大学生涯
msjcool: 看完楼主的经历，感觉自己弱爆了 

B树的C实现
hao138548: 好贴 

教你如何迅速秒杀掉：99%的海量数据处理面试题
xiyandeng: 虽然看得不是很懂，以后可以慢慢消化！感谢博主啊 

程序员编程艺术第一章、左旋转字符串
dusx1981: void RightShift4(string &str, int k){ int len = st... 


01、本blog索引 3、微软100题维护地址
1、微软100题横空出世
5、经典算法研究系列
7、红黑树系列集锦
6、程序员编程艺术系列
2、微软面试全部100题
0、经典4大原创系列集锦
4、微软100题下载地址
 
02、Google or baidu? Google搜--"结构之法"（My BLOG）
baidu 搜--"结构之法"（My BLOG）
 
03、个人标签 本BLOG RSS订阅
zhoulei0907@yahoo.cn
csdn blog订阅排行榜
TAOPP修订wiki
julymsn@live.cn
电子工程网专家VIP
 博客园blog-成为推荐博客
 ITpub-代码优化专家
 
04、我的驻点 01. 为学论坛-万物皆数 终生为学
 02、Harry
 03、NoSQLFan
 04、酷勤网
 05、52nlp
 06、北大朋友的挖掘乐园
 07、跟Sophia_qing一起读硕士
 08、面试问答社区51nod
 09、韩寒
 10、我的有鱼
 11、曾经的叛逆与年少
 12、老D之MongoDB源码分析
 14、code4app:iOS代码示例
 17、斯坦福机器学习公开课
 18、TheItHome算法版块版主
 19、36氪--关注互联网创业
 20、德问--编程是一种艺术创作
 21、善科网
 22、百度搜索研发部
 23、淘宝搜索技术博客
 24、interviewstreet
 25、LeetCode
 26、Team_Algorithms人人小组
 
文章存档 
2013年03月(1).
2012年12月(1).
2012年11月(1).
2012年09月(1).
2012年06月(1).
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

展开.
 

. 
公司简介|招贤纳士|广告服务|银行汇款帐号|联系方式|版权声明|法律顾问|问题报告QQ客服 微博客服 论坛反馈 联系邮箱：webmaster@csdn.net 服务热线：400-600-2320京 ICP 证 070598 号北京创新乐知信息技术有限公司 版权所有世纪乐知(北京)网络技术有限公司 提供技术支持江苏乐知网络技术有限公司 提供商务支持Copyright © 1999-2012, CSDN.NET, All Rights Reserved  
