
您还未登录！|登录|注册|帮助
 首页
 业界
 移动
 云计算
 研发
 论坛
 博客
 下载
 
更多
 







结构之法 算法之道

Google或baidu搜索：“结构之法”，进入本博客


 


目录视图
摘要视图
订阅
 . 



【免费有礼】欧美最新网络营销技巧分享        博客导入工具      【限时优惠】第五届云计算大会社区门票抢购 
探究云计算数据中心节能增效之道      专访邓凡平：Android开发路上的快速学习之道      CSDN博客第二期最佳移动开发博主评选 



程序员编程艺术：第九章、闲话链表追赶问题 
.
 分类： 11.TAOPP（编程艺术）14.TAOPP list2011-05-26 11:2016358人阅读评论(57)收藏举报
 
编程面试null测试struct汇编

 

                      程序员编程艺术：第九章、闲话链表追赶问题


作者：July、狂想曲创作组。
出处：http://blog.csdn.net/v_JULY_v 。


前奏
    有这样一个问题：在一条左右水平放置的直线轨道上任选两个点，放置两个机器人，请用如下指令系统为机器人设计控制程序，使这两个机器人能够在直线轨道上相遇。（注意两个机器人用你写的同一个程序来控制）。
    指令系统：只包含4条指令，向左、向右、条件判定、无条件跳转。其中向左（右）指令每次能控制机器人向左（右）移动一步；条件判定指令能对机器人所在的位置进行条件测试，测试结果是如果对方机器人曾经到过这里就返回true，否则返回false；无条件跳转，类似汇编里面的跳转，可以跳转到任何地方。

    ok，这道很有意思的趣味题是去年微软工程院的题，文末将给出解答（如果急切想知道此问题的答案，可以直接跳到本文第三节）。同时，我们看到其实这个题是一个典型的追赶问题，那么追赶问题在哪种面试题中比较常见?对了，链表追赶。本章就来阐述这个问题。有不正之处，望不吝指正。


第一节、求链表倒数第k个结点
第13题、题目描述：
输入一个单向链表，输出该链表中倒数第k个结点,
链表的倒数第0个结点为链表的尾指针。

分析：此题一出，相信，稍微有点 经验的同志，都会说到：设置两个指针p1,p2，首先p1和p2都指向head，然后p2向前走k步，这样p1和p2之间就间隔k个节点，最后p1和p2同时向前移动，直至p2走到链表末尾。

    前几日有朋友提醒我说，让我讲一下此种求链表倒数第k个结点的问题。我想，这种问题，有点经验的人恐怕都已了解过，无非是利用两个指针一前一后逐步前移。但他提醒我说，如果参加面试的人没有这个意识，它怎么也想不到那里去。

    那在平时准备面试的过程中如何加强这一方面的意识呢?我想，除了平时遇到一道面试题，尽可能用多种思路解决，以延伸自己的视野之外，便是平时有意注意观察生活。因为，相信，你很容易了解到，其实这种链表追赶的问题来源于生活中长跑比赛，如果平时注意多多思考，多多积累，多多发现并体味生活，相信也会对面试有所帮助。

    ok，扯多了，下面给出这个题目的主体代码，如下：


struct ListNode
{
    char data;
    ListNode* next;
};
ListNode* head,*p,*q;
ListNode *pone,*ptwo;

//@heyaming, 第一节,求链表倒数第k个结点应该考虑k大于链表长度的case。
ListNode* fun(ListNode *head,int k)
{
 assert(k >= 0);
 pone = ptwo = head;
 for( ; k > 0 && ptwo != NULL; k--)
  ptwo=ptwo->next;
 if (k > 0) return NULL;
 
 while(ptwo!=NULL)
 {
  pone=pone->next;
  ptwo=ptwo->next;
 }
 return pone;
}  

 

扩展：
这是针对链表单项链表查找其中倒数第k个结点。试问，如果链表是双向的，且可能存在环呢?请看第二节、编程判断两个链表是否相交。


第二节、编程判断两个链表是否相交
题目描述：给出两个单向链表的头指针（如下图所示），



比如h1、h2，判断这两个链表是否相交。这里为了简化问题，我们假设两个链表均不带环。

分析：这是来自编程之美上的微软亚院的一道面试题目。请跟着我的思路步步深入（部分文字引自编程之美）：
1.直接循环判断第一个链表的每个节点是否在第二个链表中。但，这种方法的时间复杂度为O(Length(h1) * Length(h2))。显然，我们得找到一种更为有效的方法，至少不能是O（N^2）的复杂度。
2.针对第一个链表直接构造hash表，然后查询hash表，判断第二个链表的每个结点是否在hash表出现，如果所有的第二个链表的结点都能在hash表中找到，即说明第二个链表与第一个链表有相同的结点。时间复杂度为为线性：O(Length(h1) + Length(h2))，同时为了存储第一个链表的所有节点，空间复杂度为O(Length(h1))。是否还有更好的方法呢，既能够以线性时间复杂度解决问题，又能减少存储空间？
3.进一步考虑“如果两个没有环的链表相交于某一节点，那么在这个节点之后的所有节点都是两个链表共有的”这个特点，我们可以知道，如果它们相交，则最后一个节点一定是共有的。而我们很容易能得到链表的最后一个节点，所以这成了我们简化解法的一个主要突破口。那么，我们只要判断俩个链表的尾指针是否相等。相等，则链表相交；否则，链表不相交。
所以，先遍历第一个链表，记住最后一个节点。然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点做比较，如果相同，则相交，否则，不相交。这样我们就得到了一个时间复杂度，它为O((Length(h1) + Length(h2))，而且只用了一个额外的指针来存储最后一个节点。这个方法时间复杂度为线性O（N），空间复杂度为O（1），显然比解法三更胜一筹。
4.上面的问题都是针对链表无环的，那么如果现在，链表是有环的呢?还能找到最后一个结点进行判断么?上面的方法还同样有效么?显然，这个问题的本质已经转化为判断链表是否有环。那么，如何来判断链表是否有环呢?

总结：
所以，事实上，这个判断两个链表是否相交的问题就转化成了：
1.先判断带不带环
2.如果都不带环，就判断尾节点是否相等
3.如果都带环，判断一链表上俩指针相遇的那个节点，在不在另一条链表上。
如果在，则相交，如果不在，则不相交。

    1、那么，如何编写代码来判断链表是否有环呢?因为很多的时候，你给出了问题的思路后，面试官可能还要追加你的代码，ok，如下（设置两个指针(p1, p2)，初始值都指向头，p1每次前进一步，p2每次前进二步，如果链表存在环，则p2先进入环，p1后进入环，两个指针在环中走动，必定相遇）：


 



01.//copyright@ KurtWang  
02.//July、2011.05.27。  
03.struct Node  
04.{  
05.    int value;  
06.    Node * next;  
07.};  
08.  
09.//1.先判断带不带环  
10.//判断是否有环，返回bool，如果有环，返回环里的节点  
11.//思路：用两个指针，一个指针步长为1，一个指针步长为2，判断链表是否有环  
12.bool isCircle(Node * head, Node *& circleNode, Node *& lastNode)  
13.{  
14.    Node * fast = head->next;  
15.    Node * slow = head;  
16.    while(fast != slow && fast && slow)  
17.    {  
18.        if(fast->next != NULL)  
19.            fast = fast->next;  
20.          
21.        if(fast->next == NULL)  
22.            lastNode = fast;  
23.        if(slow->next == NULL)  
24.            lastNode = slow;  
25.          
26.        fast = fast->next;  
27.        slow = slow->next;  
28.          
29.    }  
30.    if(fast == slow && fast && slow)  
31.    {  
32.        circleNode = fast;  
33.        return true;  
34.    }  
35.    else  
36.        return false;  
37.}  
 

    2&3、如果都不带环，就判断尾节点是否相等，如果都带环，判断一链表上俩指针相遇的那个节点，在不在另一条链表上。下面是综合解决这个问题的代码：






01.//判断带环不带环时链表是否相交  
02.//2.如果都不带环，就判断尾节点是否相等  
03.//3.如果都带环，判断一链表上俩指针相遇的那个节点，在不在另一条链表上。  
04.bool detect(Node * head1, Node * head2)  
05.{  
06.    Node * circleNode1;  
07.    Node * circleNode2;  
08.    Node * lastNode1;  
09.    Node * lastNode2;  
10.      
11.    bool isCircle1 = isCircle(head1,circleNode1, lastNode1);  
12.    bool isCircle2 = isCircle(head2,circleNode2, lastNode2);  
13.      
14.    //一个有环，一个无环  
15.    if(isCircle1 != isCircle2)  
16.        return false;  
17.    //两个都无环，判断最后一个节点是否相等  
18.    else if(!isCircle1 && !isCircle2)  
19.    {  
20.        return lastNode1 == lastNode2;  
21.    }  
22.    //两个都有环，判断环里的节点是否能到达另一个链表环里的节点  
23.    else  
24.    {  
25.        Node * temp = circleNode1->next;  //updated，多谢苍狼 and hyy。  
26.        while(temp != circleNode1)    
27.        {  
28.            if(temp == circleNode2)  
29.                return true;  
30.            temp = temp->next;  
31.        }  
32.        return false;  
33.    }  
34.      
35.    return false;  
36.}  
 

扩展2：求两个链表相交的第一个节点
思路：在判断是否相交的过程中要分别遍历两个链表，同时记录下各自长度。

    @Joshua：这个算法需要处理一种特殊情况，即：其中一个链表的头结点在另一个链表的环中，且不是环入口结点。这种情况有两种意思：1)如果其中一个链表是循环链表，则另一个链表必为循环链表，即两个链表重合但头结点不同；2)如果其中一个链表存在环(除去循环链表这种情况)，则另一个链表必在此环中与此环重合，其头结点为环中的一个结点，但不是入口结点。在这种情况下我们约定，如果链表B的头结点在链表A的环中，且不是环入口结点，那么链表B的头结点即作为A和B的第一个相交结点；如果A和B重合(定义方法时形参A在B之前)，则取B的头结点作为A和B的第一个相交结点。 

    @风过无痕：读《程序员编程艺术》，补充代码2012年7月18日 周三下午10:15
    发件人: "風過無痕" <luxiaoxun001@qq.com>将发件人添加到联系人
    收件人: "zhoulei0907" <zhoulei0907@yahoo.cn>
你好
    看到你在csdn上博客，学习了很多，看到下面一章，有个扩展问题没有代码，发现自己有个，发给你吧，思路和别人提出来的一样，感觉有代码更加完善一些，呵呵

扩展2：求两个链表相交的第一个节点
    思路：如果两个尾结点是一样的，说明它们有重合；否则两个链表没有公共的结点。
    在上面的思路中，顺序遍历两个链表到尾结点的时候，我们不能保证在两个链表上同时到达尾结点。这是因为两个链表不一定长度一样。但如果假设一个链表比另一个长L个结点，我们先在长的链表上遍历L个结点，之后再同步遍历，这个时候我们就能保证同时到达最后一个结点了。由于两个链表从第一个公共结点开始到链表的尾结点，这一部分是重合的。因此，它们肯定也是同时到达第一公共结点的。于是在遍历中，第一个相同的结点就是第一个公共的结点。
    在这个思路中，我们先要分别遍历两个链表得到它们的长度，并求出两个长度之差。在长的链表上先遍历若干次之后，再同步遍历两个链表，直到找到相同的结点，或者一直到链表结束。PS：没有处理一种特殊情况：就是一个是循环链表，而另一个也是，只是头结点所在位置不一样。 

    代码如下：





01.ListNode* FindFirstCommonNode( ListNode *pHead1, ListNode *pHead2)  
02.{  
03.      // Get the length of two lists  
04.      unsigned int nLength1 = ListLength(pHead1);  
05.      unsigned int nLength2 = ListLength(pHead2);  
06.      int nLengthDif = nLength1 - nLength2;  
07.  
08.      // Get the longer list  
09.      ListNode *pListHeadLong = pHead1;  
10.      ListNode *pListHeadShort = pHead2;  
11.      if(nLength2 > nLength1)  
12.      {  
13.            pListHeadLong = pHead2;  
14.            pListHeadShort = pHead1;  
15.            nLengthDif = nLength2 - nLength1;  
16.      }  
17.   
18.      // Move on the longer list  
19.      for(int i = 0; i < nLengthDif; ++ i)  
20.            pListHeadLong = pListHeadLong->m_pNext;  
21.   
22.      // Move on both lists  
23.      while((pListHeadLong != NULL) && (pListHeadShort != NULL) && (pListHeadLong != pListHeadShort))  
24.      {  
25.            pListHeadLong = pListHeadLong->m_pNext;  
26.            pListHeadShort = pListHeadShort->m_pNext;  
27.      }  
28.   
29.      // Get the first common node in two lists  
30.      ListNode *pFisrtCommonNode = NULL;  
31.      if(pListHeadLong == pListHeadShort)  
32.            pFisrtCommonNode = pListHeadLong;  
33.   
34.      return pFisrtCommonNode;  
35.}  
36.  
37.unsigned int ListLength(ListNode* pHead)  
38.{  
39.      unsigned int nLength = 0;  
40.      ListNode* pNode = pHead;  
41.      while(pNode != NULL)  
42.      {  
43.            ++ nLength;  
44.            pNode = pNode->m_pNext;  
45.      }  
46.      return nLength;  
47.}  


    关于判断单链表是否相交的问题，还可以看看此篇文章：http://www.cppblog.com/humanchao/archive/2008/04/17/47357.html。ok，下面，回到本章前奏部分的那道非常有趣味的智力题。




第三节、微软工程院面试智力题
题目描述：
    在一条左右水平放置的直线轨道上任选两个点，放置两个机器人，请用如下指令系统为机器人设计控制程序，使这两个机器人能够在直线轨道上相遇。（注意两个机器人用你写的同一个程序来控制）
    指令系统：只包含4条指令，向左、向右、条件判定、无条件跳转。其中向左（右）指令每次能控制机器人向左（右）移动一步；条件判定指令能对机器人所在的位置进行条件测试，测试结果是如果对方机器人曾经到过这里就返回true，否则返回false；无条件跳转，类似汇编里面的跳转，可以跳转到任何地方。

分析：我尽量以最清晰的方式来说明这个问题（大部分内容来自ivan，big等人的讨论）：
      1、首先题目要求很简单，就是要你想办法让A最终能赶上B，A在后，B在前，都向右移动，如果它们的速度永远一致，那A是永远无法追赶上B的。但题目给出了一个条件判断指令，即如果A或B某个机器人向前移动时，若是某个机器人经过的点是第二个机器人曾经经过的点，那么程序返回true。对的，就是抓住这一点，A到达曾经B经过的点后，发现此后的路是B此前经过的，那么A开始提速两倍，B一直保持原来的一倍速度不变，那样的话，A势必会在|AB|/move_right个单位时间内，追上B。ok，简单伪代码如下：

start:
if(at the position other robots have not reached)
    move_right
if(at the position other robots have reached)
    move_right
    move_right
goto start

再简单解释下上面的伪代码（@big）：
A------------B
|                  |
在A到达B点前，两者都只有第一条if为真，即以相同的速度向右移动，在A到达B后，A只满足第二个if，即以两倍的速度向右移动，B依然只满足第一个if，则速度保持不变，经过|AB|/move_right个单位时间，A就可以追上B。

 

     2、有个细节又出现了，正如ivan所说，

if(at the position other robots have reached)
    move_right
    move_right

上面这个分支不一定能提速的。why?因为如果if条件花的时间很少，而move指令发的时间很大（实际很可能是这样），那么两个机器人的速度还是基本是一样的。

那作如何修改呢?:

start:
if(at the position other robots have not reached)
    move_right
    move_left
    move_right
if(at the position other robots have reached)
    move_right
goto start

-------

这样改后，A的速度应该比B快了。

      3、然要是说每个指令处理速度都很快，AB岂不是一直以相同的速度右移了?那到底该作何修改呢?请看：

go_step()
{
   向右
   向左
   向右
}
--------
三个时间单位才向右一步

go_2step()
{
   向右
}
------

    一个时间单向右一步向左和向右花的时间是同样的，并且会占用一定时间。 如果条件判定指令时间比移令花的时间较少的话，应该上面两种步法，后者比前者快。至此，咱们的问题已经得到解决。

      最后，感谢蜜蜂提供的这道有意思的面试题：



本章完。

--------------------------------------------------------------------------------

版权所有，本人对本blog内所有任何内容享有版权及著作权。网络转载，请以链接形式注明出处。
 
分享到： 

上一篇：程序员编程艺术：第八章、从头至尾漫谈虚函数
下一篇：程序员编程艺术：第十章、如何给10^7个数据量的磁盘文件排序
 . 


查看评论
 
35楼 sheldonm 2013-04-04 10:06发表[回复] 在第二节里面bool detect(Node * head1, Node * head2)函数里面调用bool isCircle(Node * head, Node *& circleNode, Node *& lastNode) 有可能存在链表有一个节点，那么将直接返回false，这时lastNode是没有被赋值的，在detect里面这个指针也是没有初始化的，所以在运行时出现其中一个或两个链表只有一个节点时会报错。并且如果是两个同一个只有一个节点的链表，也会判断错误。应该对isCircle稍作修改。也有可能我看得不够细，没有领会到你的意思34楼 小菜一枚 2012-10-03 20:27发表[回复] 文章写得很好，非常感谢JuLy为大家带来的好文章，有个小小的意见~判断链表有环这里有个小问题：让两个指针的初始值都指向头，slow每次前进一步，fast每次前进二步这样写代码的可读性较高，july不必让fast的初始值在head->next吧？
bool isCircle(Node * head, Node *& circleNode, Node *& lastNode) 
{ 
Node * fast = head->next; //这里是不是应该为*fast = head;
 Node * slow = head; 
while(fast != slow && fast && slow) 
{ 
.........//省略
}33楼 msdn945497622 2012-08-28 09:28发表[回复] 楼主你好，最近一直在看您的博客，写的非常好。在本篇文章中，发现了一个小问题(decete函数中)：当两链表都存在环的时候，且恰好circleNode1 == circleNode2，应该返回true吧，但是楼主的代码返回false.看能否改成：
 else if(hasCircle1 && hasCircle2)
 {
 Node *pTemp = circleNode1->next;
 while(circleNode1 != pTemp)
 {
 if (pTemp == circleNode2)
 {
 return true;
 }
 pTemp = pTemp->next;
 }
 return circleNode1 == circleNode2;//不是直接返false
 }32楼 v_JULY_v 2012-07-19 13:31发表[回复] 感谢风过无痕发来的邮件和建议，谢谢Re: v_JULY_v 2012-07-19 13:32发表[回复] 回复v_JULY_v：代码可读性很好31楼 jy00272082 2012-07-14 03:48发表[回复] 关于链表是否有交点的问题我有一个想法，可以同时处理有环和无环的情况，但是缺点是需要改变其中一条链表。
思路是这样的，先遍历一条链表，然后对他进行标记，无论有环还是没有环这次遍历都是可以再线性时间内完成的。然后再遍历第二条链表检查第二条链表上是否有被标记过的点。
总共的算法是线性的。
不知道这种想法是对是错，望指正。30楼 myserverthepeople 2012-04-26 11:45发表[回复] 好好，先回复再看文章29楼 liumilan2011 2012-04-24 17:49发表[回复] 步长为2快指针，步长为1慢指针能满足判断环的条件，若步长为3,4甚至更多，是否一样能满足条件？这里是否有数学理论支撑啊？28楼 linehrr123 2012-02-24 08:12发表[回复] 楼主，貌似判断有没有环只用判断连标的各节点中是否有节点最后指向NULL，如果没有就一定是环啊~27楼 wgl_July 2011-09-06 22:35发表[回复] 有一个问题没懂，就是判断链表是否有环的那个函数中：
while(fast != slow && fast && slow)
{ ...
 if (slow->next == NULL)
 lastNode = slow;
 ...
}
既然fast指针跑的快，它都不为NULL的情况下slow->next怎么可能为NULL呢？26楼 wqOoops 2011-08-01 17:07发表[回复] 两个机器人的问题，要是A和B都在一个环上面走呢？？有该如何解决....呵呵！Re: futurelan 2011-11-24 18:01发表[回复] 回复shiren_Bod：这是个好想法啊，可以思考下，呵呵25楼 wangyangkobe 2011-07-28 10:55发表[回复] 通过hash表来判断有问题吧，如果两个链表的所有元素相同，但是他们根本就不相交的话，那楼主的方法是不是有问题呢？24楼 Joshua1999 2011-07-13 19:00发表[回复] 那段文字的说明我已经改了Re: v_JULY_v 2011-07-13 19:26发表[回复] 回复Joshua1999：恩，修改到了wiki上了是吧，日后会修正过来的。辛苦你拉。23楼 shifuwawa 2011-07-10 09:22发表[回复] 判相交方法三有局限性吧，链表相交没有X这种吗（中间交了N下，然后又分开了）Re: linehrr123 2012-02-24 08:14发表[回复] 回复shifuwawa：不会有的啊~单向链表只能指向一个下一节点，X形状的是办不到的，Q型的也只能是入环支路，不能是出环支路~22楼 san_ren_xing 2011-07-08 11:06发表[回复] 写得相当好，但是提两个小问题，
（1）bool isCircle(Node * head, Node *& circleNode, Node *& lastNode) 
{ 
Node * fast = head->next; 
Node * slow = head;
此处省略18个字。。。
}
由于没有判断head != NULL所以可能会出core。
（2）
此处省略18个字。。。。
else 
{ 
Node * temp = circleNode1->next; //updated，多谢苍狼 and hyy。 
while(temp != circleNode1) 
{ 
if(temp == circleNode2) 
return true; 
temp = temp->next; 
} 
return false; 
} 
这里如果circleNode1->next == circleNode1;就出现判断错误了。21楼 cqalice 2011-06-15 17:52发表[回复] [e01] 链表跟指针有关系吧！……20楼 源远流长 2011-06-09 10:24发表[回复] 判断两个链表是否相交好像有问题。如果两个链表是一开始重合，后面分叉，那么尾指针就不一样了，而是头指针一样。。Re: blueriver1981 2011-06-11 09:23发表[回复] 回复 duck_genuine：你仔细想想，链表只有一个Next结点，相关后就不会再有分叉了Re: 源远流长 2011-06-22 14:53发表[回复] 回复 blueriver1981：对哦。我搞错了。Re: chong_boy 2011-06-10 12:26发表[回复] 回复 duck_genuine：想想链表是怎么实现的,然后您就会发现这种情况是不存在的了.19楼 zhangyilina1987 2011-06-06 11:42发表[回复] 你好，我有点问题问一下，“针对第一个链表直接构造hash表，然后查询hash表，判断第二个链表的每个结点是否在hash表出现，如果所有的第二个链表的结点都能在hash表中找到，即说明第二个链表与第一个链表有相同的结点。”Re: zhangyilina1987 2011-06-06 11:42发表[回复] 回复 zhangyilina1987：在这段话中，如果链表二是链表一中的一段才成立吧，并不是相交时成立吧。不知道我想的对不对。18楼 khil_wang 2011-06-05 23:06发表[回复] 好文章，尤其是那个两个机器人追赶的问题。开始还真没想到处理指令的时间还要影响结果。[e01]17楼 lzjnhs 2011-06-04 15:12发表[回复] [e01]16楼 aimin2049 2011-06-03 10:17发表[回复] [e03]15楼 aimin2049 2011-06-03 10:17发表[回复] [e01]14楼 xingxi_200 2011-05-31 11:31发表[回复] [e01]13楼 a06057329 2011-05-31 11:03发表[回复] 昨天还一直在想在两个都有环的情况下怎么判断它们是否相交呢，谢谢楼主！Re: v_JULY_v 2011-06-05 18:01发表[回复] 回复 a06057329：客气，有任何问题，欢迎随时指出。谢谢。12楼 cwm5511 2011-05-31 08:43发表[回复] 谢谢分享，学习了！！！11楼 charlie_wu 2011-05-30 17:20发表[回复] 好文章[e01]10楼 奋斗小子 2011-05-28 10:11发表[回复] [e01]老规矩,先回复在看..Re: v_JULY_v 2011-05-28 12:57发表[回复] 回复 lanyan822：[e10]9楼 hyy281102972 2011-05-28 02:43发表[回复] 判断链表相交 
Node * temp = circleNode1; 
while(temp != circleNode1) 
有误Re: v_JULY_v 2011-05-28 11:40发表[回复] 回复 hyy281102972：?Re: hyy281102972 2011-05-28 12:36发表[回复] 回复 v_JULY_v：判断链表相交的detect函数里面代码倒数11行处...Re: v_JULY_v 2011-05-28 12:56发表[回复] 回复 hyy281102972：应该是while(temp != NULL)，对不对?Re: hyy281102972 2011-05-28 18:31发表[回复] 回复 v_JULY_v：temp是链环节点，不会为NULL吧。Re: v_JULY_v 2011-05-28 18:34发表[回复] 回复 hyy281102972：已经修正过来了，谢谢你，[e10]。8楼 happyjw 2011-05-27 23:44发表[回复] [e01]7楼 v_JULY_v 2011-05-27 22:38发表[回复] 枫叶说，前几日，编程判断两个链表是否相交的这道题百度电面被问到了。6楼 v_JULY_v 2011-05-27 22:38发表[回复] 枫叶说，前几日，这道题百度电面被问到了。5楼 v_JULY_v 2011-05-27 09:30发表[回复] [e10]4楼 newrain021011 2011-05-26 16:24发表[回复] 看到这个，我忽然想起在上海拍到的一个视频，两个机器人交战。我总觉得july的实现，并那么合理，因为机器人A可以做的事情，机器人B也是可以做的，这个才是微软出题的目的，另外，应该有一个场景设置，即机器人在某个活动范围内，否则，这个题解法就更困难。Re: newrain021011 2011-05-26 16:26发表[回复] 回复 newrain021011：漏写一字，并非那么合理。Re: v_JULY_v 2011-05-26 16:31发表[回复] 回复 newrain021011：朋友，欢迎加入狂想曲的wiki：http://tctop.wikispaces.com/。或者加入本blog算法交流群，方便探讨，95259469。有任何的问题，请一定多多提出。Re: newrain021011 2011-05-26 16:33发表[回复] 回复 v_JULY_v： 俺就是Damon. 说的是最后一段模拟代码。Re: v_JULY_v 2011-05-26 20:48发表[回复] 回复 newrain021011：最后那段代码显得有点多余，去掉了。Re: v_JULY_v 2011-05-26 16:34发表[回复] 回复 newrain021011：哦的天呐，早说嘛，那你有何建议?或作何修改?Re: v_JULY_v 2011-05-26 16:27发表[回复] 回复 newrain021011：你是说最后那一段模拟的完整代码实现么?3楼 十一文 2011-05-26 14:10发表[回复] 扩展：
这是针对链表单项链表查找其中倒数第k个结点，试问，如果链表可能存在环呢?请看第二节、编程判断两个链表是否相交。


单项链------------------------向Re: v_JULY_v 2011-05-26 16:00发表[回复] 回复 xming4321：o，对，应该修改一下，呵呵，谢谢十一文的提醒。[e03]2楼 十一文 2011-05-26 11:56发表[回复] [e04]终于抢了个沙发 别废话 了 先看文章Re: v_JULY_v 2011-05-26 12:17发表[回复] 回复 xming4321：[e10]1楼 十一文 2011-05-26 11:55发表[回复] 前台占位[e01]
 


您还没有登录,请[登录]或[注册]
 
* 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场
 








个人资料 

v_JULY_v 






访问：4195691次
积分：25982分
排名：第50名
 . 原创：134篇
转载：0篇
译文：5篇
评论：10137条
 . 
博客公告 ①.本blog开通于2010年10月11日，高级C /Algorithms交流群：149977547；北京程序员联盟：172727781。②.狂热算法，热爱数据挖掘，关注机器学习、统计分析，爱好文学数学。③.微博：研究者July，邮箱：zhoulei0907@yahoo.cn，July，二零一三年三月二十九日。 
我的微博 
文章分类 03.Algorithms（实现）(9) 
01.Algorithms（研究）(27) 
02.Algorithms（后续）(22) 
04.Algorithms（讨论）(1) 
05.MS 100' original(7) 
06.MS 100' answers(13) 
07.MS 100' classify(4) 
08.MS 100' one Keys(6) 
09.MS 100' follow-up(3) 
10.MS 100' comments(4) 
11.TAOPP（编程艺术）(26) 
12.TAOPP string(6) 
13.TAOPP array(10) 
14.TAOPP list(2) 
15.stack/heap/queue(0) 
16.TAOPP tree(1) 
17.TAOPP c/c++(2) 
18.TAOPP function(2) 
19.TAOPP algorithms(7) 
20.number operations(1) 
21.Essays(8) 
22.Big Data Processing(5) 
23.Redis/MongoDB(0) 
24.data structures(12) 
25.Red-black tree(7) 
26.Image Processing(3) 
27.Architecture design(4) 
28.Source analysis(3) 
29.Recommend&Search(4) 
30.Machine L&Data Mining(5) 

博客专栏




微软面试100题系列
文章：17篇
阅读：1246112 





程序员编程艺术
文章：24篇
阅读：859708 





经典算法研究
文章：32篇
阅读：1110611 

阅读排行 程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦(186260) 
九月十月百度人搜，阿里巴巴，腾讯华为笔试面试八十题(第331-410题)(141609) 
教你如何迅速秒杀掉：99%的海量数据处理面试题(137438) 
横空出世，席卷互联网--评微软等公司数据结构+算法面试100题(127653) 
从B树、B+树、B*树谈到R 树(122026) 
十道海量数据处理面试题与十个方法大总结(101549) 
九月腾讯，创新工场，淘宝等公司最新面试三十题（第171-200题）(87330) 
十一、从头到尾彻底解析Hash表算法(78387) 
微软公司等数据结构+算法面试100题(第1-100题)全部出炉(75912) 
支持向量机通俗导论（理解SVM的三层境界）(74609) 

评论排行 程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦(371) 
九月十月百度人搜，阿里巴巴，腾讯华为笔试面试八十题(第331-410题)(361) 
九月腾讯，创新工场，淘宝等公司最新面试三十题（第171-200题）(331) 
当今世界最为经典的十大算法--投票进行时(320) 
从B树、B+树、B*树谈到R 树(264) 
横空出世，席卷互联网--评微软等公司数据结构+算法面试100题(263) 
十三个经典算法研究与总结、目录+索引(216) 
我的大学生涯(214) 
程序员编程艺术第一章、左旋转字符串(203) 
三五杆枪，可干革命，三五个人，可以创业(198) 

最新评论 程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦
v_JULY_v: @q1w2ok11:替我感谢你的同事:-) 

程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦
q1w2ok11: 同事推荐，太给力了，必须好好学习，楼主辛苦 

程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦
kiritor: 谢谢博主的分享,先收藏了 

程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦
v_JULY_v: @zhouqinxiong:哪个学校呢？替我谢谢你的老师:-) 

程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦
zhouqinxiong: 老师推荐的，lz，你的博客非常给力 

快速排序算法
康天崽: 太给力了，我喜欢，爱死你了 

我的大学生涯
msjcool: 看完楼主的经历，感觉自己弱爆了 

B树的C实现
hao138548: 好贴 

教你如何迅速秒杀掉：99%的海量数据处理面试题
xiyandeng: 虽然看得不是很懂，以后可以慢慢消化！感谢博主啊 

程序员编程艺术第一章、左旋转字符串
dusx1981: void RightShift4(string &str, int k){ int len = st... 


01、本blog索引 3、微软100题维护地址
1、微软100题横空出世
5、经典算法研究系列
7、红黑树系列集锦
6、程序员编程艺术系列
2、微软面试全部100题
0、经典4大原创系列集锦
4、微软100题下载地址
 
02、Google or baidu? Google搜--"结构之法"（My BLOG）
baidu 搜--"结构之法"（My BLOG）
 
03、个人标签 本BLOG RSS订阅
zhoulei0907@yahoo.cn
csdn blog订阅排行榜
TAOPP修订wiki
julymsn@live.cn
电子工程网专家VIP
 博客园blog-成为推荐博客
 ITpub-代码优化专家
 
04、我的驻点 01. 为学论坛-万物皆数 终生为学
 02、Harry
 03、NoSQLFan
 04、酷勤网
 05、52nlp
 06、北大朋友的挖掘乐园
 07、跟Sophia_qing一起读硕士
 08、面试问答社区51nod
 09、韩寒
 10、我的有鱼
 11、曾经的叛逆与年少
 12、老D之MongoDB源码分析
 14、code4app:iOS代码示例
 17、斯坦福机器学习公开课
 18、TheItHome算法版块版主
 19、36氪--关注互联网创业
 20、德问--编程是一种艺术创作
 21、善科网
 22、百度搜索研发部
 23、淘宝搜索技术博客
 24、interviewstreet
 25、LeetCode
 26、Team_Algorithms人人小组
 
文章存档 
2013年03月(1).
2012年12月(1).
2012年11月(1).
2012年09月(1).
2012年06月(1).
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

展开.
 

. 
公司简介|招贤纳士|广告服务|银行汇款帐号|联系方式|版权声明|法律顾问|问题报告QQ客服 微博客服 论坛反馈 联系邮箱：webmaster@csdn.net 服务热线：400-600-2320京 ICP 证 070598 号北京创新乐知信息技术有限公司 版权所有世纪乐知(北京)网络技术有限公司 提供技术支持江苏乐知网络技术有限公司 提供商务支持Copyright © 1999-2012, CSDN.NET, All Rights Reserved  
