  
本站首页 | 行业新闻 | 产品中心 | 系统编程 | 下载中心 | 视频中心 | 解决方案 | 技术支持 | 开发与设计 | 公司简介 | 联系我们 | 留言板 | 友情链接6 行业新闻 
人机界面工业液晶显示器经典案例 
编程开发 
专题介绍技术讨论区 
签写留言查看留言友情链接 
收藏本站   现在位置： 首页 -> 嵌入式仪器仪表 -> 其他嵌入式操作系统 >> 正文   
站 内 搜 索 »    仅搜索标题  智能全文搜索   

广告位


(7,4)汉明码编解码器的设计报告 详细内容   
来源：武汉绘芯科技有限公司 作者：本站编辑 热 荐 时间：2011-12-28 查看次数：622 　　大 中 小 
(7,4)汉明码编解码器的设计报告 

(7,4)汉明码编解码器的设计报告


序  言

EDA ( Elect ronics Design Automation) 技术是随着集成电路和计算机技术飞速发展应运而生的一种高级、快速、有效的电子设计自动化工具。目前，VHDL语言已经成为EDA的关键技术之一，VHDL 是一种全方位的硬件描述语言,具有极强的描述能力,能支持系统行为级、寄存器传输级和逻辑门级三个不同层次的设计,支持结构、数据流、行为三种描述形式的混合描述,覆盖面广,抽象能力强,因此在实际应用中越来越广泛。

VHDL语言具有功能强大的语言结构，可用明确的代码描述复杂的控制逻辑设计，并且具有多层次的设计描述功能，支持设计库和可重复使用的元件的生成。近几十年来，EDA技术获得了飞速发展。它以计算机为平台，根据硬件描述语言VHDL，自动地完成逻辑编译、化简分割、综合及优化，布局布线，仿真直至对特定目标芯片的适配编译，逻辑映射和编程下载等工作。以自顶向下的设计方法，使硬件设计软件化，摆脱了传统手工设计的众多缺点。随着EDA技术的深入发展基于硬件描述语言的方法将有取代传统手工设计方法的趋势。

汉明码是在原编码的基础上附加一部分代码，使其满足纠错码的条件。它属于线性分组码，由于汉明码的抗干扰能力较强，至今仍是应用比较广泛的一类码。

本文用VHDL语言实现了（7，4）汉明码的编码和译码，并通过实例来说明利用VHDL语言实现数字系统的过程。在介绍（7，4）汉明码编码和译码原理的基础上,设计出了（7，4）汉明码的编码器和译码器，写出了基于VHDL实现的源程序,并通过QUARTUSⅡ软件进行仿真验证。

第1章 QuartusⅡ与VHDL简介

 

1.1 QuartusⅡ软件简介

QuartusⅡ是Altera公司推出的CPLD/FPGA的开发工具，QuartusⅡ提供了完全集成且与电路结构无关的开发环境，具有数字逻辑设计的全部特性。

?/P>

   Quartus Ⅱ设计软件提供完整的多平台设计环境，可以很轻松地满足特定设计的需要。它是可编程片上系统(SOPC)设计的综合性环境，拥有FPGA 和CPLD设计的所有阶段的解决方案。与其它EDA软件相比较QuartusⅡ软件的特点主要包括:

1、可利用原理图、结构框图、Verilog HDL、AHDL和VHDL完成电路描述,并将其保存为设计实体文件。

2、芯片(电路)平面布局连线编辑。

3、LogicLock增量设计方法,用户可建立并优化系统,然后添加对原始系统的性能影响较小或无影响的后续模块。

4、功能强大的逻辑综合工具。

5、完备的电路功能仿真与时序逻辑分析。

6、定时/时序分析与关键路径延时分析。

7、可使用SignalTap Ⅱ逻辑分析工具进行嵌入式的逻辑分析。

8、支持软件源文件的添加和创建,并将它们链接起来生成编程文件。

9、使用组合编译方式可一次完成整体设计流程。

10、自动定位编译错误。

11、高效的期间编程与验证工具。

12、可读入标准的EDIF网表文件、VHDL网表文件和Verilog网表文件。

13、能生成第三方EDA软件使用的VHDL网表文件和Verilog网表文件。

 

1.2 VHDL简介

  “VHDL设计”作为信息类专业新开出的一门重要的专业课，相对于传统课程具有内容新、发展快、应用性强等特点。在硬件电子电路设计领域中，电子设计自动化(EDA)工具已成为主要的设计手段，而VHDL语言则是EDA的关键技术之一。VHDL语言具有功能强大的语言结构，可用明确的代码描述复杂的控制逻辑设计，并且具有多层次的设计描述功能，支持设计库和可重复使用的元件的生成。近几十年来，EDA技术获得了飞速发展。它以计算机为平台，根据硬件描述语言VHDL，自动地完成逻辑编译、化简分割、综合及优化，布局布线，仿真直至对特定目标芯片的适配编译，逻辑映射和编程下载等工作。以自顶向下的设计方法，使硬件设计软件化，摆脱了传统手工设计的众多缺点。随着EDA技术的深入发展基于硬件描述语言的方法将有取代传统手工设计方法的趋势。

第2章 (7,4)汉明码的原理

 

2.1 基本概念

线性分组码是一类重要的纠错码，应用很广泛。在（n，k）分组码中，若

督元是按线性关系相加而得到的，则称其为线性分组码。

现在以(7,4)分组码为例来说明线性分组码的特点。设其码字为A=[a6，a5，a4，a3，a2，a1，a0]，其中前4位是信息元，后3位是监督元，可用下列线性方程组来描述该分组码，产生监督元：   

          a2 = a6 + a5 + a4

          a1 = a6 + a5      + a3                             （2.1.1）

          a0 = a6      + a4 + a3

显然，这3个方程是线性无关的。经计算可得(7,4)码的全部码字，如表2-1所示。

表2-1 (7,4)码的全部码字

?/P>

序

号
 码   字
 序

号
 码   字
 
信 息码元
 监 督 元
 信 息码元
 监 督 元
 
0
 0  0  0  0
 0  0  0
 8
 1  0  0  0
 1  1  1
 
1
   0  0  0  1
 0  1  1
 9
 1  0  0  1
 1  0  0
 
2
   0  0  1  0
 1  0  1
 10
 1  0  1  0
 0  1  0
 
3
 0  0  1  1
 1  1  0
 11
 1  0  1  1
 0  0  1
 
4
 0  1  0  0
 1  1  0
 12
    1  1  0  0
 0  0  1
 
5
 0  1  0  1
 1  0  1
 13
    1  1  0  1
 0  1  0
 
6
 0  1  1  0
 0  1  1
 14
    1  1  1  0
 1  0  0
 
7
 0  1  1  1
 0  0  0
 15
    1  1  1  1
 1  1  1
 

不难看出，上述(7,4)码的最小码距d0=3，它能纠1个错或检2个错。

汉明码是能够纠正单个错误的线性分组码，其特点是：最小码距d0=3，码长n与监督位满足n=2r-1的关系，上述的(7,4)线性分组码就是一个汉明码。

2.2 监督矩阵H

式（2.1.1）所示(7,4)汉明码的3个监督方程改写后可用矩阵形式表示为

                             a6

                            a5

          1 1 1 0 1 0 0     a4       0

          1 1 0 1 0 1 0  · a3   =   0                      (2.2.1)

          1 0 1 1 0 0 1     a2       0

                            a1

                            a0

并简记为    H·AT=0T 或 A·HT=0                             （2.2.2）

H称为监督矩阵，一旦H给定，信息位和监督位之间的关系也就确定了。H矩阵可以分成2部分

                   1 1 1 0   1 0 0

             H =   1 1 0 1   0 1 0   =[P Ir]               （2.2.3）

                   1 0 1 1   0 0 1

    H·AT=0T，可以用来作为判断接收码字A是否出错的依据。

 

2.3 生成矩阵G

把监督方程补充完整并改写为矩阵形式

a6      1 0 0 0

a5      0 1 0 0

a4      0 0 1 0     a6

a3  =   0 0 0 1  · a5                        (2.3.1)

a2      1 1 1 0     a4

a1      1 1 0 1     a3

a0      1 0 1 1

              A = [a6 a5 a4 a3] ·G                          （2.3.2）

其中

 

                   1 0 0 0  1 1 1

                   0 1 0 0  1 1 0

             G =   0 0 1 0  1 0 1                         （2.3.3）

                   0 0 0 1  0 1 1

G称为生成矩阵，由G和信息组就可以产生全部码字。生成矩阵也可以分成2部分，即          G = [Ik  Q]                                （2.3.4）

其中               1 1 1

              Q =  1 1 0  = PT                            （2.3.5）

                   1 0 1

                   0 1 1

2.4 伴随式（校正子）S 
设发送码组A= [an—1,an—2,…,a1,a0 ],在传输过程中可能发生误码。接收码组B=[ bn—1,bn—2,…,b1,b0  ],收发码组之差定义为错误图样E，即

                     E = B - A                     (2.4.1)

令S = BHT，称为伴随式或校正子。

S = BHT =（A + E）HT  = EHT                       (2.4.2)

上述(7,4)汉明码的伴随式与错误图样的对应关系如表2-2所示。

表2-2(7,4)汉明码S与E的对应关系

序

号
 错误

码位
 E
 S
 
e6    e5    e4    e3    e2    e1    e0
 s2   s1   s0
 
0
 /
 0    0    0    0    0    0    0
 0    0    0
 
1
 b0
 0    0    0    0    0    0    1
 0    0    1
 
2
 b1
 0    0    0    0    0    1    0
 0    1    0
 
3
 b2
 0    0    0    0    1    0    0
 1    0    0
 
4
 b3
 0    0    0    1    0    0    0
 0    1    1
 
5
 b4
 0    0    1    0    0    0    0
 1    0    1
 
6
 b5
 0    1    0    0    0    0    0
 1    1    0
 
7
 b6
 1    0    0    0    0    0    0
 1    1    1
 

 

第3章 (7,4)汉明码编解码器的设计 
 

3.1  (7,4)汉明码的编码思路及程序设计 
 

3.1.1 (7,4)汉明码的编码思路 
(7,4)汉明码的编码就是将输入的四位信息码编成七位的汉明码，即加入三位监督位。

根据式（2.3.2）A = [a6 a5 a4 a3] ·G可知，信息码与生成矩阵G的乘积就是编好以后的(7,4)汉明码，而生成矩阵G又是已知的，由式（2.3.3）得

                   1 0 0 0  1 1 1

                   0 1 0 0  1 1 0

             G =   0 0 1 0  1 0 1                   （3.1.1）

                   0 0 0 1  0 1 1

所以，可以得出如下方程组

            a6 = a6

            a5 =      a5

            a4 =           a4

            a3 =                a3                     (3.1.2)

            a2 = a6 + a5 + a4

            a1 = a6 + a5      + a3

            a0 = a6      + a4 + a3

根据式(3.1.2)就可以编出编码程序了。

 

3.1.2 (7,4)汉明码的编码程序设计 
根据(7,4)汉明码的编码原理，首先画出程序设计的流程图：


图3.1 编码流程图

输入信息码a3a2a1a0，输出(7,4)汉明码b6b5b4b3b2b1b0。

首先，输入信息码a3a2a1a0，即使用以下语句：

port(a:in std_logic_vector(3 downto 0);

然后，根据式(3.1.2)，就可以得到监督位与信息码之间的对应关系，使用异或运算，即：

b(2)<=a(3) xor a(2) xor a(1);

b(1)<=a(3) xor a(2) xor a(0);

b(0)<=a(3) xor a(1) xor a(0);

最后，将算好的监督位与原来输入的信息码一起输出，这样，编码程序就算完成了。

 

3.2  (7,4)汉明码的译码思路及程序设计 
 

3.2.1 (7,4)汉明码的译码思路 
(7,4)汉明码的译码就是将输入的七位汉明码翻译成四位的信息码，并且纠正其中可能出现的一个错误。

由于生成矩阵G是已知的，所以根据式（2.3.4）G = [Ik  Q] ，可以得到矩阵Q的值

 

                   1 1 1

              Q =  1 1 0  = PT                      （3.2.1）

                   1 0 1

                   0 1 1

那么               1  1  1  0

             P =   1  1  0  1                     （3.2.2）

                   1  0  1  1

而监督矩阵H与PT又存在一定的关系，即

H =[P Ir]                                        （3.2.3）

那么就可以算出监督矩阵H的值，即

                   1 1 1 0 1 0 0

             H =   1 1 0 1 0 1 0                  （3.2.4）

                   1 0 1 1 0 0 1

所以                 1  1  1

                     1  1  0

                     1  0  1

          HT  =    0  1  1                        （3.2.5）

                     1  0  0

                     0  1  0

                     0  0  1

根据式(2.4.2)S = BHT =（A + E）HT  = EHT可以看出校正子S与错误图样E之间有确定的线性变换关系。而E =[ en-1,en-2,…,e1,e0 ]，这样就可以算出校正子S与(7,4)汉明码各位之间的关系，即

          S2 = a2 + a6 + a5 + a4

          S1 = a1 + a6 + a5 +a3                               （3.2.6）

          S0 = a0 + a6 + a4 + a3

对照表2-2，就可以确定每一位出错时，对应的校正子s2s1s0的值。

这样，译码问题就迎刃而解了。

 

3.2.2 (7,4)汉明码的译码程序设计 
根据(7,4)汉明码的译码原理，首先画出程序设计的流程图：

 

图3.2.1 译码流程图

首先，输入7位汉明码a6a5a4a3a2a1a0，用以下语句来实现：

port(a:in std_logic_vector(6 downto 0);

然后，根据这7位码a6a5a4a3a2a1a0，计算校正子s2s1s0的值，根据式（3.2.6）可知校正子S与(7,4)汉明码各位之间的关系，即：

ss(2):=a(6) xor a(5) xor a(4) xor a(2);

ss(1):=a(6) xor a(5) xor a(3) xor a(1);

ss(0):=a(6) xor a(4) xor a(3) xor a(0);

第三，要判定校正子与0的关系，使用if语句，若等于0，则表示没有错误；若不为0，则表示其中有一位出错。根据表2-2，可以得到校正子S与错误图样E之间的关系，才用case语句，编写程序如下：

when "001" =>bb(0):= not bb(0);c<="000";

when "010" =>bb(1):= not bb(1);c<="001";

when "100" =>bb(2):=not bb(2);c<="010";

when "011" =>bb(3):=not bb(3);c<="011";

when "101" =>bb(4):=not bb(4);c<="100";

when "110" =>bb(5):=not bb(5);c<="101";

when "111" =>bb(6):=not bb(6);c<="110";

上述程序中，bb是变量，存放的是输入7位汉明码a6a5a4a3a2a1a0，

当S="001"，时，表示a0出错，则只需将这一位的值取反，然后再送给输出。a1、a2、a3、a4、a5、a6出错的原理也是一样的。

最后，将没有错误的(7,4)汉明码或已经纠正1个错误的(7,4)汉明码输出，这样译码程序就完成了。

为了方便阅读波形，加入输出了校正子S和错误位数C。若第0位（a0）出错，则C输出0，依次类推；若无错，则输出7。

第4章 编译程序的调试与分析 4.1  (7,4)汉明码的编码程序调试与分析 
 

4.1.1 (7,4)汉明码的编码程序的编译 
按照上述编码程序的编写思路，编写好程序，点击，进行编译，出现一些错误，如下：

Error 1: VHDL error at ym.vhd(3): object "std_logic_vector" is used but not declared

Error 2: VHDL error at bm.vhd(7): entity "bm" is used but not declared

Error 1表明在使用"std_logic_vector"时，没有打开可以使用这个函数的库，应该在程序的最前面加上如下语句：

library ieee;

use ieee.std_logic_1164.all;

Error 2表明程序中的文件名与保存时的文件名不一致，两者应该相同。

排除上述错误后，就可以进行波形仿真了。

 

4.1.2 (7,4)汉明码的编码程序的仿真分析 
建好波形文件，设置好输入信息码a3a2a1a0的初始值，点击，进行波形仿真,出现如下波形：



图4.1(7,4)汉明码的编码仿真波形

从波形中，可以看出输入信息0000～1111，对应的编码情况。对照表2-1 ，可以确定(7,4)汉明码的编码程序完全正确，编码成功。

 

 

4.2  (7,4)汉明码的编译码程序分析及调试 
 

4.2.1 (7,4)汉明码的译码程序的编译 
按照上述译码程序的编写思路，编写好程序，点击，进行编译，出现一些错误，如下：

Error 1: VHDL syntax error at ym.vhd(12) near text "variable";  expecting "end", or "(", or an identifier ("variable" is a reserved keyword), or a sequential statement,

Error 2: VHDL Case Statement error at ym.vhd(19): Case Statement choices must cover all possible values of expression

Error 1表明"variable"变量定义的位置有误。变量的定义一定要放在process(a)之后，begin之前。

Error 2表明case语句使用有误。使用case语句时，必须列出它的所有可能值，或者列出部分值，然后使用when others =>语句即可。

改正上述错误，就可以对其进行波形仿真了。

 

4.2.2 (7,4)汉明码的译码程序的仿真分析 
建好波形文件，设置好输入(7,4)汉明码a6a5a4a3a2a1a0的初始值，点击，进行波形仿真, 出现如下波形：



图4.2(7,4)汉明码的译码仿真波形1

由于设置的分别是a0、a1、a2、a3、a4、a5、a6出错，从波形上就可以清楚的看出该程序存在一定的问题，虽然没有语法错误，但存在着逻辑错误。

由波形可知：a0出错时的校正子S为100，a1出错时的校正子S为010，

a2出错时的校正子S为001，a3出错时的校正子S为110，

a4出错时的校正子S为101，a5出错时的校正子S为011，

a6出错时的校正子S为111。

而根据表2-2可知：

a0出错时的校正子S为100，a1出错时的校正子S为010，

a2出错时的校正子S为100，a3出错时的校正子S为011，

a4出错时的校正子S为101，a5出错时的校正子S为110，

a6出错时的校正子S为111。

由此可以推断是校正子S的高低位搞错了，仔细查看程序，发现的确是这个问题，改正后，编译仿真的以下波形：



图4.3(7,4)汉明码的译码仿真波形2

对照表2-2，仔细观察波形，可以确定波形没有问题，这样，(7,4)汉明码的译码程序就完全正确了，译码成功。

参考文献 
 

[1] 辛春艳.VHDL硬件描述语言[M].北京：国防工业出版社，2002．

[2] 侯伯亨，顾新.VHDL硬件描述语言与数字逻辑电路设计[M].西安：西安电子科技大学出版社，2002。

[3] 金西．VHDL与复杂数字系统设计[M]．西安：西安电子科技大学出版社，2003.   

体会与建议 
 

为期一周的课程设计就这么结束了，忙碌而又辛劳，但是却让我学到了许多东西，为不久的将来走上工作岗位打下了一定的基础。

一开始老师给我们布置了题目——(7,4)汉明码的编解码器的设计。拿到题目，我们非常着急，以为这个题目很难，象一只没头的苍蝇，我们开始乱钻，最后，一头扎进了图书馆，借了好几本书。来仔细的翻看了通信原理的书和笔记，对(7,4)汉明码的一些基本概念有了进一步的会议。突然发现这个课题其实一点也不难，一点技术含量都没有，似乎一个人也可以完成的。仔细阅读了(7,4)汉明码的原理以后，我就开始构思程序的编写，准备画流程图。其实编译码的思路非常清晰，流程图很快就画好了。接下来就是程序的编写，由于好久没有使用VHDL语言，有好多语句都遗忘了，于是翻出以前EDA的书和笔记，认真的看了几遍，对一些语句的用法和使用时的注意事项有了一个大概的了解。然后就开始编程序。编码程序比较简单，只有十几行，仅半个小时，编码程序就编好了，并且运行正确了，是心里就踏实了很多。接下来的译码程序也比较简单，半小时就编好了程序，但是却遇到了一个问题——编译没有错误，但是仿真波形却不对，很郁闷，很疑惑，找了半天也没有发现问题。后来仔细的观察了仿真波形，才发现问题所在——校正子的高低位弄错了。

一周的课程设计结束了，让我收益颇丰。通过这次的课程设计，我对VHDL语言有了新的认识，掌握了用VHDL语言编程的方法，并且能够熟练的运用它去编写各种各样的程序，它为以后能够从事这方面的工作提供了一定的基础。在掌握VHDL语言的基础上，进一步理解了(7,4)汉明码的编解码原理以及一些重要的公式。

最后，我想提一点建议，希望老师以后可以尽可能的让我们一人一组。题目虽然有些难度，但是可以更好的锻炼自己，充分发挥个人潜能，同时也杜绝了一些同学光看别人做，等着别人的成果，到时再熟悉程序就可以蒙混过关的现象。

附  录 
 

(7,4)汉明码的编码程序：

library ieee;

use ieee.std_logic_1164.all;

entity bm is

port(a:in std_logic_vector(3 downto 0);

     b:out std_logic_vector(6 downto 0));

end ;

architecture one of bm is

begin

b(6)<=a(3);

b(5)<=a(2);

b(4)<=a(1);

b(3)<=a(0);

b(2)<=a(3) xor a(2) xor a(1);

b(1)<=a(3) xor a(2) xor a(0);

b(0)<=a(3) xor a(1) xor a(0);

end;

 

(7,4)汉明码的译码程序：

library ieee;

use ieee.std_logic_1164.all;

entity ym is

port(a:in std_logic_vector(6 downto 0);

     s:out std_logic_vector(2 downto 0);

     b:out std_logic_vector(3 downto 0);

     c:out std_logic_vector(2 downto 0));

end ;

architecture one of ym is

begin

process(a)

variable ss:std_logic_vector(2 downto 0);

variable bb:std_logic_vector(6 downto 0);

begin

ss(2):=a(6) xor a(5) xor a(4) xor a(2);

ss(1):=a(6) xor a(5) xor a(3) xor a(1);

ss(0):=a(6) xor a(4) xor a(3) xor a(0);

bb:=a;

if ss> "000"   then

case ss is

when "001" =>bb(0):= not bb(0);c<="000";

when "010" =>bb(1):= not bb(1);c<="001";

when "100" =>bb(2):=not bb(2);c<="010";

when "011" =>bb(3):=not bb(3);c<="011";

when "101" =>bb(4):=not bb(4);c<="100";

when "110" =>bb(5):=not bb(5);c<="101";

when "111" =>bb(6):=not bb(6);c<="110";

when others => null;c<="111";

end case;

else b<= a(6)&a(5)&a(4)&a(3);

end if;

s<=ss;

b<=bb(6)&bb(5)&bb(4)&bb(3);

end process;

end;
 

[返回上页] [打印此页] [查看参与评论 ] [关闭]  

上篇文章: 485总线编程要点 
下篇文章: ARM温室大棚设计系统方案 相关文章 
没有相关文章  
  
推 荐 阅 读  
绘芯3.5寸人机界面绘芯5.6寸人机界面使用手册绘芯电磁屏蔽工业显示器外观质.绘芯镀膜屏蔽显示器简介绘芯5.7寸人机界面使用手册绘芯9.7寸人机界面使用手册关于2013年元旦及春节放假安排.8寸人机界面用户手册19寸专业级工业显示器说明书（.12.1寸人机界面使用手册  

阅 读 排 行  
DB15的引脚定义及线序
八度音阶和频率的关系
基于单片机的彩灯设计
DS18B20温度检测系统
基于超声波汽车防撞报警系统
数字电子秤设计
液晶屏的结构解析
曼彻斯特码编码解码方案
电子密码锁设计与制作
基于SOPC的电子钟设计与实现 
 

专 题 列 表 
绘芯人机界面应用完全教程  

 

联系我们 技术支持 返回顶部

◇ 武汉绘芯科技专营人机界面,工业液晶显示器,工业显示器,绘芯人机界面,单片机人机界面,专业人机界面,串口显示器,单片机显示器,PS2/USB单片机键盘,工业PC,平板电脑等

◇ 友情链接：人机界面|人机界面管理专家|工业显示器|工业液晶显示器|电子设计|串口显示器|军用显示器|串口智能显示终端|单片机显示器|智能显示器|高速人机界面

◇ 联系地址:武汉·光谷藏龙岛九凤街谭湖一路8号 2-2单元-206 联系电话：027-8705 2087, 传真:027-5925 3307, 24小时服务电话：13329706647 QQ：956693667 
--------------------------------------------------------------------------------------------乘 车 路 线----------------------------------------------------------------------------------- 
◇ 718（758，738）等公交车到光谷大道刘张湾下车->前行约100m至前方十字路口,过马路右拐（可见百度百捷大楼）->前行约500m,到谭湖一路路口，沿谭湖一路往前走约500m，看见光谷8号大楼，靠门口第一个单元（楼下大厅墙上有绘芯的标牌）上楼至 2栋2单元206室，武汉绘芯科技有限公司。详情请看“乘车路线”。 
--------------------------------------------------------------------------------------------版 权 所 有----------------------------------------------------------------------------------- 
版权所有: 武汉绘芯科技有限公司 copyright; 2010-2015 武汉绘芯科技有限公司网络服务部 Corporation 　　　　　网站备案号：鄂ICP备09000207号-2　　 
-----------------------------------------------------------------------------------------------广 告 位------------------------------------------------------------------------------------- 


-
　 
-
-


基于Asp Cms架构 网站模板　 
