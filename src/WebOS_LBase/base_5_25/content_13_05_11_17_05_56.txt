
您还未登录！|登录|注册|帮助
 首页
 业界
 移动
 云计算
 研发
 论坛
 博客
 下载
 
更多
 







结构之法 算法之道

Google或baidu搜索：“结构之法”，进入本博客


 


目录视图
摘要视图
订阅
 . 



【免费有礼】欧美最新网络营销技巧分享        博客导入工具      【限时优惠】第五届云计算大会社区门票抢购 
探究云计算数据中心节能增效之道      专访邓凡平：Android开发路上的快速学习之道      CSDN博客第二期最佳移动开发博主评选 



程序员编程艺术：第七章、求连续子数组的最大和 
.
 分类： 13.TAOPP array11.TAOPP（编程艺术）2011-05-25 01:3027270人阅读评论(140)收藏举报
 
编程algorithm算法面试磁盘微软

 
 程序员编程艺术：第七章、求连续子数组的最大和 
 
作者：July。
出处：http://blog.csdn.net/v_JULY_v 。
 

前奏
 •希望更多的人能和我一样，把本狂想曲系列中的任何一道面试题当做一道简单的编程题或一个实质性的问题来看待，在阅读本狂想曲系列的过程中，希望你能尽量暂时放下所有有关面试的一切包袱，潜心攻克每一道“编程题”，在解决编程题的过程中，好好享受编程带来的无限乐趣，与思考带来的无限激情。--By @July_____。
 •原狂想曲系列已更名为：程序员编程艺术系列。原狂想曲创作组更名为编程艺术室。编程艺术室致力于以下三点工作：1、针对一个问题，不断寻找更高效的算法，并予以编程实现。2、解决实际中会碰到的应用问题，如第十章、如何给10^7个数据量的磁盘文件排序。3、经典算法的研究与实现。总体突出一点：编程，如何高效的编程解决实际问题。欢迎有志者加入。
 

第一节、求子数组的最大和
3.求子数组的最大和
题目描述：
输入一个整形数组，数组里有正数也有负数。
数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。
求所有子数组的和的最大值。要求时间复杂度为O(n)。
 
例如输入的数组为1, -2, 3, 10, -4, 7, 2, -5，和最大的子数组为3, 10, -4, 7, 2，
因此输出为该子数组的和18。
 
分析：这个问题在各大公司面试中出现频率之频繁，被人引用次数之多，非一般面试题可与之匹敌。单凭这点，就没有理由不入选狂想曲系列中了。此题曾作为本人之前整理的微软100题中的第3题，至今反响也很大。ok，下面，咱们来一步一步分析这个题：
      1、求一个数组的最大子数组和，如此序列1, -2, 3, 10, -4, 7, 2, -5，我想最最直观也是最野蛮的办法便是，三个for循环三层遍历，求出数组中每一个子数组的和，最终求出这些子数组的最大的一个值。
记Sum[i, …, j]为数组A中第i个元素到第j个元素的和（其中0 <= i <= j < n），遍历所有可能的Sum[i, …, j]，那么时间复杂度为O（N^3）：
 

//本段代码引自编程之美
int MaxSum(int* A, int n)
{
 int maximum = -INF; 
 int sum=0;   
 for(int i = 0; i < n; i++)
 {
  for(int j = i; j < n; j++)
  {
   for(int k = i; k <= j; k++)
   {
    sum += A[k];
   }
   if(sum > maximum)
    maximum = sum;
 
   sum=0;   //这里要记得清零，否则的话sum最终存放的是所有子数组的和。也就是编程之美上所说的bug。多谢苍狼。
  }
 }
 return maximum;
} 
 
      2、其实这个问题，在我之前上传的微软100题，答案V0.2版[第1-20题答案]，便直接给出了以下O（N）的算法：



01.//copyright@ July 2010/10/18  
02.//updated，2011.05.25.  
03.#include <iostream.h>  
04.  
05.int maxSum(int* a, int n)  
06.{  
07.    int sum=0;  
08.    //其实要处理全是负数的情况，很简单，如稍后下面第3点所见，直接把这句改成："int sum=a[0]"即可  
09.    //也可以不改，当全是负数的情况，直接返回0，也不见得不行。  
10.    int b=0;  
11.      
12.    for(int i=0; i<n; i++)  
13.    {  
14.        if(b<0)           //...  
15.            b=a[i];  
16.        else  
17.            b+=a[i];  
18.        if(sum<b)  
19.            sum=b;  
20.    }  
21.    return sum;  
22.}  
23.  
24.int main()  
25.{  
26.    int a[10]={1, -2, 3, 10, -4, 7, 2, -5};  
27.    //int a[]={-1,-2,-3,-4};  //测试全是负数的用例  
28.    cout<<maxSum(a,8)<<endl;  
29.    return 0;  
30.}  
31.  
32./*------------------------------------- 
33.解释下： 
34.例如输入的数组为1, -2, 3, 10, -4, 7, 2, -5， 
35.那么最大的子数组为3, 10, -4, 7, 2， 
36.因此输出为该子数组的和18。 
37. 
38.所有的东西都在以下俩行， 
39.即： 
40.b  ：  0  1  -1  3  13   9  16  18  13   
41.sum：  0  1   1  3  13  13  16  18  18 
42.   
43.其实算法很简单，当前面的几个数，加起来后，b<0后， 
44.把b重新赋值，置为下一个元素，b=a[i]。 
45.当b>sum，则更新sum=b; 
46.若b<sum，则sum保持原值，不更新。。July、10/31。 
47.----------------------------------*/  
 

      3、不少朋友看到上面的答案之后，认为上述思路2的代码，没有处理全是负数的情况，当全是负数的情况时，我们可以让程序返回0，也可以让其返回最大的那个负数，下面便是前几日重写的，修改后的处理全是负数情况（返回最大的负数）的代码：
 




01.//copyright@ July  
02.//July、updated，2011.05.25。  
03.#include <iostream.h>  
04.#define n 4           //多定义了一个变量  
05.  
06.int maxsum(int a[n])    
07.//于此处，你能看到上述思路2代码（指针）的优势  
08.{  
09.    int max=a[0];       //全负情况，返回最大数  
10.    int sum=0;  
11.    for(int j=0;j<n;j++)  
12.    {  
13.        if(sum>=0)     //如果加上某个元素，sum>=0的话，就加  
14.            sum+=a[j];  
15.        else     
16.            sum=a[j];  //如果加上某个元素，sum<0了，就不加  
17.        if(sum>max)  
18.            max=sum;  
19.    }  
20.    return max;  
21.}  
22.  
23.int main()  
24.{  
25.    int a[]={-1,-2,-3,-4};  
26.    cout<<maxsum(a)<<endl;  
27.    return 0;  
28.}  

 
      4、DP解法的具体方程：@ flyinghearts：设sum[i] 为前i个元素中，包含第i个元素且和最大的连续子数组，result 为已找到的子数组中和最大的。对第i+1个元素有两种选择：做为新子数组的第一个元素、放入前面找到的子数组。
sum[i+1] = max(a[i+1], sum[i] + a[i+1])
result = max(result, sum[i])
 
 
扩展：
1、如果数组是二维数组，同样要你求最大子数组的和列?
2、如果是要你求子数组的最大乘积列?
3、如果同时要求输出子段的开始和结束列?
 
 
 
第二节、Data structures and Algorithm analysis in C
 
下面给出《Data structures and Algorithm analysis in C》中4种实现。
 




01.//感谢网友firo  
02.//July、2010.06.05。  
03.  
04.//Algorithm 1:时间效率为O(n*n*n)  
05.int MaxSubsequenceSum1(const int A[],int N)  
06.{  
07.    int ThisSum=0 ,MaxSum=0,i,j,k;  
08.    for(i=0;i<N;i++)  
09.        for(j=i;j<N;j++)  
10.        {  
11.            ThisSum=0;  
12.            for(k=i;k<j;k++)  
13.                ThisSum+=A[k];  
14.              
15.            if(ThisSum>MaxSum)  
16.                MaxSum=ThisSum;  
17.        }  
18.        return MaxSum;  
19.}  
20.  
21.//Algorithm 2:时间效率为O(n*n)  
22.int MaxSubsequenceSum2(const int A[],int N)  
23.{  
24.    int ThisSum=0,MaxSum=0,i,j,k;  
25.    for(i=0;i<N;i++)  
26.    {  
27.        ThisSum=0;  
28.        for(j=i;j<N;j++)  
29.        {  
30.            ThisSum+=A[j];  
31.            if(ThisSum>MaxSum)  
32.                MaxSum=ThisSum;  
33.        }  
34.    }  
35.    return MaxSum;  
36.}  
37.  
38.//Algorithm 3:时间效率为O(n*log n)  
39.//算法3的主要思想：采用二分策略，将序列分成左右两份。  
40.//那么最长子序列有三种可能出现的情况，即  
41.//【1】只出现在左部分.  
42.//【2】只出现在右部分。  
43.//【3】出现在中间，同时涉及到左右两部分。  
44.//分情况讨论之。  
45.static int MaxSubSum(const int A[],int Left,int Right)  
46.{  
47.    int MaxLeftSum,MaxRightSum;              //左、右部分最大连续子序列值。对应情况【1】、【2】  
48.    int MaxLeftBorderSum,MaxRightBorderSum;  //从中间分别到左右两侧的最大连续子序列值，对应case【3】。  
49.    int LeftBorderSum,RightBorderSum;  
50.    int Center,i;  
51.    if(Left == Right)Base Case  
52.        if(A[Left]>0)  
53.            return A[Left];  
54.        else  
55.            return 0;  
56.        Center=(Left+Right)/2;  
57.        MaxLeftSum=MaxSubSum(A,Left,Center);  
58.        MaxRightSum=MaxSubSum(A,Center+1,Right);  
59.        MaxLeftBorderSum=0;  
60.        LeftBorderSum=0;  
61.        for(i=Center;i>=Left;i--)  
62.        {  
63.            LeftBorderSum+=A[i];  
64.            if(LeftBorderSum>MaxLeftBorderSum)  
65.                MaxLeftBorderSum=LeftBorderSum;  
66.        }  
67.        MaxRightBorderSum=0;  
68.        RightBorderSum=0;  
69.        for(i=Center+1;i<=Right;i++)  
70.        {  
71.            RightBorderSum+=A[i];  
72.            if(RightBorderSum>MaxRightBorderSum)  
73.                MaxRightBorderSum=RightBorderSum;  
74.        }  
75.        int max1=MaxLeftSum>MaxRightSum?MaxLeftSum:MaxRightSum;  
76.        int max2=MaxLeftBorderSum+MaxRightBorderSum;  
77.        return max1>max2?max1:max2;  
78.}  
79.  
80.//Algorithm 4:时间效率为O(n)  
81.//同上述第一节中的思路3、和4。  
82.int MaxSubsequenceSum(const int A[],int N)  
83.{  
84.    int ThisSum,MaxSum,j;  
85.    ThisSum=MaxSum=0;  
86.    for(j=0;j<N;j++)  
87.    {  
88.        ThisSum+=A[j];  
89.        if(ThisSum>MaxSum)  
90.            MaxSum=ThisSum;  
91.        else if(ThisSum<0)  
92.            ThisSum=0;  
93.    }  
94.    return MaxSum;  
95.}   
  
 
本章完。 
3.3续、求给定区间内的第K小（大）元素 第九章、闲话链表追赶问题 第十章、如何给10^7个数据量的磁盘文件排序 
--------------------------------------------------------------------------------

版权所有，本人对本blog内所有任何内容享有版权及著作权。实要转载，请以链接形式注明出处。
 
 
 
分享到： 

下一篇：算法面试：精选微软经典的算法面试100题（第1-20题）
 . 


查看评论
 
90楼 woyaoying 3天前 19:55发表[回复] 最后一个算法，不能适用于全是负数的情况，请楼主标注，谢谢。Re: v_JULY_v 前天 22:52发表[回复] 回复woyaoying：你说的是下段代码么？




01.//copyright@ July    
02.//July、updated，2011.05.25。    
03.#include <iostream.h>    
04.#define n 4           //多定义了一个变量    
05.    
06.int maxsum(int a[n])      
07.//于此处，你能看到上述思路2代码（指针）的优势    
08.{    
09.    int max=a[0];       //全负情况，返回最大数    
10.    int sum=0;    
11.    for(int j=0;j<n;j++)    
12.    {    
13.        if(sum>=0)     //如果加上某个元素，sum>=0的话，就加    
14.            sum+=a[j];    
15.        else       
16.            sum=a[j];  //如果加上某个元素，sum<0了，就不加    
17.        if(sum>max)    
18.            max=sum;    
19.    }    
20.    return max;    
21.}    
22.    
23.int main()    
24.{    
25.    int a[]={-1,-2,-3,-4};    
26.    cout<<maxsum(a)<<endl;    
27.    return 0;    
28.}    
Re: woyaoying 前天 13:41发表[回复] 回复v_JULY_v：抱歉，我没说清楚，是这段代码：
//Algorithm 4:时间效率为O(n) 
//同上述第一节中的思路3、和4。 
int MaxSubsequenceSum(const int A[],int N) 
{ 
int ThisSum,MaxSum,j; 
ThisSum=MaxSum=0; 
for(j=0;j<N;j++) 
{ 
ThisSum+=A[j]; 
if(ThisSum>MaxSum) 
MaxSum=ThisSum; 
else if(ThisSum<0) 
ThisSum=0; 
} 
return MaxSum; 
} 

先加后判断，全负情况就不能适用了。89楼 liuxp1988 2013-03-14 10:13发表[回复] 嗯，试了下，是我看错了，下面有个if(sum<b) sum = b的判断，这样就对了。88楼 liuxp1988 2013-03-14 09:59发表[回复] 博主分析的很精彩，但楼主写的这个算法应该有些问题（仅仅单向扫描是不行的），请看看对于这个数组适用不？
100， 101， -300，1， 2， 3， 4
按照博主的写法应该返回的是10，而不是201。。。87楼 ynwlgh 2013-02-21 17:02发表[回复] 



01./* 
02.思路: 
03.此题可以用看作求曲线y=F(x)上的区间(a<=x<=b)上的面积的离散形式. 
04. 
05.设面积为S=∫<ab> F(x).函数在a到b区间上的积分. 
06.显然,当积分函数区间a和b,分别取最小值和最大值时,面积最大. 
07.*/  
08.  
09.    #include "stdafx.h"  
10.    int _tmain(int argc, _TCHAR* argv[])  
11.    {  
12.        const int num[8]={1, -2, 3, 10, -4, 7, 2, -5};  
13.        int len= sizeof(num) / sizeof(int);  
14.  
15.        int min=num[0];//保存最小的那个  
16.        int max=min;   //最大的  
17.  
18.  
19.  
20.        int sum=0;      //积分值  
21.        for (int j=0;j<len;++j)  
22.        {  
23.            sum+=num[j];  
24.  
25.            if (sum<min)  
26.                min=sum;  
27.            if (sum>max)  
28.                max=sum;  
29.        }  
30.  
31.  
32.        printf("最大子数组的和为 : %d\n",max-min);  
33.  
34.        return 0;  
35.    }  
86楼 kopscript 2013-01-28 01:59发表[回复] 你的解法就是DP。。你不觉得？85楼 CSForCser 2012-12-23 19:33发表[回复] 
引用“ckdtc3699”的评论：支持楼主！dp方法没有编码实现啊

DP
int maxSum(int *arr, int length){
 int sum = 0,result = 0;
 for(int i = 0; i < length; i++){
 sum = sum + arr[i] > arr[i] ? sum + arr[i]:arr[i];
 result = sum > result ? sum : result;
 }
 return result;
}84楼 ckdtc3699 2012-07-19 09:00发表[回复] 支持楼主！dp方法没有编码实现啊Re: xiaoyanilw 2013-01-05 15:47发表[回复] 回复ckdtc3699：dp无敌了，太精炼了！83楼 jy00272082 2012-07-13 06:23发表[回复] 关于求最大子数组和的问题我有一个想法，求大家验证一下，时间复杂度是O(n)+O(n)=O(n), 空间复杂度是O(N). 思路如下：先申请一个长度为N的数组，其中每一个位置都记录了在原数组中这个位置极其以后的和，例如：
原数组：1 -2 3 10 -4 7 2 -5
新数组: -9 11 13 10 0 4 -3 -5
这个数组的生成可以从后向前扫描，需要O(N)
然后再这个新数组中从前开始扫描，先找到最大的值，此例中是13 对应原数组中3的位置，然后再在13的后面找到最小的值，此例中是-5，对应原数组-5的位置，那么这个拥有最大和的子数组就是这之间的数组，对应原数组中3到2. 这次遍历也是O(n)，所以总共是O(N).
需要注意的是：
1 一定是在找到最大的位置之后，再其后面找最小的位置
2 找到最小的位置后，那个位置上的数是不被包含在我们的子数组中的Re: java_4_ever 2013-03-22 15:59发表[回复] 回复jy00272082：这种办法有问题，对于{ 100, 101, -300, 1, 2, 3, 4 }得到的结果是10，而非201.
求和得到的结果是：{-89, -189, -290, 10, 9, 7, 4}.Re: v_JULY_v 2012-07-13 10:34发表[回复] 回复jy00272082：你这个思路跟本文第一个轮询的思路其实并无二致，只是轮询的复杂度为O（N^3），而你每遍历一个元素，都要扫描此元素之后的数组剩下的元素，这个复杂度已经有O（N^2）了Re: jy00272082 2012-07-14 03:22发表[回复] 回复v_JULY_v：不需要扫描后面的元素啊，你从原数组a[]的最后向前扫描，新数组b[]中的每一项都为：
b[i-1]=a[i-1]+b[i]这样只需O(N)的复制度就可以求出b[]数组了。
然后再b数组中也只需遍历一次即可找到最大的，然后再从其后面找出最小的, 所以不会产生指数级的复杂度的Re: v_JULY_v 2012-07-14 09:05发表[回复] 回复jy00272082：“从原数组a[]的最后向前扫描，新数组b[]中的每一项都为：
b[i-1]=a[i-1]+b这样只需O(N)的复制度就可以求出b[]数组了。”
Sorry，之前看错了，看成了从前往后扫描，既然是从后向前扫描生成新数组求得相应的和值的话，那么时间复杂度O（N）就没有问题了，不错。
不过，本文所列的第2、3个思路，时间 O(N)& 空间O(1)。而你的思路虽然时间O(N)&空间O(N)非最优，还是不错的。82楼 xiaowaiwaia 2012-05-13 21:03发表[回复] int MaxSum(int* str,int n)
{
 int sum=0;
 int maxsum=-1;
 for(int i=0;i<n;i++)
 {
 for(int j=i;j<n;j++)
 {
 sum+=str[j];
 if(maxsum<sum)
 maxsum=sum;
 }
 sum=0;
 }
 return maxsum;

}
如上，第一种思路二层循环就可以遍历所有子串，为什么要用三层循环呢？？81楼 waytofall 2012-04-10 20:13发表[回复] 后来在《编程珠玑》中看到了对此种算法的解释，实际上，编程珠玑中对于sum小于0后舍弃的定义如下：

maxendinghere = max(maxendinghere, 0)

这里的maxendinghere就是网上常见算法的sum，其意义是以当前元素为结尾的最长字段的长度。

我们可以看到，这其实是一个动态规划解法，最优子结构可以归纳为：

　　a[0] = max(a[0], 0)

　　a[i] = max(a[i - 1] + a[i], 0)

即如果当前元素加上以前一个元素为结尾的子段和小于0，就把以当前元素为结尾的子段和设为0。实际上这个“子段”是一个空段。我不知道为什么非要区分0和非零，可能是在这道题里“小于0的元素会让整个子段值变小”这个概念很显眼吧，但是这种情况确实忽略如果所有输入为负数的情况，虽然题目假设输入有正有负。

于是我试图改变最优子结构的构造，抛弃0的概念，定义为：

　　a[0] = a[0]

　　a[i] = max(a[i - 1] + a[i], a[i])

这样看起来比较直观，而且“以元素a[i]为结尾的最大子段和”就不会是一个空子段了。

这种规划方法我不知道是否有什么错误，看起来没什么问题，我实现了一下。可以参照我的博客http://www.cnblogs.com/waytofall/archive/2012/04/10/2441185.html

大家是否可以就这个问题讨论下80楼 waytofall 2012-04-10 01:08发表[回复] 
引用“waytofall”的评论：这个算法如此精炼简单，而且复杂度只有线性。但是我想，能想出来却非常困难，而且证明也不简单。在这里，我...[/quote]
有一处
[quote=waytofall]
所以这些子段的和是小于当前子段的，也就是小于1的，对于后面也是需要抛弃的。

1应该是079楼 waytofall 2012-04-10 01:04发表[回复] 这个算法如此精炼简单，而且复杂度只有线性。但是我想，能想出来却非常困难，而且证明也不简单。在这里，我斗胆写出自己证明的想法：

关于这道题的证明，我的思路是去证明这样的扫描法包含了所有n^2种情况，即所有未显示列出的子数组都可以在本题的扫描过程中被抛弃。

1 首先，假设算法扫描到某个地方时，始终未出现加和小于等于0的情况。

我们可以把所有子数组（实际上为当前扫描过的元素所组成的子数组）列为三种：

1.1 以开头元素为开头，结尾为任一的子数组

1.2 以结尾元素为结尾，开头为任一的子数组

1.3 开头和结尾都不等于当前开头结尾的所有子数组

1.1由于遍历过程中已经扫描，所以算法已经考虑了。1.2确实没考虑，但我们随便找到1.2中的某一个数组，可知，从开头元素到这个1.2中的数组的加和大于0（因为如果小于0就说明扫描过程中遇到小于0的情况，不包括在大前提1之内），那么这个和一定小于从开头到这个1.2数组结尾的和。故此种情况可舍弃

1.3 可以以1.2同样的方法证明，因为我们的结尾已经列举了所有的情况，那么每一种情况和1.2是相同的，故也可以舍弃。

2 如果当前加和出现小于等于0的情况，且是第一次出现，可知前面所有的情况加和都不为0

一个很直观的结论是，如果子段和小于0，我们可以抛弃，但问题是是不是他的所有以此子段结尾为结尾而开头任意的子段也需要抛弃呢？

答案是肯定的。因为以此子段开头为开头而结尾任意的子段加和都大于0（情况2的前提），所以这些子段的和是小于当前子段的，也就是小于1的，对于后面也是需要抛弃的。也就是说，所有以之前的所有元素为开头而以当前结尾之后元素为结尾的数组都可以抛弃了。

而对于后面抛弃后的数组，则可以同样递归地用1 2两个大情况进行分析，于是得证。

这个算法的证明有些复杂，现在感觉应该不会错，至少思路是对的，谁帮着在表达上优化下吧。:-)78楼 wangyangkobe 2011-11-18 13:13发表[回复] 



01.int MaxSum(int arr[], int n)  
02.{  
03.    int res = INT_MIN;  
04.    int sum = 0;  
05.      
06.    for (int i = 0; i < n; ++i)  
07.    {  
08.        sum += arr[i];  
09.        if (sum <= 0)  
10.        {  
11.            sum = 0;  
12.        }  
13.  
14.        if (sum >= res)  
15.        {  
16.            res = sum;  
17.        }  
18.    }  
19.    return res;  
20.}  
77楼 nic122333 2011-11-15 16:47发表[回复] 看的了觉得有点问题，不知是我没理解到位还是博主写的有问题，下面贴些片段：




01.for(int j = i; j < n; j++)  
02. {  
03.  for(int k = i; k <= j; k++)  
04.  {  
05.   sum += A[k];  
06.  }  
07.  if(sum > maximum)  
08.   maximum = sum;  
09.  
10.  sum=0;   //这里要记得清零，否则的话sum最终存放的是所有子数组的和。也就是编程之美上所说的bug。多谢苍狼。  

个人认为 
sum=0;
这句应该放在
for(int j = i; j < n; j++)
 {
之后。76楼 maoxing63570 2011-08-22 22:29发表[回复] 只看过利用分治的思想来做75楼 chong_boy 2011-06-10 11:40发表[回复] 在ACM中,这题只是水题.Re: v_JULY_v 2011-06-10 12:10发表[回复] 回复 chong_boy：[e03]74楼 hmhao123 2011-06-09 23:56发表[回复] int MaxSub(int ar[],int n)
{
 int ret=0;
 int endinghere=0;73楼 Selena 2011-06-08 13:02发表[回复] [e01]收藏了！！！72楼 magic_han 2011-06-06 22:56发表[回复] 来看看，路过71楼 magic_han 2011-06-06 22:56发表[回复] ....计算机科学啊70楼 peng520mike 2011-06-06 19:06发表[回复] 算法是学计算机专业必须的么？
我怎么觉得好难相处来呀！[e01]Re: v_JULY_v 2011-06-06 19:44发表[回复] 回复 peng520mike：数据结构才是计算机专业必须。算法，可学，可不学。69楼 v_JULY_v 2011-06-05 20:08发表[回复] 补上了Data structures and Algorithm analysis in C中4种实现。68楼 buyueliuying 2011-06-05 09:11发表[回复] int maximum = -INF; //这句里面的“-INF”是什么意思？？67楼 RaceBug2010 2011-06-04 10:48发表[回复] 这个是ACM/ICPC里面最简单的题了Re: v_JULY_v 2011-06-05 18:07发表[回复] 回复 RaceBug2010：[e03]66楼 amblue 2011-06-03 17:29发表[回复] 动态规划算法，思路还是很清楚的：
遍历数组a[]，用一个变量cur_max(i)表示以当前a[i]为结尾的最大子数组和，那么
cur_max(i) = max { cur_max(i)+a[i], a[i]}
同时用一个变量ret记录cur_max从0到n的最大值即可65楼 zdnexus 2011-06-03 13:48发表[回复] C语言还没有学完呢。。LZ的面试题目我都收藏了的、、以后有什么问题还要向LZ请教。Re: v_JULY_v 2011-06-05 18:06发表[回复] 回复 zdnexus：[e03]64楼 rwjlqn 2011-06-03 11:54发表[回复] [e01]
此题用一个for循环可以实现，两个for亦可以实现，三个for也能实现。从头开始看的时候发现楼主用了三个for循环，但是我纳闷为何三个for，我试着用两个for循环去实现了它。继续往下看发现楼主用了一个for，此时我才恍然大悟，原来我差点绕进去~[e01]63楼 lihuaib 2011-06-02 21:56发表[回复] 不就是acm 的dp 吗，题目太吸引人了，就过来看了下！acm.hdu.edu.cn上都有啊！Re: v_JULY_v 2011-06-02 22:41发表[回复] 回复 lishujie911：yeah，[e03]62楼 cqalice 2011-06-02 15:36发表[回复] 之间有看C方面的书的嘛，这上面写得够详细了，结果，还是有眯糊涂了……61楼 蜡笔小龙 2011-06-02 11:00发表[回复] 得算法者的天下呀~哈哈~60楼 PilyWang 2011-06-02 10:49发表[回复] 发现自己很喜欢你的空间。谢谢你的好文章。学习学习&#183;&#183;&#183;呵呵&#183;&#183;&#183;多多指教哦[e01][e01][e03][e03]Re: v_JULY_v 2011-06-02 11:18发表[回复] 回复 PilyWang：[e10]59楼 pj603084113 2011-06-02 08:25发表[回复] 谢谢 [e03]58楼 goingstudy 2011-06-02 00:18发表[回复] 以前上算法课时，老师说DP是解决含有子问题重叠的，并且关键是要找出最优解的结构，LZ能否就个人的经验讲一下DP算法的设计思路(j就是怎样想到的）？57楼 goingstudy 2011-06-02 00:12发表[回复] 以前上算法课时，老师说dp是解决有子问题重叠的，并且关键是要找出最优解的结构，lz能否就个人的经验讲一下dp算法的设计阿？56楼 goingstudy 2011-06-02 00:17发表[回复] 以前上算法课时，老师说DP是解决含有子问题重叠的，并且关键是要找出最优解的结构，LZ能否就个人的经验讲一下DP算法的设计思路(j就是怎样想到的）？55楼 goingstudy 2011-06-02 00:17发表[回复] 以前上算法课时，老师说DP是解决含有子问题重叠的，并且关键是要找出最优解的结构，LZ能否就个人的经验讲一下DP算法的设计思路(j就是怎样想到的）？54楼 Eric_Jiang 2011-06-01 23:18发表[回复] 算法真的很巧妙，再次感谢楼主，同时祝楼主节日快乐（还差四十分钟过去哦）。[e04]Re: v_JULY_v 2011-06-02 00:27发表[回复] 回复 jiangzhanchang：哦，谢谢，过了哈，[e10]53楼 逍遥K杰 2011-06-01 19:47发表[回复] 第四种方法，楼主说得不是很详细，能说得更简单易懂点么？Re: v_JULY_v 2011-06-01 19:57发表[回复] 回复 keshuangjie：恩，也可以完全不必理会它的。只是一个状态方程而已。看懂第二、三种方法，就够了。52楼 mirrorcool 2011-06-01 16:55发表[回复] 问下楼主 —INF是什么意思51楼 attitude424 2011-06-01 08:37发表[回复] 第三段代码中的两个注释好像有点问题。LZ看下，如果正数小于前面的负数。难道不加？Re: v_JULY_v 2011-06-01 08:59发表[回复] 回复 attitude424：正数会小于负数么?50楼 richardsic 2011-05-31 20:22发表[回复] [e01]好49楼 Hohenstaufen 2011-05-31 19:28发表[回复] 很巧妙，厉害48楼 何日复西归 2011-05-31 15:28发表[回复] f(i)从0到k上的积分函数F(K)，可以通过扫描一遍数组求出。如题目中的数组对应的F(K)是：
1，-1，2，12，8，15，17，12
(这一步开销是o(N))Re: v_JULY_v 2011-06-01 08:59发表[回复] 回复 myxxdyl：[e03]47楼 何日复西归 2011-05-31 15:28发表[回复] 这道题，也可以用代数思想的方法解决：
(1)这个数组是f(0),f(1),f(2),...f(N)。也就是知道这个数据的函数式f(i)。
题目求子数组的和的最大值，实际上是函数f(i)的在某区间(m,n)上积分的最大值。46楼 lindir 2011-05-31 15:01发表[回复] [e01]的确很妙，看了两遍45楼 xingxi_200 2011-05-31 11:19发表[回复] 巧妙[e01]44楼 独自蹲街角 2011-05-30 19:08发表[回复] 有味43楼 linjinnan168 2011-05-30 11:21发表[回复] 恕我太笨，能给我解释一下这个文章的精髓在哪吗？[e01]Re: v_JULY_v 2011-05-30 11:34发表[回复] 回复 linjinnan168：谈不上精髓，文章也没有亮点。O（N）的算法，网上也随处可见。42楼 fjksdafj 2011-05-30 10:54发表[回复] [e01]41楼 wanghongbiaohao 2011-05-30 10:44发表[回复] [e01]很好啊，谢谢楼主分享啊！40楼 kkkmoving 2011-05-30 08:51发表[回复] [e01][e03][e10]39楼 贝拉 2011-05-30 08:43发表[回复] [e01][e03]38楼 anan040102 2011-05-29 23:01发表[回复] [e01][e10]37楼 iwsn007 2011-05-29 16:10发表[回复] 方法2中的代码，b的最后一个值应该是13Re: v_JULY_v 2011-05-29 18:49发表[回复] 回复 iwsn007：是的，谢谢你，朋友，这就修正下，[e10]36楼 chang_night 2011-05-29 10:51发表[回复] [e03]35楼 奋斗小子 2011-05-28 09:42发表[回复] 错了一个字,是今年..34楼 奋斗小子 2011-05-28 09:40发表[回复] [e01]今天淘宝实习生笔试题倒数第二道就是连续和最大.
这让我想起之前同学给我讲的创新工场出过的一道题.
输入一个整形数组,求里面的递增(递减)子序列.不一定连续.Re: 4dreams 2011-05-30 10:40发表[回复] 回复 lanyan822：是经典的Longest Increase Subsequence模型吧Re: v_JULY_v 2011-05-28 10:59发表[回复] 回复 lanyan822：[e03]33楼 Mrs_zheng 2011-05-27 17:19发表[回复] [e03]妙哉妙哉....32楼 prajna 2011-05-27 14:59发表[回复] 这个算法是错的[e06]Re: v_JULY_v 2011-05-27 15:04发表[回复] 回复 gumh：不吝赐教?31楼 磊落天下 2011-05-27 13:37发表[回复] 牛！[e03]30楼 pch002 2011-05-26 23:29发表[回复] 太巧妙了吧！29楼 luwangjun1227 2011-05-26 22:54发表[回复] [e01]28楼 zs_yuangy 2011-05-26 20:01发表[回复] 其实还有更加难的版本，子矩阵，子立方体。不过子立方体就比较难了，自己的空间想象能力不行Re: v_JULY_v 2011-05-26 20:25发表[回复] 回复 zs_yuangy：那就不是面试技巧，而是超难度技巧了，，27楼 lazy_p 2011-05-26 17:00发表[回复] [e03][e01]这个问题比较简单吧，做过ACM的基本上都会O（n）算法，呵呵。。。希望能在出篇，多维找最小子矩阵的思考过程分析的文章吧，呵呵～～～[e10][e10][e10][e10]Re: v_JULY_v 2011-05-26 17:04发表[回复] 回复 lazy_p：[e03]，[e10]。怕到最后出现了ACM习题集了..Re: 4dreams 2011-05-30 10:37发表[回复] 回复 v_JULY_v：你如果是用基本题来讲算法，那题目是ACM题集是很正常的。而大多数人没有搞过acm，所以看见一些这种题感觉很新鲜。而对于ACMer这些都是司空见惯的。所以对于博主这种并非针对ACM的算法爱好者，应该多写关于算法的实际运用，而不是题的运用。Re: v_JULY_v 2011-05-30 19:12发表[回复] 回复 CodeChomper：是的，非常不错的建议，你看一下第十章，如何给磁盘文件排序。Re: v_JULY_v 2011-05-30 18:52发表[回复] 回复 CodeChomper：恩，非常好的建议，第十章、如何给磁盘文件排序，就是讲算法应用了。，谢谢你，[e10]Re: lazy_p 2011-05-27 12:21发表[回复] 回复 v_JULY_v：[e04][e04][e04]，呵呵～～～26楼 axuancxp 2011-05-26 11:30发表[回复] LZ还没毕业啊！看了你文章一下激起了我对算法的兴趣![e03]Re: v_JULY_v 2011-05-26 11:33发表[回复] 回复 axuancxp：你怎么知道的?Re: axuancxp 2011-05-27 12:29发表[回复] 回复 v_JULY_v：看你的个人介绍Re: axuancxp 2011-05-27 12:28发表[回复] 回复 v_JULY_v：LZ还没毕业啊！看了你文章一下激起了我对算法的兴趣![e03]
看你的个人介绍啊！25楼 zhoujk 2011-05-26 05:22发表[回复] [e08]不好意思，理解错了，原来是连续段啊。Re: v_JULY_v 2011-05-26 08:46发表[回复] 回复 zhoujk：[e04]，没什么，上面的话不是指你列24楼 zhoujk 2011-05-25 23:54发表[回复] 输入一个整形数组，数组里有正数也有负数。
数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。
求所有子数组的和的最大值。要求时间复杂度为O(n)。

所有大于0的数构成的子数组之和应该就是结果吧Re: v_JULY_v 2011-05-26 00:52发表[回复] 回复 zhoujk：是的，是有的人只看特殊情况，而不看题。Re: iwsn007 2011-05-29 16:08发表[回复] 回复 v_JULY_v：方法2中的代码，b的最后一个值应该是1323楼 itgrit 2011-05-25 23:17发表[回复] 数据结构与算法分析——C语言描述 Mark Allen Weiss第二章分析了这个问题的四种解法，大家也可以看看Re: v_JULY_v 2011-05-26 00:54发表[回复] 回复 SOLIDCEO：恩，right，日后酌情考虑添补相关东西于本文中。谢谢你。22楼 Peroi_Sun 2011-05-25 22:55发表[回复] 我是刚刚开始学习C语言的，是不是应该都看看这方面的？Re: v_JULY_v 2011-05-26 00:56发表[回复] 回复 Peroi_Sun：可以酌情看看，但非必须。建议先打好语言基础，再来看这类东西。21楼 Tishion 2011-05-25 22:17发表[回复] 4月份淘宝的笔试题目，我以前从没见过这个题目，自己临时想到的解法就是第二种方法。Re: v_JULY_v 2011-05-25 22:18发表[回复] 回复 OtishionO：[e04]20楼 Zsm 2011-05-25 22:15发表[回复] 前几天看了，自己也写过先前的代码，但是没写博文。这次看了又一种新的感觉。请问你的代码是如何插入到博文中的？ 谢谢 [e04]Re: v_JULY_v 2011-05-25 22:18发表[回复] 回复 Zsm0107：有代码编辑器的，一个铅笔的形状，，Re: Zsm 2011-05-25 22:31发表[回复] 回复 v_JULY_v：谢谢哈。Re: v_JULY_v 2011-05-26 00:57发表[回复] 回复 Zsm0107：这两个手冢，摆到一起，真...19楼 hehuabing 2011-05-25 18:58发表[回复] 顶，不过如何证明这个算法是对的。Re: v_JULY_v 2011-05-25 20:22发表[回复] 回复 hehuabing：恩，不错的提议，[e10]18楼 hehuabing 2011-05-25 18:56发表[回复] 如何证明这个算法是对的17楼 chuchenchuchen 2011-05-25 18:09发表[回复] [e01]16楼 xiaobukuai 2011-05-25 17:30发表[回复] 我的理解（可能是错误的）：加都没加下一个，怎么知道加上下一个是什么结果呢？再看第2段代码末尾的注释：其实算法很简单，当前面的几个数，加起来后。怎么这里又是前面的几个数，而不是加上下一个啊？Re: v_JULY_v 2011-05-25 20:22发表[回复] 回复 xiaobukuai：en，我把注释给修改下，谢谢你，[e10]15楼 xiaobukuai 2011-05-25 17:30发表[回复] 楼主，麻烦你看下第3段代码中的倒数两个注释14楼 xiaobukuai 2011-05-25 17:28发表[回复] 抽风的csdn，怎么发不了评论啊？13楼 easycruel 2011-05-25 17:23发表[回复] dp的方法也很不错的，毕竟更好理解12楼 辉仔 2011-05-25 15:37发表[回复] [e01][e01][e01][e01][e01][e01]11楼 Bit_bbtt 2011-05-25 15:06发表[回复] int FindMaxSubArray(int array[], int size)
{
 int maxbegin = -1;
 int maxend = -1;
 int maxsum = 0x80000001;//int型负数的极值Re: v_JULY_v 2011-05-25 22:30发表[回复] 回复 Bit_bbtt：可能评论里很不方便插入代码，如果有好的意见，欢迎加入狂想曲的wiki：http://tctop.wikispaces.com/。[e10]Re: Bit_bbtt 2011-05-27 17:14发表[回复] 回复 v_JULY_v：其实算法跟第三种差不多，只是看见您的博客提到这个题，顺手也写了一个，我只是多返回了目标子数组的下标起点和终点，博主继续加油！10楼 断无忌 2011-05-25 14:59发表[回复] [e03]O(N)啊。9楼 ztj2cml 2011-05-25 14:21发表[回复] 可以借鉴一下 谢谢8楼 rgd3385 2011-05-25 14:11发表[回复] 子数组不包含数组本身吗？貌似没有考虑这种情况。Re: v_JULY_v 2011-05-25 14:14发表[回复] 回复 rgd3385：是的，子数组不包含数组本身。Re: 木不且八 2011-05-31 10:05发表[回复] 回复 v_JULY_v：?我怎么觉得本身也算过了7楼 aimin2049 2011-05-25 14:01发表[回复] [e01]6楼 yhxyhxyhx 2011-05-25 13:40发表[回复] 麻烦，能不能换回网球王子的头像，帅多了Re: buyueliuying 2011-06-05 09:41发表[回复] 回复 yhxyhxyhx：看来你没认真看过网球王子。。。不了解手冢。。Re: v_JULY_v 2011-05-25 13:48发表[回复] 回复 yhxyhxyhx：i，看来我长得太龊了阿...5楼 十一文 2011-05-25 13:37发表[回复] 又没前排的 囧Re: v_JULY_v 2011-05-25 13:54发表[回复] 回复 xming4321：sf没了，还有冷板凳，[e04]4楼 love_jk 2011-05-25 13:03发表[回复] 实在是妙，，，，3楼 mo451583183 2011-05-25 10:57发表[回复] 第二种解法用的是动归的思想么？Re: v_JULY_v 2011-05-25 11:00发表[回复] 回复 mo451583183：是 的2楼 lwx496 2011-05-25 10:35发表[回复] [e01]好巧妙1楼 v_JULY_v 2011-05-25 10:10发表[回复] 本篇是至今为止，狂想曲系列中最短的一篇，也是被推的最快的一篇文章。前后不到二十分钟的功夫。
 


您还没有登录,请[登录]或[注册]
 
* 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场
 








个人资料 

v_JULY_v 






访问：4195666次
积分：25982分
排名：第50名
 . 原创：134篇
转载：0篇
译文：5篇
评论：10137条
 . 
博客公告 ①.本blog开通于2010年10月11日，高级C /Algorithms交流群：149977547；北京程序员联盟：172727781。②.狂热算法，热爱数据挖掘，关注机器学习、统计分析，爱好文学数学。③.微博：研究者July，邮箱：zhoulei0907@yahoo.cn，July，二零一三年三月二十九日。 
我的微博 
文章分类 03.Algorithms（实现）(9) 
01.Algorithms（研究）(27) 
02.Algorithms（后续）(22) 
04.Algorithms（讨论）(1) 
05.MS 100' original(7) 
06.MS 100' answers(13) 
07.MS 100' classify(4) 
08.MS 100' one Keys(6) 
09.MS 100' follow-up(3) 
10.MS 100' comments(4) 
11.TAOPP（编程艺术）(26) 
12.TAOPP string(6) 
13.TAOPP array(10) 
14.TAOPP list(2) 
15.stack/heap/queue(0) 
16.TAOPP tree(1) 
17.TAOPP c/c++(2) 
18.TAOPP function(2) 
19.TAOPP algorithms(7) 
20.number operations(1) 
21.Essays(8) 
22.Big Data Processing(5) 
23.Redis/MongoDB(0) 
24.data structures(12) 
25.Red-black tree(7) 
26.Image Processing(3) 
27.Architecture design(4) 
28.Source analysis(3) 
29.Recommend&Search(4) 
30.Machine L&Data Mining(5) 

博客专栏




微软面试100题系列
文章：17篇
阅读：1246089 





程序员编程艺术
文章：24篇
阅读：859706 





经典算法研究
文章：32篇
阅读：1110608 

阅读排行 程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦(186260) 
九月十月百度人搜，阿里巴巴，腾讯华为笔试面试八十题(第331-410题)(141609) 
教你如何迅速秒杀掉：99%的海量数据处理面试题(137438) 
横空出世，席卷互联网--评微软等公司数据结构+算法面试100题(127653) 
从B树、B+树、B*树谈到R 树(122026) 
十道海量数据处理面试题与十个方法大总结(101549) 
九月腾讯，创新工场，淘宝等公司最新面试三十题（第171-200题）(87330) 
十一、从头到尾彻底解析Hash表算法(78387) 
微软公司等数据结构+算法面试100题(第1-100题)全部出炉(75912) 
支持向量机通俗导论（理解SVM的三层境界）(74609) 

评论排行 程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦(371) 
九月十月百度人搜，阿里巴巴，腾讯华为笔试面试八十题(第331-410题)(361) 
九月腾讯，创新工场，淘宝等公司最新面试三十题（第171-200题）(331) 
当今世界最为经典的十大算法--投票进行时(320) 
从B树、B+树、B*树谈到R 树(264) 
横空出世，席卷互联网--评微软等公司数据结构+算法面试100题(263) 
十三个经典算法研究与总结、目录+索引(216) 
我的大学生涯(214) 
程序员编程艺术第一章、左旋转字符串(203) 
三五杆枪，可干革命，三五个人，可以创业(198) 

最新评论 程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦
v_JULY_v: @q1w2ok11:替我感谢你的同事:-) 

程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦
q1w2ok11: 同事推荐，太给力了，必须好好学习，楼主辛苦 

程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦
kiritor: 谢谢博主的分享,先收藏了 

程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦
v_JULY_v: @zhouqinxiong:哪个学校呢？替我谢谢你的老师:-) 

程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦
zhouqinxiong: 老师推荐的，lz，你的博客非常给力 

快速排序算法
康天崽: 太给力了，我喜欢，爱死你了 

我的大学生涯
msjcool: 看完楼主的经历，感觉自己弱爆了 

B树的C实现
hao138548: 好贴 

教你如何迅速秒杀掉：99%的海量数据处理面试题
xiyandeng: 虽然看得不是很懂，以后可以慢慢消化！感谢博主啊 

程序员编程艺术第一章、左旋转字符串
dusx1981: void RightShift4(string &str, int k){ int len = st... 


01、本blog索引 3、微软100题维护地址
1、微软100题横空出世
5、经典算法研究系列
7、红黑树系列集锦
6、程序员编程艺术系列
2、微软面试全部100题
0、经典4大原创系列集锦
4、微软100题下载地址
 
02、Google or baidu? Google搜--"结构之法"（My BLOG）
baidu 搜--"结构之法"（My BLOG）
 
03、个人标签 本BLOG RSS订阅
zhoulei0907@yahoo.cn
csdn blog订阅排行榜
TAOPP修订wiki
julymsn@live.cn
电子工程网专家VIP
 博客园blog-成为推荐博客
 ITpub-代码优化专家
 
04、我的驻点 01. 为学论坛-万物皆数 终生为学
 02、Harry
 03、NoSQLFan
 04、酷勤网
 05、52nlp
 06、北大朋友的挖掘乐园
 07、跟Sophia_qing一起读硕士
 08、面试问答社区51nod
 09、韩寒
 10、我的有鱼
 11、曾经的叛逆与年少
 12、老D之MongoDB源码分析
 14、code4app:iOS代码示例
 17、斯坦福机器学习公开课
 18、TheItHome算法版块版主
 19、36氪--关注互联网创业
 20、德问--编程是一种艺术创作
 21、善科网
 22、百度搜索研发部
 23、淘宝搜索技术博客
 24、interviewstreet
 25、LeetCode
 26、Team_Algorithms人人小组
 
文章存档 
2013年03月(1).
2012年12月(1).
2012年11月(1).
2012年09月(1).
2012年06月(1).
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

展开.
 

. 
公司简介|招贤纳士|广告服务|银行汇款帐号|联系方式|版权声明|法律顾问|问题报告QQ客服 微博客服 论坛反馈 联系邮箱：webmaster@csdn.net 服务热线：400-600-2320京 ICP 证 070598 号北京创新乐知信息技术有限公司 版权所有世纪乐知(北京)网络技术有限公司 提供技术支持江苏乐知网络技术有限公司 提供商务支持Copyright © 1999-2012, CSDN.NET, All Rights Reserved  
