
您还未登录！|登录|注册|帮助
 首页
 业界
 移动
 云计算
 研发
 论坛
 博客
 下载
 
更多
 







高爽|Coder 






目录视图
摘要视图
订阅
 . 



《这些年，我们读过的技术经典图书》主题有奖征文       专访李铁军：从医生到金山首席安全专家的转变      独一无二的职位：开源社区经理        CSDN博客第三期云计算最佳博主评选
 


Java线程(五)：线程池 
.
 分类： Java进阶2012-04-09 23:318458人阅读评论(29)收藏举报
 
java多线程线程池


 


        上一篇：Java线程(四)
 
        下一篇：Java线程(六)
 
        自JDK5之后，Java推出了一个并发包，java.util.concurrent，在Java开发中，我们接触到了好多池的技术，String类的对象池、Integer的共享池、连接数据库的连接池、Struts1.3的对象池等等，池的最终目的都是节约资源，以更小的开销做更多的事情，从而提高性能。
 
        我们的web项目都是部署在服务器上，浏览器端的每一个request就是一个线程，那么服务器需要并发的处理多个请求，就需要线程池技术，下面来看一下Java并发包下如何创建线程池。
 
        1.  创建一个可重用固定线程集合的线程池，以共享的无界队列方式来运行这些线程。
 








01. ExecutorService threadPool = Executors.newFixedThreadPool(3);// 创建可以容纳3个线程的线程池  
         2. 创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。 










01. ExecutorService threadPool = Executors.newCachedThreadPool();// 线程池的大小会根据执行的任务数动态分配  
         3. 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。 










01. ExecutorService threadPool = Executors.newSingleThreadExecutor();// 创建单个线程的线程池，如果当前线程在执行任务时突然中断，则会创建一个新的线程替代它继续执行任务  
         4. 创建一个可安排在给定延迟后运行命令或者定期地执行的线程池。 










01. ScheduledExecutorService threadPool = Executors.newScheduledThreadPool(3);// 效果类似于Timer定时器  
         每种线程池都有不同的使用场景，下面看一下这四种线程池使用起来有什么不同。 


        1. FixedThreadPool
 








01. import java.util.concurrent.ExecutorService;  
02. import java.util.concurrent.Executors;  
03. public class ThreadPoolTest {  
04.     public static void main(String[] args) {  
05.         ExecutorService threadPool = Executors.newFixedThreadPool(3);  
06.         for(int i = 1; i < 5; i++) {  
07.             final int taskID = i;  
08.             threadPool.execute(new Runnable() {  
09.                 public void run() {  
10.                     for(int i = 1; i < 5; i++) {  
11.                         try {  
12.                             Thread.sleep(20);// 为了测试出效果，让每次任务执行都需要一定时间  
13.                         } catch (InterruptedException e) {  
14.                             e.printStackTrace();  
15.                         }  
16.                         System.out.println("第" + taskID + "次任务的第" + i + "次执行");  
17.                     }  
18.                 }  
19.             });  
20.         }  
21.         threadPool.shutdown();// 任务执行完毕，关闭线程池  
22.     }  
23. }  
         输出结果： 










01. 第1次任务的第1次执行  
02. 第2次任务的第1次执行  
03. 第3次任务的第1次执行  
04. 第2次任务的第2次执行  
05. 第3次任务的第2次执行  
06. 第1次任务的第2次执行  
07. 第3次任务的第3次执行  
08. 第1次任务的第3次执行  
09. 第2次任务的第3次执行  
10. 第3次任务的第4次执行  
11. 第2次任务的第4次执行  
12. 第1次任务的第4次执行  
13. 第4次任务的第1次执行  
14. 第4次任务的第2次执行  
15. 第4次任务的第3次执行  
16. 第4次任务的第4次执行  
         上段代码中，创建了一个固定大小的线程池，容量为3，然后循环执行了4个任务，由输出结果可以看到，前3个任务首先执行完，然后空闲下来的线程去执行第4个任务，在FixedThreadPool中，有一个固定大小的池，如果当前需要执行的任务超过了池大小，那么多于的任务等待状态，直到有空闲下来的线程执行任务，而当执行的任务小于池大小，空闲的线程也不会去销毁。
         2. CachedThreadPool 


        上段代码其它地方不变，将newFixedThreadPool方法换成newCachedThreadPool方法。
 
        输出结果：
 








01. 第3次任务的第1次执行  
02. 第4次任务的第1次执行  
03. 第1次任务的第1次执行  
04. 第2次任务的第1次执行  
05. 第4次任务的第2次执行  
06. 第3次任务的第2次执行  
07. 第2次任务的第2次执行  
08. 第1次任务的第2次执行  
09. 第2次任务的第3次执行  
10. 第3次任务的第3次执行  
11. 第1次任务的第3次执行  
12. 第4次任务的第3次执行  
13. 第2次任务的第4次执行  
14. 第4次任务的第4次执行  
15. 第3次任务的第4次执行  
16. 第1次任务的第4次执行  
         可见，4个任务是交替执行的，CachedThreadPool会创建一个缓存区，将初始化的线程缓存起来，如果线程有可用的，就使用之前创建好的线程，如果没有可用的，就新创建线程，终止并且从缓存中移除已有60秒未被使用的线程。
 

        3. SingleThreadExecutor        
 
       上段代码其它地方不变，将newFixedThreadPool方法换成newSingleThreadExecutor方法。       
 
       输出结果：
 








01. 第1次任务的第1次执行  
02. 第1次任务的第2次执行  
03. 第1次任务的第3次执行  
04. 第1次任务的第4次执行  
05. 第2次任务的第1次执行  
06. 第2次任务的第2次执行  
07. 第2次任务的第3次执行  
08. 第2次任务的第4次执行  
09. 第3次任务的第1次执行  
10. 第3次任务的第2次执行  
11. 第3次任务的第3次执行  
12. 第3次任务的第4次执行  
13. 第4次任务的第1次执行  
14. 第4次任务的第2次执行  
15. 第4次任务的第3次执行  
16. 第4次任务的第4次执行  
         4个任务是顺序执行的，SingleThreadExecutor得到的是一个单个的线程，这个线程会保证你的任务执行完成，如果当前线程意外终止，会创建一个新线程继续执行任务，这和我们直接创建线程不同，也和newFixedThreadPool(1)不同。
 

    4.ScheduledThreadPool    
 








01. import java.util.concurrent.ScheduledExecutorService;  
02. import java.util.concurrent.TimeUnit;  
03. public class ThreadPoolTest {  
04.     public static void main(String[] args) {  
05.         ScheduledExecutorService schedulePool = Executors.newScheduledThreadPool(1);  
06.         // 5秒后执行任务  
07.         schedulePool.schedule(new Runnable() {  
08.             public void run() {  
09.                 System.out.println("爆炸");  
10.             }  
11.         }, 5, TimeUnit.SECONDS);  
12.         // 5秒后执行任务，以后每2秒执行一次  
13.         schedulePool.scheduleAtFixedRate(new Runnable() {  
14.             @Override  
15.             public void run() {  
16.                 System.out.println("爆炸");  
17.             }  
18.         }, 5, 2, TimeUnit.SECONDS);  
19.     }  
20. }  
         ScheduledThreadPool是一个固定大小的线程池，与FixedThreadPool类似，执行的任务是定时执行。 
    Java的并发包很强大，上面所说只是入门，随着学习深入，会有更多记录在博客里。
 
        本文来自：高爽|Coder，原文地址：http://blog.csdn.net/ghsau/article/details/7443324。

分享到： 

上一篇：Java线程(四)：Timer和TimerTask
下一篇：Java线程(六)：Callable和Future
 .
顶18踩5. 


查看评论
 
13楼 kyan54 2013-05-23 11:07发表[回复] 
引用“kyan54”的评论：[quote=ghsau]回复Markzwei：需要的，定时任务我写了两个...


您有QQ或其他联系方式么?我自己用这个线程池实现了一个类似quartz的功能,但是我还有一部分移除任务的逻辑没有搞清楚怎么弄...能否帮助我下?Re: 三千分之一的爱 2013-05-23 20:44发表[回复] 回复kyan54：我QQ：283929477
MSN也在线的12楼 kyan54 2013-05-23 11:05发表[回复] 
引用“ghsau”的评论：回复Markzwei：需要的，定时任务我写了两个例子，一个是5秒后执行，一...

想知道下..你是怎么停止任务的..11楼 markzwei 2012-04-16 14:17发表[回复] 学习了，顺便问下，如果用定时任务的话，线程池需要关闭吗？Re: 三千分之一的爱 2012-04-16 20:45发表[回复] 回复Markzwei：需要的，定时任务我写了两个例子，一个是5秒后执行，一个是5秒后执行后，每2秒再执行，像第一种线程池使用完是需要shutdown的，而第二种任务是持续执行，想什么时候shutdown需要自己定。Re: kyan54 2013-05-23 11:11发表[回复] 回复ghsau：不好意思,我的QQ是602050412,邮箱是kulou54@gmail.com
有时间请帮助我下,非常感谢!10楼 liuybfine 2012-04-14 16:11发表[回复] 不错 学习了9楼 ghrui 2012-04-13 20:39发表[回复] 不错，虽然对JAVA不太熟Re: 三千分之一的爱 2012-04-13 20:57发表[回复] 回复ghrui：呵呵，语言无界限8楼 feihumingyue 2012-04-13 17:21发表[回复] good,worth learningRe: 三千分之一的爱 2012-04-13 20:58发表[回复] 回复feihumingyue：Doesn't you have chinese input function?Re: 探花 2012-04-14 09:10发表[回复] 回复ghsau：少年，你英语写错了Re: 三千分之一的爱 2012-04-14 09:39发表[回复] 回复d08570121：表达清楚意思就行7楼 AFer198215 2012-04-13 17:07发表[回复] Thread并不使用jvm的内存,而是向os申请,所以不停的new Thread会发现,jvm占用的内存越来越大，而且不释放，ThreadPool让我们可以年复的线程资源而无需次次申请。Re: 三千分之一的爱 2012-04-13 18:08发表[回复] 回复AFer198215：是这样吗？Thread也是生存在JVM里面，怎么会越过JVM直接向OS申请内存Re: wnczwl369 2012-04-16 09:06发表[回复] 回复
看来我下去得确认一下，二位讨论的东西。我在做一个东西，用到了线程池解决并发处理。楼主，学习了。Thanks。
：Re: 三千分之一的爱 2012-04-16 09:39发表[回复] 回复wnczwl369：呵呵，不客气6楼 Monica 2012-04-11 17:48发表[回复] 这些问题提得很烂了！Re: 三千分之一的爱 2012-04-11 19:29发表[回复] 回复myloveiscomealone：怎么烂了？5楼 allen1981813 2012-04-11 17:16发表[回复] 不错。 我写过一个thread pool的例子在android上。共同学习。
http://code.google.com/a/eclipselabs.org/p/pausable-thread-util/Re: 三千分之一的爱 2012-04-11 19:51发表[回复] 回复allen1981813：学习了，但是BlockingQueue是个接口，而且你写那两个BlockingQueue中的方法在SE中没有啊，你写的这个线程池是Andriod的吗？Re: allen1981813 2012-04-12 23:36发表[回复] 回复ghsau：对，是android的。Re: 三千分之一的爱 2012-04-13 09:37发表[回复] 回复allen1981813：貌似在Android开发中线程很重要啊。4楼 shark1682003 2012-04-11 15:37发表[回复] 不错，学习了3楼 persh1985 2012-04-11 14:59发表[回复] 很不错啊 学习了 谢谢Re: 三千分之一的爱 2012-04-11 16:39发表[回复] 回复persh1985：不客气，多多支持2楼 yulang1028 2012-04-10 17:46发表[回复] 不错 ！1楼 nuonuodaodao 2012-04-09 23:36发表[回复] 很好，学习了啊Re: 三千分之一的爱 2012-04-09 23:38发表[回复] 回复nuonuodaodao：共同学习
 


您还没有登录,请[登录]或[注册]
 
* 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场
 








个人资料 

三千分之一的爱 





◦访问：128442次
◦积分：2377分
◦排名：第3359名
 . ◦原创：61篇
◦转载：24篇
◦译文：1篇
◦评论：270条
 . 

详细资料 
--------------------------------------------------------------------------------
姓名：高爽 
--------------------------------------------------------------------------------
生日：1989.6 
--------------------------------------------------------------------------------
学历：本科 
--------------------------------------------------------------------------------
学校：黑龙江科技大学 
--------------------------------------------------------------------------------
毕业：2012.7 
--------------------------------------------------------------------------------
微博：关注 
--------------------------------------------------------------------------------
爱好：乒乓球、旅行、摄影、LOL 
--------------------------------------------------------------------------------
邮箱&MSN：ghsau@163.com 
博客专栏




Design Pattern
文章：6篇
阅读：3717 





Java线程
文章：9篇
阅读：58065 

友情链接 酷壳 

阮一峰的网络日志 

曹胜欢的专栏 

Eric的Blog 

专注于AS3游戏算法及特效开发 

各种资源汇总 

如何用好 Google 搜索引擎？ 
文章分类 • 算法之道(2) 
• Java基础(14) 
• Java进阶(23) 
• Java Web(5) 
• Java Mail(1) 
• JavaScript(17) 
• Adobe Flex(11) 
• HTML/JS/CSS(10) 
• Oracle(2) 
• Integrated D E(9) 
• 非技术(4) 
• 软件开发(2) 
• NOSQL(1) 

文章存档 
2013年08月(5).
2013年07月(1).
2013年05月(1).
2013年04月(1).
2013年03月(1).
.
.
.
.
.
.
.
.
.
.
.
.
.

展开.
 
阅读排行 • Java线程(一)：线程安全与不安全(12965) 
• Java线程(二)：线程同步synchronized和volatile(11545) 
• Java线程(五)：线程池(8458) 
• Java线程(六)：Callable和Future(5978) 
• Java线程(四)：Timer和TimerTask(5709) 
• HTML发送邮件链接(5066) 
• Java线程(三)：线程协作-生产者/消费者模式(4925) 
• 史上最NB程序员的自白(4518) 
• Java线程(七)：锁对象Lock-同步问题更完美的处理方式(4067) 
• Java线程(八)：Condition-线程通信更高效的方式(3120) 

评论排行 • Java线程(一)：线程安全与不安全(40) 
• Java线程(五)：线程池(29) 
• 程序员的小笑话(19) 
• Java线程(二)：线程同步synchronized和volatile(19) 
• Aptana：JavaScript开发利器(14) 
• HTML发送邮件链接(10) 
• Java线程(篇外篇)：阻塞队列BlockingQueue(8) 
• Java线程(七)：锁对象Lock-同步问题更完美的处理方式(8) 
• Flex事件机制(二)(7) 
• 工厂方法模式(7) 

最新评论 •Java线程(一)：线程安全与不安全
三千分之一的爱: @y8465279130:哈哈，校友啊 

•Java线程(一)：线程安全与不安全
y8465279130: 同届校友啊, 我是电信院的. 惭愧惭愧, 才刚开始学习多线程. 向楼主学习!!! 

•关于List比较好玩的操作
三千分之一的爱: @hsj623:我试什么？从头遍历元素和从尾遍历元素区别？ 

•关于List比较好玩的操作
hsj623: @ghsau:相当的区别，LZ可以试一下 

•关于List比较好玩的操作
三千分之一的爱: @zczcmylove:这和i++有区别吗，一样会漏掉元素。 

•关于List比较好玩的操作
zczcmylove: 可以使用for(int i = intList.size()-1; i >= 0; i--) { 

•登录之找回密码
三千分之一的爱: @dongjianwan:呵呵，文中的处理方式还有些不安全。 

•登录之找回密码
dongjianwan: 我也是来这里学习了，楼主的思路很清晰啊 

•Java线程(七)：锁对象Lock-同步问题更完美的处理方式
wy554332466: 学长加个q1292658152 ，不懂的交流一下 

•Java线程(七)：锁对象Lock-同步问题更完美的处理方式
三千分之一的爱: @wy554332466:嗯 



. 
公司简介|招贤纳士|广告服务|银行汇款帐号|联系方式|版权声明|法律顾问|问题报告QQ客服 微博客服 论坛反馈 联系邮箱：webmaster@csdn.net 服务热线：400-600-2320京 ICP 证 070598 号北京创新乐知信息技术有限公司 版权所有世纪乐知(北京)网络技术有限公司 提供技术支持江苏乐知网络技术有限公司 提供商务支持Copyright © 1999-2012, CSDN.NET, All Rights Reserved  
