



结构之法 算法之道

Google或baidu搜索：“结构之法”，进入本博客


 


•目录视图
•摘要视图
•订阅
 



《这些年，我们读过的技术经典图书》主题有奖征文       专访李铁军：从医生到金山首席安全专家的转变      独一无二的职位：开源社区经理        CSDN博客第三期云计算最佳博主评选
 


程序员编程艺术：第八章、从头至尾漫谈虚函数 

分类： 11.TAOPP（编程艺术）17.TAOPP c/c++2011-05-26 01:0322583人阅读评论(109)收藏举报
 
编程floatfunclasstable面试

 
                    程序员编程艺术：第八章、从头至尾漫谈虚函数

作者：July。
出处：http://blog.csdn.net/v_JULY_v 。

 

前奏

    有关虚函数的问题层出不穷，有关虚函数的文章千篇一律，那为何还要写这一篇有关虚函数的文章呢?看完本文后，相信能懂其意义之所在。同时，原狂想曲系列已经更名为程序员编程艺术系列，因为不再只专注于“面试”，而在“编程”之上了。ok，如果有不正之处，望不吝赐教。谢谢。


第一节、一道简单的虚函数的面试题
题目要求：写出下面程序的运行结果?
//谢谢董天喆提供的这道百度的面试题 
#include <iostream>
using namespace std;
class A{
  public:virtual void p() 
  { 
    cout << "A" << endl; 
  }
};

class B : public A
{
  public:virtual void p() 
  { cout << "B" << endl;
  }
};

int main() 
{
  A * a = new A;
  A * b = new B;
  a->p();
  b->p();
  delete a;
  delete b;    
  return 0;
} 

    我想，这道面试题应该是考察虚函数相关知识的相对简单的一道题目了。然后，希望你碰到此类有关虚函数的面试题，不论其难度是难是易，都能够举一反三，那么本章的目的也就达到了。ok，请跟着我的思路，咱们步步深入（上面程序的输出结果为A B）。

 

 

第二节、有无虚函数的区别
      1、当上述程序中的函数p()不是虚函数，那么程序的运行结果是如何?即如下代码所示：


class A
{
public:
 void p() 
 { 
  cout << "A" << endl; 
 }
 
};

class B : public A
{
public:
 void p() 
 { 
  cout << "B" << endl;
 }
};

对的，程序此时将输出两个A，A。为什么?
我们知道，在构造一个类的对象时，如果它有基类，那么首先将构造基类的对象，然后才构造派生类自己的对象。如上，A* a=new A，调用默认构造函数构造基类A对象，然后调用函数p()，a->p();输出A，这点没有问题。
    然后，A * b = new B;，构造了派生类对象B，B由于是基类A的派生类对象，所以会先构造基类A对象，然后再构造派生类对象，但由于当程序中函数是非虚函数调用时，B类对象对函数p()的调用时在编译时就已静态确定了，所以，不论基类指针b最终指向的是基类对象还是派生类对象，只要后面的对象调用的函数不是虚函数，那么就直接无视，而调用基类A的p()函数。

      2、那如果加上虚函数呢?即如最开始的那段程序那样，程序的输出结果，将是什么?
在此之前，我们还得明确以下两点：
    a、通过基类引用或指针调用基类中定义的函数时，我们并不知道执行函数的对象的确切类型，执行函数的对象可能是基类类型的，也可能是派生类型的。
    b、如果调用非虚函数，则无论实际对象是什么类型，都执行基类类型所定义的函数（如上述第1点所述）。如果调用虚函数，则直到运行时才能确定调用哪个函数，运行的虚函数是引用所绑定的或指针所指向的对象所属类型定义的版本。

根据上述b的观点，我们知道，如果加上虚函数，如上面这道面试题，


class A
{
public:
 virtual void p() 
 { 
  cout << "A" << endl; 
 }
 
};

class B : public A
{
public:
 virtual void p() 
 { 
  cout << "B" << endl;
 }
};

int main() 
{
 A * a = new A;
 A * b = new B;
 a->p();
 b->p();
 delete a;
 delete b;
    return 0;
}

 

那么程序的输出结果将是A B。

所以，至此，咱们的这道面试题已经解决。但虚函数的问题，还没有解决。


第三节、虚函数的原理与本质
    我们已经知道，虚（virtual）函数的一般实现模型是：每一个类（class）有一个虚表（virtual table），内含该class之中有作用的虚（virtual）函数的地址，然后每个对象有一个vptr，指向虚表（virtual table）的所在。

请允许我援引自深度探索c++对象模型一书上的一个例子：


class Point { 
public: 
   virtual ~Point();   

   virtual Point& mult( float ) = 0;  

   float x() const { return _x; }     //非虚函数，不作存储
   virtual float y() const { return 0; }  
   virtual float z() const { return 0; }  
   // ... 

protected: 
   Point( float x = 0.0 ); 
   float _x; 
}; 

      1、在Point的对象pt中，有两个东西，一个是数据成员_x，一个是_vptr_Point。其中_vptr_Point指向着virtual table point，而virtual table（虚表）point中存储着以下东西：
•virtual ~Point()被赋值slot 1，
•mult() 将被赋值slot 2. 
•y() is 将被赋值slot 3 
•z() 将被赋值slot 4. 


class Point2d : public Point { 
public: 
   Point2d( float x = 0.0, float y = 0.0 )  
      : Point( x ), _y( y ) {} 
   ~Point2d();   //1

   //改写base class virtual functions 
   Point2d& mult( float );  //2
   float y() const { return _y; }  //3

protected: 
   float _y; 
}; 

      2、在Point2d的对象pt2d中，有三个东西，首先是继承自基类pt对象的数据成员_x，然后是pt2d对象本身的数据成员_y，最后是_vptr_Point。其中_vptr_Point指向着virtual table point2d。由于Point2d继承自Point，所以在virtual table point2d中存储着：改写了的其中的~Point2d()、Point2d& mult( float )、float y() const，以及未被改写的Point::z()函数。


class Point3d: public Point2d { 
public: 
   Point3d( float x = 0.0, 
            float y = 0.0, float z = 0.0 ) 
      : Point2d( x, y ), _z( z ) {} 
   ~Point3d(); 

   // overridden base class virtual functions 
   Point3d& mult( float ); 
   float z() const { return _z; } 

   // ... other operations ... 
protected: 
   float _z; 
}; 

      3、在Point3d的对象pt3d中，则有四个东西，一个是_x，一个是_vptr_Point，一个是_y，一个是_z。其中_vptr_Point指向着virtual table point3d。由于point3d继承自point2d，所以在virtual table point3d中存储着：已经改写了的point3d的~Point3d()，point3d::mult()的函数地址，和z()函数的地址，以及未被改写的point2d的y()函数地址。

ok，上述1、2、3所有情况的详情，请参考下图。



（图：virtual table（虚表）的布局：单一继承情况）

本文，日后可能会酌情考虑增补有关内容。ok，更多，可参考深度探索c++对象模型一书第四章。
最近几章难度都比较小，是考虑到狂想曲有深有浅的原则，后续章节会逐步恢复到相应难度。

 

第四节、虚函数的布局与汇编层面的考察

      ivan、老梦的两篇文章继续对虚函数进行了一番深入，我看他们已经写得很好了，我就不饶舌了。ok，请看：1、VC虚函数布局引发的问题，2、从汇编层面深度剖析C++虚函数、http://blog.csdn.net/linyt/archive/2011/04/20/6336762.aspx。

 

第五节、虚函数表的详解

    本节全部内容来自淄博的共享，非常感谢。注@molixiaogemao：只有发生继承的时候且父类子类都有virtual的时候才会出现虚函数指针，请不要忘了虚函数出现的目的是为了实现多态。
 


 一般继承（无虚函数覆盖）
 下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系：

 

 请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，

 对于实例：Derive d; 的虚函数表如下：


 

 我们可以看到下面几点：
 1）虚函数按照其声明顺序放于表中。
 2）父类的虚函数在子类的虚函数前面。
 
 我相信聪明的你一定可以参考前面的那个程序，来编写一段程序来验证。
 

 一般继承（有虚函数覆盖）
 覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。
 下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。

 

 为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()  。
 那么，对于派生类的实例，其虚函数表会是下面的一个样子：
 
 我们从表中可以看到下面几点，
 1）覆盖的f()函数被放到了虚表中原来父类虚函数的位置。
 2）没有被覆盖的函数依旧。
 
 这样，我们就可以看到对于下面这样的程序，
 Base *b = new Derive();

b->f();

由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，
于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。


多重继承（无虚函数覆盖）

下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系（注意：子类并没有覆盖父类的函数）：



对于子类实例中的虚函数表，是下面这个样子：



 

我们可以看到：
1） 每个父类都有自己的虚表。
2） 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）

这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。


多重继承（有虚函数覆盖）
下面我们再来看看，如果发生虚函数覆盖的情况。
下图中，我们在子类中覆盖了父类的f()函数。

 



下面是对于子类实例中的虚函数表的图：



 

我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。
这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如：

Derive d;
Base1 *b1 = &d;
Base2 *b2 = &d;
Base3 *b3 = &d;
b1->f(); //Derive::f()
b2->f(); //Derive::f()
b3->f(); //Derive::f()
b1->g(); //Base1::g()
b2->g(); //Base2::g()
b3->g(); //Base3::g()

 

安全性
每次写C++的文章，总免不了要批判一下C++。
这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。
水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。

一、通过父类型的指针访问子类自己的虚函数
我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。
虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数：

Base1 *b1 = new Derive();
b1->g1(); //编译出错

任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，即基类指针不能调用子类自己定义的成员函数。所以，这样的程序根本无法编译通过。
但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。
（关于这方面的尝试，通过阅读后面附录的代码，相信你可以做到这一点）

二、访问non-public的虚函数
另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，
所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。
如：

class Base {
private: 
 virtual void f() { cout << "Base::f" << endl; } 
};

class Derive : public Base{ 
};
typedef void(*Fun)(void);
void main() {
 Derive d;
 Fun pFun = (Fun)*((int*)*(int*)(&d)+0);
 pFun(); 
}

对上面粗体部分的解释（@a && x）：

1. (int*)(&d)取vptr地址，该地址存储的是指向vtbl的指针
2. (int*)*(int*)(&d)取vtbl地址，该地址存储的是虚函数表数组
3. (Fun)*((int*)*(int*)(&d) +0)，取vtbl数组的第一个元素，即Base中第一个虚函数f的地址
4. (Fun)*((int*)*(int*)(&d) +1)，取vtbl数组的第二个元素（这第4点，如下图所示）。

下图也能很清晰的说明一些东西（@5）：



 

ok，再来看一个问题，如果一个子类重载的虚拟函数为privete，那么通过父类的指针可以访问到它吗？

#include <IOSTREAM>   
class B   
{    
public:    
    virtual void fun()      
    {     
        std::cout << "base fun called";     
    };    
};   

class D : public B    
{    
private:   
    virtual void fun()      
    {     
        std::cout << "driver fun called";    
    };    
};   

int main(int argc, char* argv[])   
{       
    B* p = new D();    
    p->fun();    
    return 0;    
}  
运行时会输出 driver fun called

从这个实验，可以更深入的了解虚拟函数编译时的一些特征:
在编译虚拟函数调用的时候，例如p->fun(); 只是按其静态类型来处理的, 在这里p的类型就是B，不会考虑其实际指向的类型（动态类型）。
    也就是说，碰到p->fun();编译器就当作调用B的fun来进行相应的检查和处理。
因为在B里fun是public的，所以这里在“访问控制检查”这一关就完全可以通过了。
然后就会转换成(*p->vptr[1])(p)这样的方式处理, p实际指向的动态类型是D，
    所以p作为参数传给fun后(类的非静态成员函数都会编译加一个指针参数，指向调用该函数的对象，我们平常用的this就是该指针的值）, 实际运行时p->vptr[1]则获取到的是D::fun()的地址，也就调用了该函数, 这也就是动态运行的机理。


为了进一步的实验，可以将B里的fun改为private的，D里的改为public的，则编译就会出错。
C++的注意条款中有一条" 绝不重新定义继承而来的缺省参数值" 
（Effective C++ Item37， never redefine a function's inherited default parameter value) 也是同样的道理。

可以再做个实验
class B   
{    
public:   
    virtual void fun(int i = 1)      
    {     
        std::cout << "base fun called, " << i;     
    };    
};   

class D : public B    
{    
private:    
    virtual void fun(int i = 2)      
    {     
        std::cout << "driver fun called, " << i;     
    };    
};  

 

 
则运行会输出driver fun called, 1
 

关于这一点，Effective上讲的很清楚“virtual 函数系动态绑定， 而缺省参数却是静态绑定”，
也就是说在编译的时候已经按照p的静态类型处理其默认参数了,转换成了(*p->vptr[1])(p, 1)这样的方式。 

补遗

   一个类如果有虚函数，不管是几个虚函数，都会为这个类声明一个虚函数表，这个虚表是一个含有虚函数的类的，不是说是类对象的。一个含有虚函数的类，不管有多少个数据成员，每个对象实例都有一个虚指针，在内存中，存放每个类对象的内存区，在内存区的头部都是先存放这个指针变量的（准确的说，应该是：视编译器具体情况而定），从第n（n视实际情况而定）个字节才是这个对象自己的东西。

 

下面再说下通过基类指针，调用虚函数所发生的一切：
One *p;
p->disp();

1、上来要取得类的虚表的指针，就是要得到，虚表的地址。存放类对象的内存区的前四个字节其实就是用来存放虚表的地址的。
2、得到虚表的地址后，从虚表那知道你调用的那个函数的入口地址。根据虚表提供的你要找的函数的地址。并调用函数；你要知道，那个虚表是一个存放指针变量的数组，并不是说，那个虚表中就是存放的虚函数的实体。

本章完。
3.3续、求给定区间内的第K小（大）元素 第九章、闲话链表追赶问题 第十章、如何给10^7个数据量的磁盘文件排序
--------------------------------------------------------------------------------

版权所有，本人对本blog内所有任何内容享有版权及著作权。网络转载，请以链接形式注明出处。
 

•上一篇：程序员编程艺术：第七章、求连续子数组的最大和
•下一篇：程序员编程艺术：第九章、闲话链表追赶问题
 


查看评论
 



* 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场
 







个人资料 

v_JULY_v 




◦访问：4771615次
◦积分：27387分
◦排名：第46名
 ◦原创：138篇
◦转载：0篇
◦译文：5篇
◦评论：10756条
 

博客公告 ①.本blog开通于2010年10月11日，高级C++/算法交流群：128691433；北京程序员联盟：172727781。②.狂热算法，热爱数据挖掘，关注机器学习、统计分析，爱好文学数学。③.微博：研究者July，邮箱：zhoulei97@aliyun.com，或zhoulei0907@yahoo.cn，July，二零一三年八月七日。 
我的微博 
文章分类 • 03.Algorithms（实现）(9) 
• 01.Algorithms（研究）(27) 
• 02.Algorithms（后续）(22) 
• 04.Algorithms（讨论）(1) 
• 05.MS 100' original(7) 
• 06.MS 100' answers(13) 
• 07.MS 100' classify(4) 
• 08.MS 100' one Keys(6) 
• 09.MS 100' follow-up(3) 
• 10.MS 100' comments(4) 
• 11.TAOPP（编程艺术）(29) 
• 12.TAOPP string(8) 
• 13.TAOPP array(12) 
• 14.TAOPP list(2) 
• 15.stack/heap/queue(0) 
• 16.TAOPP tree(1) 
• 17.TAOPP c/c++(2) 
• 18.TAOPP function(2) 
• 19.TAOPP algorithms(7) 
• 20.number operations(1) 
• 21.Essays(8) 
• 22.Big Data Processing(5) 
• 23.Redis/MongoDB(0) 
• 24.data structures(12) 
• 25.Red-black tree(7) 
• 26.Image Processing(3) 
• 27.Architecture design(4) 
• 28.Source analysis(3) 
• 29.Recommend&Search(4) 
• 30.Machine L&Data Mining(5) 

博客专栏




数据挖掘十大算法系列
文章：5篇
阅读：277416 





微软面试100题系列
文章：17篇
阅读：1412267 





程序员编程艺术
文章：27篇
阅读：1022204 





经典算法研究
文章：32篇
阅读：1254721 

阅读排行 • 程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦(217908) 
• 教你如何迅速秒杀掉：99%的海量数据处理面试题(170893) 
• 九月十月百度人搜，阿里巴巴，腾讯华为笔试面试八十题(第331-410题)(166897) 
• 从B树、B+树、B*树谈到R 树(142708) 
• 横空出世，席卷互联网--评微软等公司数据结构+算法面试100题(137238) 
• 十道海量数据处理面试题与十个方法大总结(113474) 
• 支持向量机通俗导论（理解SVM的三层境界）(102790) 
• 九月腾讯，创新工场，淘宝等公司最新面试三十题（第171-200题）(94309) 
• 十一、从头到尾彻底解析Hash表算法(89258) 
• 微软公司等数据结构+算法面试100题(第1-100题)全部出炉(84427) 

评论排行 • 程序员面试、算法研究、编程艺术、红黑树、数据挖掘5大系列集锦(409) 
• 九月十月百度人搜，阿里巴巴，腾讯华为笔试面试八十题(第331-410题)(368) 
• 九月腾讯，创新工场，淘宝等公司最新面试三十题（第171-200题）(339) 
• 当今世界最为经典的十大算法--投票进行时(322) 
• 从B树、B+树、B*树谈到R 树(279) 
• 横空出世，席卷互联网--评微软等公司数据结构+算法面试100题(267) 
• 我的大学生涯(236) 
• 程序员编程艺术第一章、左旋转字符串(223) 
• 十三个经典算法研究与总结、目录+索引(218) 
• 支持向量机通俗导论（理解SVM的三层境界）(215) 

最新评论 •程序员编程艺术第三十二~三十三章：最小操作数，木块砌墙问题
u011916787: 问一个关于C++的问题，使用vector的时候为什么有时候初始化了之后需要resize(),而有时候... 

•程序员编程艺术第三十二~三十三章：最小操作数，木块砌墙问题
u011916787: 问一下，这一个算法你大约想多久啊，我看现成的解答都要看半天，哎~~~ 

•从Hadoop框架与MapReduce模式中谈海量数据处理（含淘宝技术架构）
yutianzuijin: @RunZhi1989:惊现俊哥！ 

•程序员编程艺术：第二章、字符串是否包含及匹配/查找/转换/拷贝问题
ken_lover: @likefxy:这个方法有问题 

•程序员编程艺术第一章、左旋转字符串
ken_lover: 将问题提高到数学方法实现，思考问题层次立马advanced了 

•从Trie树（字典树）谈到后缀树（10.28修订）
hanchengxi: “还要提到一个节约时间的方法. 当我们遍历所有后缀时, 如果某个后缀的某个儿子跟待加字符(新前缀最后... 

•全新整理：微软、Google等公司的面试题及解答、第161-170题
ilogo1: 放鸡蛋那个题，应该DP一下，在条件限制下的完全背包问题。 

•微软面试100题2010年版全部答案集锦（含下载地址）
hasayake0302: 看了博主的帖子受益匪浅感觉Q48和Q51解法欠妥Q48：仅靠“a >= k && k > a”还不足... 

•程序员编程艺术：第十章、如何给10^7个数据量的磁盘文件排序
yankai0219: 关于这个题目中K路归并时所采用的算法。在您的原文中，K路归并时就是采用数组比较获得最小值，复杂度为O... 

•程序员编程艺术第三十四~三十五章：格子取数问题，完美洗牌算法
v_JULY_v: @k578522915:没记录最大值？ 


01、本blog索引 ◦3、微软100题维护地址
◦1、微软100题横空出世
◦5、经典算法研究系列
◦7、红黑树系列集锦
◦6、程序员编程艺术系列
◦2、微软面试全部100题
◦0、经典5大原创系列集锦
◦4、微软100题下载地址
 
02、Google or baidu? ◦Google搜--"结构之法"（My BLOG）
◦baidu 搜--"结构之法"（My BLOG）
 
03、我的驻点 ◦01. 为学论坛-万物皆数 终生为学
 ◦02、Harry
 ◦03、NoSQLFan
 ◦04、酷勤网
 ◦05、52nlp
 ◦06、北大朋友的挖掘乐园
 ◦07、跟Sophia_qing一起读硕士
 ◦08、caopengcs
 ◦08、面试问答社区51nod
 ◦09、韩寒
 ◦11、曾经的叛逆与年少
 ◦12、老D之MongoDB源码分析
 ◦14、code4app:iOS代码示例
 ◦17、斯坦福机器学习公开课
 ◦18、TheItHome算法版块版主
 ◦19、36氪--关注互联网创业
 ◦20、德问--编程是一种艺术创作
 ◦21、善科网
 ◦22、百度搜索研发部
 ◦23、淘宝搜索技术博客
 ◦24、interviewstreet
 ◦25、LeetCode
 ◦26、Team_Algorithms人人小组
 
文章存档 
•2013年08月(2)
•2013年06月(1)
•2013年03月(1)
•2012年12月(1)
•2012年11月(1)
•2012年09月(1)
•2012年06月(1)
•2012年05月(2)
•2012年04月(1)
•2012年03月(2)
•2012年02月(2)
•2012年01月(2)
•2011年12月(5)
•2011年11月(1)
•2011年10月(7)
•2011年09月(3)
•2011年08月(11)
•2011年07月(4)
•2011年06月(7)
•2011年05月(10)
•2011年04月(7)
•2011年03月(17)
•2011年02月(11)
•2011年01月(18)
•2010年12月(14)
•2010年11月(6)
•2010年10月(5)
 



