装配中的脑袋
用大脑装配程序，再用程序装配大脑

随笔- 58  文章- 0  评论- 1125 
博客园  首页  新随笔  新文章  联系  管理  订阅 
自己动手开发编译器（二）正则语言和正则表达式
从今天这一篇起，我们就来正式揭开编译器的奥秘。首先我们接触到的模块是词法分析器，也叫词法扫描器，代码里我常常叫它Scanner。昨天我稍微解释了一下为什么需要将词法分析单独分离出来，今天来回顾一下这个问题。请看下面这段C#代码：

 

 string str = "Hello World";
 

即使没有语法高亮，这段代码也可以很明显地分成好几部分。首先是关键字string，之后是变量名str，然后是等号=，接下来是一个字符串字面常量”Hello World”。现代语言如C#这样的，都能明显地将源代码分断成这样具有明确含义的片段，我们称之为词素（lexeme）。与描述整个C#语言的语法相比，我们用比较简单的规则就能描述不同类型的词素。比如上面这段代码中出现的词素用白话来描述的话就是：

 

类型

规则

例子

关键字string

正好是s-t-r-i-n-g这几个字母按顺序组成

string

标识符（变量名）

由字母开头，后面可以跟零个或多个字母或数字，但不能与关键字冲突

str

等号

一个=符号

=

字符串字面常量

由双引号开始，中间可以包含任意个不是双引号的字符，最后以双引号结尾

"hello world"

分号

一个;符号

;

 

我们看到，不同词素可以根据其特征划分到几个类型当中，而接下来的语法分析阶段，就可以直接以词素的类型——我们称之为单词（token）——作为输入。token有时候也翻译成令牌、记号、象征什么的，在本文中统一称为单词。如此可见，只要用相对简洁的规则，就能把原本字符串组成的源文件，分解为一串单词流，这样就能大大简化接下来的语法分析。这就是我们把词法分析单独分出来作为一个模块的根本原因。

 

不过，上面表格中所列的规则是用白话来描述的，我们希望能用一种形式化的语言来进行描述，以便计算机自动进行处理。正则表达式就是一个理想的选择。

 

大家日常编程中估计多多少少都接触过正则表达式，用它来匹配字符串等，也可能已经很熟悉其语法了。但我这次想从正则表达式的最基本概念来重新介绍一次，主要想让大家更深地理解它。首先我们要重新定义一下“语言”这个概念。“语言”就是指字符串的集合，其中的字符来自于一个有限的字符集合。也就是说，语言总要定义在一个有限的字符集上，但是语言本身可以既可以是有穷集合，也可以是无穷集合。比如“C#语言”就是指满足C#语法的全体字符串的集合，它显然是个无穷集合。当然也可以定义一些简单的语言，比如这个语言{ a }就只有一个成员，那就是一个字母a。后面我们都用大括号{}来表示字符串的集合。所谓正则表达式呢，就是描述一类语言的一种特殊表达式，正则表达式共有2种基本要素：

表达式ε表示一个语言，仅包含一个长度为零的字符串，可以理解为{ String.Empty }，我们通常把String.Empty记作ε，读作epsilon。
对字符集中任意字符a，表达式a表示仅有一个字符a的语言，即{ a }。
同时正则表达式定义了3种基本运算规则：

两个正则表达式的并，记作X|Y，表示的语言是正则表达式X所表示的语言与正则表达式Y所表示语言的并集。比如a|b所得的语言就是{a, b}。类似于加法
两个正则表达式的连接，记作XY，表示的语言是将X的语言中每个字符串后面连接上Y语言中的每一种字符串，再把所有这种连接的结果组成一种新的语言。比如令X = a|b，Y = c|d，那么XY所表示的语言就是{ac, bc, ad, bd}。因为X表示是{a, b}，而Y表示的是{ c, d}，连接运算取X语言的每一个字符串接上Y语言的每一个字符串，最后得到了4种连接结果。这类似于乘法
一个正则表达式的克林闭包，记作X*，表示分别将零个，一个，两个……无穷个X与自己连接，然后再把所有这些求并。也就是说X* = ε | X | XX | XXX | XXX | ……。比如a*这个正则表达式，就表示的是个无穷语言{ ε, a, aa, aaa, aaaa, …. }。这相当于任意次重复一个语言。
以上三种运算写在一起时克林闭包的优先级高于连接运算，而连接运算的优先级高于并运算。以上就是正则表达式的全部规则！并不是很难理解对吧？下面我们用正则表达式来描述一下刚才各个词素的规则。

 

首先是关键字string，刚才我们描述说它是“正好是s-t-r-i-n-g这几个字母按顺序组成”，用正则表达式来表示，那就是s-t-r-i-n-g这几个字母的连接运算，所以写成正则表达是就是string。大家一定会觉得这个例子很无聊。。那么我们来看下一个例子：标识符。用白话来描述是“由字母开头，后面可以跟零个或多个字母或数字”。先用正则表达式描述“由字母开头”，那就是指，可以是a-z中任意一个字母来开头。这是正则表达式中的并运算：a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z。如果每个正则表达式都这么写，那真是要疯掉了，所以我们引入方括号语法，写在方括号里就表示这些字符的并运算。比如[abc]就表示a|b|c。而a-z一共26个字母我们也简写成a-z，这样，“由字母开头”就可以翻译成正则表达式[a-z]了。接下来我们翻译第二句“后面可以跟零个或多个字母或数字”这句话中的“零个或多个”可以翻译成克林闭包运算，最后相信大家都可以写出来，就是[a-z0-9]*。最后，前后两句之间是一个连接运算，因此最后描述标识符“语言”的正则表达式就是[a-z][a-z0-9]*。其中的*运算也意味着“标识符”是一种无穷语言，有无数种可能的标识符。本来就是这样，很好理解对吧？

 

从上面例子可以看出，正则表达式都可以用两种要素和三种基本运算组合出来。但是如果我们要真的拿来描述词法单词的规则，需要一些便于使用的辅助语法，就像上边的方括号语法那样。我们定义一些正则表达式的扩展运算：

方括号表示括号内的字符并运算。[abc]就等于a|b|c
方括号中以^字符开头，表示字符集中，排除方括号中的所有字符之后，所剩字符的并运算。[^ab]就表示除了ab以外所有字符求并。
圆.点表示字符集内所有字符的并。因此 .* 这个表达式就能表示这种字符集所能组成的一切字符串。
X?表示 X|ε 。表示X与空字符串之间可选。
X+表示XX*。这等于限制了X至少要重复1次。
用过正则表达式的同学应该都熟悉以上运算了。其实.NET中的正则表达式还提供更多的扩展语法，但我们这次并不使用.NET的正则库，所以就不列出其余的语法了。

 

我们把所有能用正则表达式表示的语言称作正则语言。很遗憾，并非所有的语言都是正则语言。比如C#，或者所有编程语言、HTML、XML、JSON等等，都不是正则语言。所以不能用正则表达式定义上述语言的规则。但是，用正则表达式来定义词法分析的规则却是非常合适的。大部分编程语言的词素都可以用一个简单的正则表达式来表达。下面就是上述单词的正则表达式定义。

 

类型

正则表达式

例子

关键字string

string

string

标识符（变量名）

[a-z][a-z0-9]*

str

等号

=

=

字符串字面常量

"[^"]*"

"hello world"

分号

;

;

 

我们大家平时熟悉的正则表达式是写成上文这样的字符串形式。但这次我们要自己处理正则表达式，写成字符串显然增加了处理的难度（要解析正则表达式字符串）。所以在VBF.Compilers库的词法分析库中，我引入了一种用对象来表示正则表达式的手法。我定义了一个RegularExpression基类，然后为每一种正则表达式要素或运算编写了一个子类：



其中AlternationExpression就是“并”运算，ConcatenationExpression就是“连接”运算，EmptyExpression当然就表示ε空字符串，KleeneStarExpression表示“克林闭包”运算（你现在可以知道克林闭包也可以叫做克林星——本来就是一星号嘛）和表示单一字符的SymbolExpression。像SymbolExpression里面其实就储存了它所表示的一个字符，而AlternationExpression下面储存了两个RegularExpression实例，用来表示并运算的双方。所以，任何正则表达式都能用RegularExpression的对象树来表示。比如正则表达式[a|b]*就可以表示为：

 

RegularExpression re = new KleeneStarExpression(
             new AlternationExpression(
             new SymbolExpression('a'), new SymbolExpression('b')));
             
 

有点像Linq to XML有木有？虽然它写起来比字符串长了那么一点点（观众：是长好多吧……），但是我们不需要解析字符串就可以获得它的结构，这对下一步进行处理非常有帮助。好吧，我承认全都写这么长也受不了，所以我定义了一些辅助的静态方法和运算符重载。上面的正则表达式可以写成：

 

var re = (RE.Symbol('a') | RE.Symbol('b')).Many();
 

其中RE其实是要用using RE=VBF.Compilers.Scanners.RegularExpression;语句来声明的别名。虽然它还是比字符串的正则表达式长一些，但考虑到无需解析字符串带来的方便，就忍了吧。等到后面语法分析学习完了以后我会带大家自己开发正则表达式字符串的解析器。

 

接下来的问题是，怎么用正则表达式表示的规则来进行词法分析呢？正则表达式利于我们理解单词的规则，但并不能拿来直接解析字符串。为此我们要引入有穷自动机的概念来真正处理输入字符串。敬请期待下一篇。

同时大家别忘了关注VBF项目：https://github.com/Ninputer/VBF 和我的微博：http://weibo.com/ninputer 多谢大家支持！

绿色通道： 好文要顶 关注我 收藏该文与我联系 
装配脑袋
关注 - 8
粉丝 - 626
荣誉：推荐博客
+加关注
21 0
(请您对文章做出评价)
« 博主上一篇：自己动手开发编译器（一）编译器的模块化工程
» 博主下一篇：自己动手开发编译器（三）有穷自动机
« 首页上一篇：web前端——曝光图像替换的N种办法缺陷
» 首页下一篇：Delegate,Action,Func,Predicate的使用与区别
 posted on 2011-06-08 21:12 装配脑袋 阅读(9081) 评论(49) 编辑 收藏


评论
#1楼    
 山诺海心   | 2011-06-08 21:15
我顶，我再顶！
支持(0)反对(0)
#2楼    
 幸运草   | 2011-06-08 21:29
来顶一下。
支持(0)反对(0)
#3楼    
 aisk   | 2011-06-08 21:55
持续关注。。。支持楼主！
支持(0)反对(0)
#4楼    
 羽落无声   | 2011-06-08 21:56
我感觉，这部分基础知识还得仔细看龙书才行，当初学编译原理那会儿真是痛不欲生呀
支持(0)反对(0)
#5楼    
 老马睡不醒   | 2011-06-08 22:14
谢谢楼主共享。

编译原理到现在还记得的只有递归下降法了。

楼主给的正则表达式的类图很好很强大，学习了。
支持(0)反对(0)
#6楼    
 横刀天笑   | 2011-06-08 22:30
跟着脑袋学习了~~
支持(0)反对(0)
#7楼    
 Tony Zhou   | 2011-06-08 22:33
博客园top5牛的主题了
支持(0)反对(0)
#8楼    
 MNight   | 2011-06-08 22:40
很强大，期待下文……
支持(0)反对(0)
#9楼    
 BlueDream   | 2011-06-08 22:45
这个好东西，标记~
支持(0)反对(0)
#10楼    
 诺贝尔   | 2011-06-08 23:14
用类来表示,比学习复杂的字符串解析算法要高明很多.
赞一个,是一个不错的入门.
支持(0)反对(0)
#11楼    
 G yc {Son of VB.NET}   | 2011-06-09 01:41
先支持一下


补充一个， 还有 字母或下划线开头
支持(0)反对(0)
#12楼    
 Treenew Lyn   | 2011-06-09 08:08
继续关注。楼上也别太较真。楼主是以简单易懂的方式入门。如果面面俱到，那阅读起来就会很困难的。
支持(0)反对(0)
#13楼    
 君之蘭   | 2011-06-09 09:22
持续关注
支持(0)反对(0)
#14楼    
 Zhenway   | 2011-06-09 09:25
继续关注
我现在遇到的最大的问题是如何解析c#中类似linq的语法
在c#里面，from/where/select等都不是关键字，不过，当写linq语句时，这些又变了关键字，真想知道c#编译器是如何实现这样的效果
eg.
object[] select = new object[0];//这里的select明显不是关键字，不需要用@
var where = from @from in @select select @from;//而这里的select明显是关键字，不用@会报错
支持(0)反对(0)
#15楼    
 蛙蛙王子   | 2011-06-09 09:25
不知道多少人能看懂
支持(0)反对(0)
#16楼    
 红泥   | 2011-06-09 09:30
搬个板凳好好听讲
支持(0)反对(0)
#17楼    
 Ivony...   | 2011-06-09 09:43
引用
Zhenway：
继续关注
我现在遇到的最大的问题是如何解析c#中类似linq的语法
在c#里面，from/where/select等都不是关键字，不过，当写linq语句时，这些又变了关键字，真想知道c#编译器是如何实现这样的效果
eg.
object[] select = new object[0];//这里的select明显不是关键字，不需要用@
var where = from @from in @select select @from;//而这里的select明显是关键字，不用@会报错



上下文关键字，没有上下文的概念的话当然是没法处理的。

词法分析阶段最重要的工作还是断词。
支持(0)反对(0)
#18楼    
 gtts   | 2011-06-09 09:47
学了很多，经楼主这么一分析，明朗了很多，期待...
支持(0)反对(0)
#19楼    
 咕嚕咕嚕   | 2011-06-09 09:56
搬个板凳听大师讲课
支持(0)反对(0)
#20楼    
 AlexTiffy   | 2011-06-09 10:22
不过瘾，太少了，量不足，楼主认识快乐？
支持(0)反对(0)
#21楼    
 testzhangsan   | 2011-06-09 10:28
非常不错，期待下篇！
支持(0)反对(0)
#22楼    
 AlexTiffy   | 2011-06-09 10:30
vbf是做什么用的，没有文档额？？
支持(0)反对(0)
#23楼    
 木+头   | 2011-06-09 10:57
楼主给力,期待
支持(0)反对(0)
#24楼    
 麒麟.NET   | 2011-06-09 11:01
很多概念都是第一次听说，汗啊……
不过脑袋的文章通俗易懂，赞啊……
支持(0)反对(0)
#25楼    
 陈梓瀚(vczh)   | 2011-06-09 11:05
@蛙蛙王子
from不需要当成一个关键字。做法大概是，如果你发现一个expression的第一个token是"from"，那么先尝试分析成linq，失败了再当普通expression处理。
支持(0)反对(0)
#26楼[楼主]    
 装配脑袋   | 2011-06-09 11:11
@Zhenway
你看看上面vczh大虾的做法，我也会介绍我的做法，不过要比较靠后面了，先捡基本的讲~
支持(0)反对(0)
#27楼[楼主]    
 装配脑袋   | 2011-06-09 11:12
@AlexTiffy
“快乐”是个人名吗。。不认识状。。
支持(0)反对(0)
#28楼[楼主]    
 装配脑袋   | 2011-06-09 11:13
@G yc {Son of VB.NET}
别急呀，后面还要支持中文呢
支持(0)反对(0)
#29楼    
 Zhenway   | 2011-06-09 11:15
@装配脑袋
期待中
支持(0)反对(0)
#30楼    
 xiao ming   | 2011-06-09 11:20
讲的不错，持续关注中
支持(0)反对(0)
#31楼    
 徐培华   | 2011-06-09 11:39
脑子咋这么聪明的，
有木有~~~！！
哥比不起呀比不起。
支持(0)反对(0)
#32楼    
 YTYT2002YTYT   | 2011-06-09 12:09
跟着楼主学习！
支持(0)反对(0)
#33楼    
 Shikyoh   | 2011-06-09 12:48
前来膜拜 ，技术学习
支持(0)反对(0)
#34楼    
 dax.net   | 2011-06-09 12:55
牛人，膜拜！
如今能潜心研究计算机基础学科相关的人已经很少了。。。
支持(0)反对(0)
#35楼    
 FireWard   | 2011-06-09 13:26
一天到晚潜水的鱼
支持(0)反对(0)
#36楼    
 道法自然   | 2011-06-09 13:53
Cool，直接学习了LZ的总结了。
支持(0)反对(0)
#37楼    
 mickeysuda   | 2011-06-09 15:02
期待到大结局
支持(0)反对(0)
#38楼    
 Jeffrey Zhao   | 2011-06-09 16:07
我爱脑袋
支持(0)反对(0)
#39楼    
 Old   | 2011-06-09 17:02
龙书还是没看懂，悲催啊。编译原理之痛
支持(0)反对(0)
#40楼    
 FireWard   | 2011-06-10 10:49
虎书是啥书，科普一下好伐
支持(0)反对(0)
#41楼    
 天堂十八楼   | 2011-06-10 22:05
正好这学期的期末设计就有一个是设计个编译器，学习了！！！
支持(0)反对(0)
#42楼[楼主]    
 装配脑袋   | 2011-06-11 09:45
@FireWard
是Modern Compiler by Andrew W. Appel
支持(0)反对(0)
#43楼    
 陈国立   | 2011-06-11 21:20
谢谢博的分享，看过知道才知道正则原来是这么回事，以前只知道用，不知道为什么那么用！现在总算明白了。
支持(0)反对(0)
#44楼    
 卡索   | 2011-06-13 12:08
用户了很长时间的正则表达式，看完本文，又多知道了一点关于正则的知识啊...
支持(0)反对(0)
#45楼    
 Air`_氵桀╱   | 2011-06-19 00:20
学习中。。。
支持(0)反对(0)
#46楼    
 肖敏   | 2011-06-23 14:46
我用我的脑袋顶脑袋
支持(0)反对(0)
#47楼    
 royen   | 2011-07-14 14:06
学习+关注...
支持(0)反对(0)
#48楼    
 鸽子飞扬   | 2011-08-28 21:31
上学的时候编译原理竟然是选修，而我竟然没选，悲剧啊，最近独自一个人在肯龙书，第一遍看得很辛苦，第二遍稍有收获，支持脑袋，我也想充实一下自己的脑袋，关注脑袋。
支持(0)反对(0)
#49楼    
 無羽   | 2012-11-09 12:06
膜拜~
支持(0)反对(0)
刷新评论刷新页面返回顶部
注册用户登录后才能发表评论，请 登录 或 注册，访问网站首页。
博客园首页博问新闻闪存程序员招聘知识库

最新IT新闻:
· 裁员伤透了中兴员工的心！
· LG收购WebOS资产
· “百度第二司机”车祸离世 十五万网友微博悼念
· 埃洛普：诺基亚不会推出WP8全键盘手机
· iOS被批创新力不足：将成为苹果的Windows XP
» 更多新闻...
最新知识库文章:
· 为什么很多人工作都不开心？
· 不用IDE写C#的Hello World
· 注重实效的架构师——大胆行前人未行之路
· 走向“持续部署”
· curl 网站开发指南
» 更多知识库文章...

公告

昵称：装配脑袋
园龄：8年2个月
荣誉：推荐博客
粉丝：626
关注：8
+加关注
<	2011年6月	>
日	一	二	三	四	五	六
29	30	31	1	2	3	4
5	6	7	8	9	10	11
12	13	14	15	16	17	18
19	20	21	22	23	24	25
26	27	28	29	30	1	2
3	4	5	6	7	8	9
搜索

 
常用链接

我的随笔
我的评论
我的参与
最新评论
我的标签
我的标签

Expression Tree(1)
VB10 C#4 .NET4 泛型 协变 反变(1)
随笔分类

Visual Basic 9.0 前沿播报(10)
随笔档案

2012年1月 (1)
2011年8月 (2)
2011年7月 (3)
2011年6月 (10)
2009年12月 (2)
2009年11月 (3)
2009年9月 (1)
2009年8月 (3)
2009年4月 (1)
2008年11月 (2)
2007年11月 (2)
2006年6月 (2)
2006年4月 (2)
2006年3月 (2)
2006年2月 (2)
2006年1月 (3)
2005年11月 (3)
2005年10月 (3)
2005年9月 (9)
2005年5月 (1)
2005年4月 (1)
2004年12月 (1)
积分与排名

积分 - 258093
排名 - 314
最新评论

1. Re:Expression Tree上手指南 （一）
@J-Pei引用Expression<Func<tWorkOrderDetail, int>> aaa = (tWorkOrderDetail a) => a.tWorkOrder.iDDBH; 怎样动态生成 class tWorkOrder { public int iDDBH { get; set; } } ...
--吴东雷
2. Re:Expression Tree上手指南 （一）
我练习的代码： ParameterExpression expA_double = Expression.Parameter(typeof(double), "a"); ParameterExpression expB_double = Expression.Parameter(typeof(double), "b"); P...
--吴东雷
3. Re:Expression Tree 上手指南 （二）
为什么图都坏掉了呢？
--吴东雷
4. Re:Expression Tree 上手指南 （三）
精彩期待继续。
--楚萧萧
5. Re:自己动手开发编译器（三）有穷自动机
看了下你的NFA转DFA代码，其实没必要直接翻译算法，因为每次都要求T'里所有状态能到达的状态集的并集。这个问题可以转换为图的遍历，下面是我写的伪代码：
//输入: 原状态集org
//输出: closure(org)
Set<State> closure(Set<State> org)
{ //存放结果 Set<State> res = new HashSet<State>(); ...
--有来 有去
阅读排行榜

1. 自己动手开发编译器（零）序言(12673)
2. VS2008亮点：用Lambda表达式进行函数式编程(10532)
3. Expression Tree上手指南 （一）(10504)
4. .NET 4.0中的泛型协变和反变(10500)
5. 自己动手开发编译器（二）正则语言和正则表达式(9081)
评论排行榜

1. 自己动手开发编译器（零）序言(87)
2. Expression Tree上手指南 （一）(73)
3. VS2008亮点：用Lambda表达式进行函数式编程(50)
4. 自己动手开发编译器（二）正则语言和正则表达式(49)
5. 自己动手开发编译器（三）有穷自动机(48)
推荐排行榜

1. 自己动手开发编译器（零）序言(62)
2. 自己动手开发编译器（一）编译器的模块化工程(28)
3. Expression Tree上手指南 （一）(28)
4. 自己动手开发编译器（十二）生成托管代码(23)
5. 自己动手开发编译器（三）有穷自动机(21)
